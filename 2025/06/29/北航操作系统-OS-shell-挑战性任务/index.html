<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>北航操作系统-OS-shell-挑战性任务 | lucky-sheltered-boy's Blog</title><meta name="author" content="Jiyuan Zhao"><meta name="copyright" content="Jiyuan Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="我实现挑战性任务的顺序并不是按照题目顺序，而是根据我认为的合理顺序来实现的，实验报告也将按照我实现指令的顺序来书写。  重写 sh.c 架构指导书中提出， Shell是一种命令解释器，对输入指令进行解析并执行。现有MOS实现的Shell较为简陋，如果在其基础上尝试实现挑战性任务内容可能复杂度较高，可以参考sh,bash等工业界shell实现原理进行重新实现，以下是一个可行的实现方案:  因此，我">
<meta property="og:type" content="article">
<meta property="og:title" content="北航操作系统-OS-shell-挑战性任务">
<meta property="og:url" content="http://example.com/2025/06/29/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-shell-%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1/index.html">
<meta property="og:site_name" content="lucky-sheltered-boy&#39;s Blog">
<meta property="og:description" content="我实现挑战性任务的顺序并不是按照题目顺序，而是根据我认为的合理顺序来实现的，实验报告也将按照我实现指令的顺序来书写。  重写 sh.c 架构指导书中提出， Shell是一种命令解释器，对输入指令进行解析并执行。现有MOS实现的Shell较为简陋，如果在其基础上尝试实现挑战性任务内容可能复杂度较高，可以参考sh,bash等工业界shell实现原理进行重新实现，以下是一个可行的实现方案:  因此，我">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG">
<meta property="article:published_time" content="2025-06-29T12:50:00.000Z">
<meta property="article:modified_time" content="2026-02-05T16:53:05.428Z">
<meta property="article:author" content="Jiyuan Zhao">
<meta property="article:tag" content="MOS">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "北航操作系统-OS-shell-挑战性任务",
  "url": "http://example.com/2025/06/29/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-shell-%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1/",
  "image": "https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG",
  "datePublished": "2025-06-29T12:50:00.000Z",
  "dateModified": "2026-02-05T16:53:05.428Z",
  "author": [
    {
      "@type": "Person",
      "name": "Jiyuan Zhao",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/06/29/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-shell-%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '北航操作系统-OS-shell-挑战性任务',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lucky-sheltered-boy's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">北航操作系统-OS-shell-挑战性任务</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">北航操作系统-OS-shell-挑战性任务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-06-29T12:50:00.000Z" title="Created 2025-06-29 20:50:00">2025-06-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-05T16:53:05.428Z" title="Updated 2026-02-06 00:53:05">2026-02-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">23.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>114mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>我实现挑战性任务的顺序并不是按照题目顺序，而是根据我认为的合理顺序来实现的，实验报告也将按照我实现指令的顺序来书写。</p>
</blockquote>
<h3 id="重写-sh-c-架构"><a href="#重写-sh-c-架构" class="headerlink" title="重写 sh.c 架构"></a>重写 sh.c 架构</h3><p>指导书中提出， Shell是一种命令解释器，对输入指令进行解析并执行。现有MOS实现的Shell较为简陋，如果在其基础上尝试实现挑战性任务内容可能复杂度较高，可以参考sh,bash等工业界shell实现原理进行重新实现，以下是一个可行的实现方案:</p>
<p><img src="/pictures/image-5.png" alt="alt text"></p>
<p>因此，我第一步先按照上述架构把 sh.c 重写了一遍，抛弃了原有课程组的代码，按照AST语法树来解析输入。代码如下（最后的完整版代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;args.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_INPUT_BUF 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TOKEN_LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMD_ARGS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VAR_NAME_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VAR_VALUE_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SHELL_VARS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EXPANDED_STR_LEN (MAX_TOKEN_LEN * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UP <span class="string">&#x27;A&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOWN <span class="string">&#x27;B&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OTHER -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HISTFILESIZE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HISTORY_FILE <span class="string">&quot;/.mos_history&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITESPACE <span class="string">&quot; \t\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMD_SUBST_OUTPUT_LEN (MAX_INPUT_BUF * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMD_SUBST_BUFFERS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> cmd_subst_output_pool[MAX_CMD_SUBST_BUFFERS][MAX_CMD_SUBST_OUTPUT_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cmd_subst_output_pool_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">execute_command_substitution</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* command_to_run, <span class="type">int</span> parent_is_interactive)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> history_lines[HISTFILESIZE][MAX_INPUT_BUF];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> history_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> history_add_idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> history_latest_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> current_typed_line[MAX_INPUT_BUF] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> expansion_buffer_pool[<span class="number">100</span>][MAX_EXPANDED_STR_LEN];</span><br><span class="line"><span class="type">int</span> expansion_buffer_pool_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">expand_string_variables</span><span class="params">(<span class="type">char</span> *input_str)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymemmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_history</span><span class="params">(<span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_history</span><span class="params">(<span class="type">char</span> ope[][<span class="number">600</span>],<span class="type">int</span> *sz)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> value[MAX_VAR_VALUE_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> is_exported;</span><br><span class="line">    <span class="type">int</span> is_readonly;</span><br><span class="line">    <span class="type">int</span> is_set;</span><br><span class="line">&#125; ShellVar;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> ShellVar shell_vars[MAX_SHELL_VARS];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_set_vars = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_shell_vars</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ShellVar* <span class="title function_">find_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">set_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> export_flag, <span class="type">int</span> readonly_flag, <span class="type">int</span> update_flags_if_exists)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unset_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_all_variables</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_variable_value</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> <span class="title">ASTNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NODE_ILLEGAL = <span class="number">0</span>,</span><br><span class="line">    NODE_COMMAND,</span><br><span class="line">    NODE_PIPELINE,</span><br><span class="line">    NODE_LIST_SEMI,</span><br><span class="line">    NODE_LIST_AMP,</span><br><span class="line">    NODE_AND,</span><br><span class="line">    NODE_OR,</span><br><span class="line">&#125; ASTNodeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TOKEN_ERROR = <span class="number">0</span>,</span><br><span class="line">    TOKEN_EOF = <span class="number">1</span>,</span><br><span class="line">    TOKEN_EOL = <span class="number">2</span>,</span><br><span class="line">    TOKEN_WORD,</span><br><span class="line">    TOKEN_PIPE,</span><br><span class="line">    TOKEN_SEMI,</span><br><span class="line">    TOKEN_AMP,</span><br><span class="line">    TOKEN_AND,</span><br><span class="line">    TOKEN_OR,</span><br><span class="line">    TOKEN_REDIR_IN,</span><br><span class="line">    TOKEN_REDIR_OUT,</span><br><span class="line">    TOKEN_REDIR_APP,</span><br><span class="line">&#125; TokenType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TokenType type;</span><br><span class="line">    <span class="type">char</span> value[MAX_TOKEN_LEN];</span><br><span class="line">&#125; Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    REDIR_TYPE_IN,</span><br><span class="line">    REDIR_TYPE_OUT,</span><br><span class="line">    REDIR_TYPE_APP,</span><br><span class="line">&#125; RedirType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RedirNode</span> &#123;</span></span><br><span class="line">    RedirType type;</span><br><span class="line">    <span class="type">char</span> *filename;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RedirNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RedirNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *argv[MAX_CMD_ARGS];</span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    RedirNode *redirects;</span><br><span class="line">&#125; CMDNodeData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ASTNode *left;</span><br><span class="line">    ASTNode *right;</span><br><span class="line">&#125; BinaryOpNodeData;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> &#123;</span></span><br><span class="line">    ASTNodeType type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        CMDNodeData command;</span><br><span class="line">        BinaryOpNodeData binary_op;</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_list</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n, <span class="type">int</span> interactive)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_ast_resources</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> strdup_pool[<span class="number">100</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> strdup_pool_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ASTNode astnode_pool[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> astnode_pool_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RedirNode redirnode_pool[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> redirnode_pool_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_subst_output_buffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cmd_subst_output_pool_idx &gt;= MAX_CMD_SUBST_BUFFERS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sh: too many command substitutions on one line\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (MAX_CMD_SUBST_BUFFERS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cmd_subst_output_pool[MAX_CMD_SUBST_BUFFERS <span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        user_panic(<span class="string">&quot;cmd_subst_output_pool out of space and no fallback buffer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cmd_subst_output_pool[cmd_subst_output_pool_idx], <span class="number">0</span>, MAX_CMD_SUBST_OUTPUT_LEN);</span><br><span class="line">    <span class="keyword">return</span> cmd_subst_output_pool[cmd_subst_output_pool_idx++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">execute_command_substitution</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* command_to_run, <span class="type">int</span> parent_is_interactive)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> child_pid_for_sh_c;</span><br><span class="line">    <span class="type">char</span> *output_buffer = get_subst_output_buffer();</span><br><span class="line">    output_buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    u_int output_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> read_char;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_fds) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sh: pipe failed for command substitution\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> output_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    child_pid_for_sh_c = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid_for_sh_c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sh: fork failed for command substitution\n&quot;</span>);</span><br><span class="line">        close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> output_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid_for_sh_c == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (dup(pipe_fds[<span class="number">1</span>], <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;sh: dup stdout to pipe failed in cmd_subst child\n&quot;</span>);</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">char</span> temp_cmd_buffer_for_argv[MAX_INPUT_BUF];</span><br><span class="line">        mystrcpy(temp_cmd_buffer_for_argv, command_to_run);</span><br><span class="line">        <span class="type">char</span> *sh_argv[] = &#123;<span class="string">&quot;sh.b&quot;</span>, <span class="string">&quot;-c&quot;</span>, temp_cmd_buffer_for_argv, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        spawn(<span class="string">&quot;/sh.b&quot;</span>, sh_argv);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> ((r = read(pipe_fds[<span class="number">0</span>], &amp;read_char, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output_len &lt; MAX_CMD_SUBST_OUTPUT_LEN - <span class="number">1</span>) &#123;</span><br><span class="line">                output_buffer[output_len++] = read_char;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                debugf(<span class="string">&quot;sh: command substitution output too long, truncated.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(read(pipe_fds[<span class="number">0</span>], &amp;read_char, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh: error reading from pipe in command substitution\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[output_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">        wait(child_pid_for_sh_c, <span class="literal">NULL</span>); <span class="comment">// Modified to match new wait signature if necessary</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (output_len &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">               (output_buffer[output_len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span> || output_buffer[output_len - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)) &#123;</span><br><span class="line">            output_buffer[--output_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; output_len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output_buffer[i] == <span class="string">&#x27;\n&#x27;</span> || output_buffer[i] == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">                output_buffer[i] = <span class="string">&#x27; &#x27;</span>; <span class="comment">// Changed from &#x27;\0&#x27; to &#x27; &#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get_subst_output_buffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset_allocators</span><span class="params">()</span> &#123;</span><br><span class="line">    strdup_pool_index = <span class="number">0</span>;</span><br><span class="line">    astnode_pool_index = <span class="number">0</span>;</span><br><span class="line">    redirnode_pool_index = <span class="number">0</span>;</span><br><span class="line">    expansion_buffer_pool_index = <span class="number">0</span>;</span><br><span class="line">    cmd_subst_output_pool_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">user_strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(s) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;strdup: string too long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strdup_pool_index &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;strdup_pool out of space&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *new_s = strdup_pool[strdup_pool_index++];</span><br><span class="line">    <span class="built_in">memcpy</span>(new_s, s, len);</span><br><span class="line">    <span class="keyword">return</span> new_s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">alloc_ast_node</span><span class="params">(ASTNodeType type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (astnode_pool_index &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;astnode_pool out of space&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ASTNode *node = &amp;astnode_pool[astnode_pool_index++];</span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(ASTNode));</span><br><span class="line">    node-&gt;type = type;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedirNode *<span class="title function_">alloc_redir_node</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (redirnode_pool_index &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;redirnode_pool out of space&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RedirNode *node = &amp;redirnode_pool[redirnode_pool_index++];</span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(RedirNode));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *current_pos;</span><br><span class="line"><span class="type">static</span> Token current_token;</span><br><span class="line"><span class="type">static</span> Token peeked_token;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> has_peeked_token;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skip_whitespace_and_comments</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*current_pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(<span class="string">&quot; \t\r\n&quot;</span>, *current_pos)) &#123;</span><br><span class="line">            current_pos++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (*current_pos &amp;&amp; *current_pos != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                current_pos++;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                 current_pos++;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Token <span class="title function_">get_next_raw_token</span><span class="params">()</span> &#123;</span><br><span class="line">    Token token;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;token, <span class="number">0</span>, <span class="keyword">sizeof</span>(Token));</span><br><span class="line">    token.type = TOKEN_ERROR;</span><br><span class="line"></span><br><span class="line">    skip_whitespace_and_comments();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_EOF;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mystrncmp(current_pos, <span class="string">&quot;&amp;&amp;&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        token.type = TOKEN_AND;</span><br><span class="line">        mystrncpy(token.value, <span class="string">&quot;&amp;&amp;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        token.value[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrncmp(current_pos, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        token.type = TOKEN_OR;</span><br><span class="line">        mystrncpy(token.value, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        token.value[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrncmp(current_pos, <span class="string">&quot;&gt;&gt;&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        token.type = TOKEN_REDIR_APP;</span><br><span class="line">        mystrncpy(token.value, <span class="string">&quot;&gt;&gt;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        token.value[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_PIPE;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;|&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;;&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_SEMI;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;;&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_AMP;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;&amp;&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_REDIR_IN;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;&lt;&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;&gt;&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_REDIR_OUT;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;&gt;&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;`&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_WORD;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        token.value[i++] = *current_pos++;</span><br><span class="line">        <span class="keyword">while</span> (*current_pos &amp;&amp; i &lt; MAX_TOKEN_LEN - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;`&#x27;</span>) &#123;</span><br><span class="line">                token.value[i++] = *current_pos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            token.value[i++] = *current_pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        token.value[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; token.value[i<span class="number">-1</span>] != <span class="string">&#x27;`&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh: unclosed backtick\n&quot;</span>);</span><br><span class="line">            token.type = TOKEN_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (i==<span class="number">1</span> &amp;&amp; token.value[<span class="number">0</span>] == <span class="string">&#x27;`&#x27;</span> &amp;&amp; *current_pos == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                token.type = TOKEN_ERROR;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        token.type = TOKEN_WORD;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (*current_pos &amp;&amp;</span><br><span class="line">               !<span class="built_in">strchr</span>(<span class="string">&quot; \t\r\n&quot;</span>, *current_pos) &amp;&amp;</span><br><span class="line">               !<span class="built_in">strchr</span>(<span class="string">&quot;|;&amp;&lt;&gt;`#&quot;</span>, *current_pos) &amp;&amp;</span><br><span class="line">               i &lt; MAX_TOKEN_LEN - <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (mystrncmp(current_pos, <span class="string">&quot;&amp;&amp;&quot;</span>, <span class="number">2</span>) == <span class="number">0</span> ||</span><br><span class="line">                mystrncmp(current_pos, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>) == <span class="number">0</span> ||</span><br><span class="line">                mystrncmp(current_pos, <span class="string">&quot;&gt;&gt;&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            token.value[i++] = *current_pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        token.value[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;\0&#x27;</span>) token.type = TOKEN_EOF;</span><br><span class="line">             <span class="keyword">else</span> token.type = TOKEN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tokenizer_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *input)</span> &#123;</span><br><span class="line">    current_pos = input;</span><br><span class="line">    has_peeked_token = <span class="number">0</span>;</span><br><span class="line">    current_token = get_next_raw_token();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Token <span class="title function_">consume_token</span><span class="params">()</span> &#123;</span><br><span class="line">    Token old_current = current_token;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type == TOKEN_EOF) <span class="keyword">return</span> old_current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_peeked_token) &#123;</span><br><span class="line">        current_token = peeked_token;</span><br><span class="line">        has_peeked_token = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current_token = get_next_raw_token();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old_current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Token <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type == TOKEN_EOF) <span class="keyword">return</span> current_token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!has_peeked_token) &#123;</span><br><span class="line">        peeked_token = get_next_raw_token();</span><br><span class="line">        has_peeked_token = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> peeked_token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_and_or</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ASTNode *<span class="title function_">parse_pipeline</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ASTNode *<span class="title function_">parse_command</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_line</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parse_list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_list</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_and_or();</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_SEMI || current_token.type == TOKEN_AMP) &#123;</span><br><span class="line">        TokenType op_type = current_token.type;</span><br><span class="line">        consume_token();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) &#123;</span><br><span class="line">            ASTNode *new_list_node = alloc_ast_node(op_type == TOKEN_SEMI ? NODE_LIST_SEMI : NODE_LIST_AMP);</span><br><span class="line">            new_list_node-&gt;data.binary_op.left = node;</span><br><span class="line">            new_list_node-&gt;data.binary_op.right = <span class="literal">NULL</span>;</span><br><span class="line">            node = new_list_node;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ASTNode *right_node = parse_and_or();</span><br><span class="line">        <span class="keyword">if</span> (!right_node &amp;&amp; (op_type == TOKEN_SEMI || (op_type == TOKEN_AMP &amp;&amp; current_token.type != TOKEN_EOF &amp;&amp; current_token.type != TOKEN_EOL ) ) ) &#123;</span><br><span class="line">             debugf(<span class="string">&quot;Syntax error after &#x27;%s&#x27;\n&quot;</span>, op_type == TOKEN_SEMI ? <span class="string">&quot;;&quot;</span> : <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ASTNode *new_list_node = alloc_ast_node(op_type == TOKEN_SEMI ? NODE_LIST_SEMI : NODE_LIST_AMP);</span><br><span class="line">        new_list_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_list_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_list_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_and_or</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_pipeline();</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_AND || current_token.type == TOKEN_OR) &#123;</span><br><span class="line">        TokenType op_type = current_token.type;</span><br><span class="line">        consume_token();</span><br><span class="line">        ASTNode *right_node = parse_pipeline();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error: &#x27;%s&#x27; not followed by pipeline\n&quot;</span>, op_type == TOKEN_AND ? <span class="string">&quot;&amp;&amp;&quot;</span> : <span class="string">&quot;||&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_op_node = alloc_ast_node(op_type == TOKEN_AND ? NODE_AND : NODE_OR);</span><br><span class="line">        new_op_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_op_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_op_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_pipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_command();</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_PIPE) &#123;</span><br><span class="line">        consume_token();</span><br><span class="line">        ASTNode *right_node = parse_command();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error: &#x27;|&#x27; not followed by command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_pipe_node = alloc_ast_node(NODE_PIPELINE);</span><br><span class="line">        new_pipe_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_pipe_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_pipe_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_command</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type != TOKEN_WORD &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_IN &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_OUT &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_APP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASTNode *cmd_node_ast = alloc_ast_node(NODE_COMMAND);</span><br><span class="line">    CMDNodeData *cmd_data = &amp;cmd_node_ast-&gt;data.command;</span><br><span class="line">    RedirNode **next_redir_ptr = &amp;cmd_data-&gt;redirects;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent_shell_is_interactive = iscons(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_WORD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmd_data-&gt;argc &lt; MAX_CMD_ARGS - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> *arg_after_var_expansion = expand_string_variables(current_token.value);</span><br><span class="line">                <span class="type">char</span> *final_arg_for_argv = arg_after_var_expansion;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> rebuilt_arg_buffer[MAX_EXPANDED_STR_LEN * <span class="number">2</span>];</span><br><span class="line">                rebuilt_arg_buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="type">char</span> *current_rebuilt_ptr = rebuilt_arg_buffer;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *scan_ptr = arg_after_var_expansion;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (*scan_ptr) &#123;</span><br><span class="line">                    <span class="type">char</span> *backtick_start = <span class="built_in">strchr</span>(scan_ptr, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (backtick_start) &#123;</span><br><span class="line">                        <span class="type">char</span> *backtick_end = <span class="built_in">strchr</span>(backtick_start + <span class="number">1</span>, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (backtick_end) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (backtick_start &gt; scan_ptr) &#123;</span><br><span class="line">                                mystrncpy(current_rebuilt_ptr, scan_ptr, backtick_start - scan_ptr);</span><br><span class="line">                                current_rebuilt_ptr += (backtick_start - scan_ptr);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="type">char</span> cmd_to_subst[MAX_INPUT_BUF];</span><br><span class="line">                            <span class="type">int</span> cmd_len = backtick_end - (backtick_start + <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span> (cmd_len &gt;= MAX_INPUT_BUF) cmd_len = MAX_INPUT_BUF <span class="number">-1</span>;</span><br><span class="line">                            mystrncpy(cmd_to_subst, backtick_start + <span class="number">1</span>, cmd_len);</span><br><span class="line">                            cmd_to_subst[cmd_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                            <span class="type">char</span> *subst_output = execute_command_substitution(cmd_to_subst, parent_shell_is_interactive);</span><br><span class="line">                            <span class="keyword">if</span> (subst_output) &#123;</span><br><span class="line">                                mystrcat(current_rebuilt_ptr, subst_output);</span><br><span class="line">                                current_rebuilt_ptr += mystrlen(subst_output);</span><br><span class="line">                            &#125;</span><br><span class="line">                            scan_ptr = backtick_end + <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mystrcat(current_rebuilt_ptr, scan_ptr);</span><br><span class="line">                            current_rebuilt_ptr += mystrlen(scan_ptr);</span><br><span class="line">                            scan_ptr += mystrlen(scan_ptr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mystrcat(current_rebuilt_ptr, scan_ptr);</span><br><span class="line">                        current_rebuilt_ptr += mystrlen(scan_ptr);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                *current_rebuilt_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rebuilt_arg_buffer[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span> || arg_after_var_expansion[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                    final_arg_for_argv = user_strdup(rebuilt_arg_buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    final_arg_for_argv = user_strdup(arg_after_var_expansion);</span><br><span class="line">                &#125;</span><br><span class="line">                cmd_data-&gt;argv[cmd_data-&gt;argc++] = final_arg_for_argv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">            consume_token();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_token.type == TOKEN_REDIR_IN ||</span><br><span class="line">                   current_token.type == TOKEN_REDIR_OUT ||</span><br><span class="line">                   current_token.type == TOKEN_REDIR_APP) &#123;</span><br><span class="line">            TokenType redir_op_type = current_token.type;</span><br><span class="line">            consume_token();</span><br><span class="line">            <span class="keyword">if</span> (current_token.type != TOKEN_WORD) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;Syntax error: Redirection operator not followed by filename\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RedirNode *redir_node = alloc_redir_node();</span><br><span class="line">            <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_IN) redir_node-&gt;type = REDIR_TYPE_IN;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_OUT) redir_node-&gt;type = REDIR_TYPE_OUT;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_APP) redir_node-&gt;type = REDIR_TYPE_APP;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> *filename_after_vars = expand_string_variables(current_token.value);</span><br><span class="line">            <span class="type">char</span> *final_filename = filename_after_vars;</span><br><span class="line">            <span class="comment">// Apply command substitution to filenames as well</span></span><br><span class="line">            <span class="type">char</span> rebuilt_fname_buffer[MAX_EXPANDED_STR_LEN * <span class="number">2</span>];</span><br><span class="line">            rebuilt_fname_buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="type">char</span> *current_rebuilt_fname_ptr = rebuilt_fname_buffer;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *scan_fname_ptr = filename_after_vars;</span><br><span class="line">            <span class="keyword">while</span>(*scan_fname_ptr)&#123;</span><br><span class="line">                <span class="type">char</span> *bt_start = <span class="built_in">strchr</span>(scan_fname_ptr, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(bt_start)&#123;</span><br><span class="line">                    <span class="type">char</span> *bt_end = <span class="built_in">strchr</span>(bt_start + <span class="number">1</span>, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(bt_end)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(bt_start &gt; scan_fname_ptr)&#123;</span><br><span class="line">                            mystrncpy(current_rebuilt_fname_ptr, scan_fname_ptr, bt_start - scan_fname_ptr);</span><br><span class="line">                            current_rebuilt_fname_ptr += (bt_start - scan_fname_ptr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">char</span> cmd_to_subst_fname[MAX_INPUT_BUF];</span><br><span class="line">                        <span class="type">int</span> cmd_len_fname = bt_end - (bt_start + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(cmd_len_fname &gt;= MAX_INPUT_BUF) cmd_len_fname = MAX_INPUT_BUF <span class="number">-1</span>;</span><br><span class="line">                        mystrncpy(cmd_to_subst_fname, bt_start + <span class="number">1</span>, cmd_len_fname);</span><br><span class="line">                        cmd_to_subst_fname[cmd_len_fname] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                        <span class="type">char</span> *subst_out_fname = execute_command_substitution(cmd_to_subst_fname, parent_shell_is_interactive);</span><br><span class="line">                        <span class="keyword">if</span>(subst_out_fname)&#123;</span><br><span class="line">                            mystrcat(current_rebuilt_fname_ptr, subst_out_fname);</span><br><span class="line">                            current_rebuilt_fname_ptr += mystrlen(subst_out_fname);</span><br><span class="line">                        &#125;</span><br><span class="line">                        scan_fname_ptr = bt_end + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mystrcat(current_rebuilt_fname_ptr, scan_fname_ptr);</span><br><span class="line">                        current_rebuilt_fname_ptr += mystrlen(scan_fname_ptr);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mystrcat(current_rebuilt_fname_ptr, scan_fname_ptr);</span><br><span class="line">                    current_rebuilt_fname_ptr += mystrlen(scan_fname_ptr);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            *current_rebuilt_fname_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(rebuilt_fname_buffer[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span> || filename_after_vars[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">                final_filename = user_strdup(rebuilt_fname_buffer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                final_filename = user_strdup(filename_after_vars);</span><br><span class="line">            &#125;</span><br><span class="line">            redir_node-&gt;filename = final_filename;</span><br><span class="line">            consume_token();</span><br><span class="line">            *next_redir_ptr = redir_node;</span><br><span class="line">            next_redir_ptr = &amp;redir_node-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cmd_data-&gt;argv[cmd_data-&gt;argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmd_data-&gt;argc == <span class="number">0</span> &amp;&amp; cmd_data-&gt;redirects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cmd_node_ast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset_expansion_buffer_pool</span><span class="params">()</span> &#123;</span><br><span class="line">    expansion_buffer_pool_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_expansion_buffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (expansion_buffer_pool_index &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;expansion_buffer_pool out of space&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(expansion_buffer_pool[expansion_buffer_pool_index], <span class="number">0</span>, MAX_EXPANDED_STR_LEN);</span><br><span class="line">    <span class="keyword">return</span> expansion_buffer_pool[expansion_buffer_pool_index++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">expand_string_variables</span><span class="params">( <span class="type">char</span> *input_str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!input_str || !<span class="built_in">strchr</span>(input_str, <span class="string">&#x27;$&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> user_strdup(input_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *output_buf = get_expansion_buffer();</span><br><span class="line">    output_buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *out_ptr = output_buf;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *in_ptr = input_str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*in_ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*in_ptr == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">            in_ptr++;</span><br><span class="line">            <span class="type">char</span> var_name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (*in_ptr &amp;&amp;</span><br><span class="line">                   i &lt; MAX_VAR_NAME_LEN &amp;&amp;</span><br><span class="line">                   !<span class="built_in">strchr</span>(<span class="string">&quot; \t\r\n$|;&amp;&lt;&gt;/`&quot;</span>, *in_ptr) <span class="comment">// Added ` to terminators</span></span><br><span class="line">                   ) &#123;</span><br><span class="line">                var_name[i++] = *in_ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            var_name[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *var_value = get_variable_value(var_name);</span><br><span class="line">                <span class="keyword">if</span> (var_value) &#123;</span><br><span class="line">                    <span class="type">size_t</span> val_len = mystrlen(var_value);</span><br><span class="line">                    <span class="keyword">if</span> ((out_ptr - output_buf) + val_len &lt; MAX_EXPANDED_STR_LEN) &#123;</span><br><span class="line">                        mystrcpy(out_ptr, var_value);</span><br><span class="line">                        out_ptr += val_len;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* Buffer overflow */</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((out_ptr - output_buf) &lt; MAX_EXPANDED_STR_LEN <span class="number">-1</span>) &#123;</span><br><span class="line">                    *out_ptr++ = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((out_ptr - output_buf) &lt; MAX_EXPANDED_STR_LEN - <span class="number">1</span>) &#123;</span><br><span class="line">                *out_ptr++ = *in_ptr++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                in_ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *out_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> output_buf; <span class="comment">// Returns from expansion_buffer_pool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_inner_cmd</span><span class="params">(CMDNodeData *cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;pwd&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;declare&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;unset&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_inner_cmd</span><span class="params">(CMDNodeData *cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;pwd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pwd: expected 0 arguments; got %d\n&quot;</span>, cmd-&gt;argc - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			syscall_get_cwd(buf);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">char</span> finalpath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span> (cmd-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">			mystrcpy(finalpath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            syscall_set_cwd(finalpath); <span class="comment">// cd to root if no argument</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">char</span> cwd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			syscall_get_cwd(cwd);</span><br><span class="line">			<span class="type">int</span> r;</span><br><span class="line">			<span class="keyword">if</span> ((r = get_final_path(cwd, cmd-&gt;argv[<span class="number">1</span>], finalpath)) == <span class="number">0</span>) &#123;</span><br><span class="line">				syscall_set_cwd(finalpath);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: The directory &#x27;%s&#x27; does not exist\n&quot;</span>, cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: &#x27;%s&#x27; is not a directory\n&quot;</span>, cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: error processing path (null args)\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-2</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: path too long\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-3</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: failed to normalize path\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;cd: too many arguments\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Default exit with 0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;declare&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> export_f = <span class="number">0</span>;</span><br><span class="line">       		<span class="type">int</span> readonly_f = <span class="number">0</span>;</span><br><span class="line">        	<span class="type">int</span> arg_idx = <span class="number">1</span>;</span><br><span class="line">        	<span class="type">char</span> *name_val_pair = <span class="literal">NULL</span>;</span><br><span class="line">        	<span class="keyword">while</span> (cmd-&gt;argv[arg_idx] &amp;&amp; cmd-&gt;argv[arg_idx][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            		<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-x&quot;</span>) == <span class="number">0</span>) export_f = <span class="number">1</span>;</span><br><span class="line">            		<span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-r&quot;</span>) == <span class="number">0</span>) readonly_f = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-xr&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">				 mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-rx&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				export_f = <span class="number">1</span>; readonly_f = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="built_in">printf</span>(<span class="string">&quot;declare: invalid option %s\n&quot;</span>, cmd-&gt;argv[arg_idx]);</span><br><span class="line">                		<span class="keyword">return</span>;</span><br><span class="line">            		&#125;</span><br><span class="line">            		arg_idx++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (cmd-&gt;argv[arg_idx]) &#123;</span><br><span class="line">            		name_val_pair = cmd-&gt;argv[arg_idx];</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (!name_val_pair) &#123;</span><br><span class="line">            		print_all_variables();</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            		<span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            		<span class="type">char</span> value_buf[MAX_VAR_VALUE_LEN + <span class="number">1</span>];</span><br><span class="line">            		<span class="type">char</span> *value_ptr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            		<span class="type">char</span> *eq_ptr = <span class="built_in">strchr</span>(name_val_pair, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            		<span class="keyword">if</span> (eq_ptr) &#123;</span><br><span class="line">                		<span class="type">int</span> name_len = eq_ptr - name_val_pair;</span><br><span class="line">                		<span class="keyword">if</span> (name_len &gt; MAX_VAR_NAME_LEN) &#123;<span class="built_in">printf</span>(<span class="string">&quot;sh: var name too long\n&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrncpy(name, name_val_pair, name_len);</span><br><span class="line">                		name[name_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                		value_ptr = eq_ptr + <span class="number">1</span>;</span><br><span class="line">                		<span class="keyword">if</span> (mystrlen(value_ptr) &gt; MAX_VAR_VALUE_LEN) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sh: var value too long\n&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrcpy(value_buf, value_ptr);</span><br><span class="line">                		value_ptr = value_buf;</span><br><span class="line">            		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="keyword">if</span> (mystrlen(name_val_pair) &gt; MAX_VAR_NAME_LEN) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sh: var name too long\n&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrcpy(name, name_val_pair);</span><br><span class="line">            		&#125;</span><br><span class="line">            		set_variable(name, value_ptr, export_f, readonly_f, <span class="number">1</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;unset&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (cmd-&gt;argc != <span class="number">2</span>) &#123;</span><br><span class="line">            		<span class="built_in">printf</span>(<span class="string">&quot;unset: usage: unset NAME\n&quot;</span>);</span><br><span class="line">            		<span class="keyword">return</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	unset_variable(cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">&quot;history: too many arguments\n&quot;</span>);</span><br><span class="line">        		<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="type">int</span> start_idx;</span><br><span class="line">    		<span class="keyword">if</span> (history_count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    		<span class="keyword">if</span> (history_count &lt; HISTFILESIZE) start_idx = <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">else</span> start_idx = history_add_idx;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; history_count; ++i) &#123;</span><br><span class="line">        		<span class="type">int</span> current_entry_idx = (start_idx + i) % HISTFILESIZE;</span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, history_lines[current_entry_idx]);</span><br><span class="line">    		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_final_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cwd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *finalpath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cwd || !path || !finalpath) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> constructed_path[MAXPATHLEN * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mystrlen(path) &gt;= MAXPATHLEN) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        mystrcpy(constructed_path, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mystrlen(cwd) + <span class="number">1</span> + mystrlen(path) + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(constructed_path)) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        mystrcpy(constructed_path, cwd);</span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span> &amp;&amp; constructed_path[mystrlen(constructed_path) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            mystrcat(constructed_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mystrcat(constructed_path, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (normalize_path(constructed_path) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// Only stat if original path was relative for cd behavior</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">        <span class="type">int</span> r_stat = stat(constructed_path, &amp;st);</span><br><span class="line">        <span class="keyword">if</span> (r_stat &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (st.st_isdir == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mystrcpy(finalpath, constructed_path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">normalize_path</span><span class="params">(<span class="type">char</span> *path_buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path_buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> components[MAX_CMD_ARGS][MAXNAMELEN];</span><br><span class="line">    <span class="type">int</span> comp_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = path_buf;</span><br><span class="line">    <span class="type">int</span> is_absolute = (*p == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        p++; <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="type">char</span> current_comp_val[MAXNAMELEN];</span><br><span class="line">        <span class="type">char</span> *c_ptr = current_comp_val;</span><br><span class="line">        <span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c_ptr - current_comp_val &lt; MAXNAMELEN - <span class="number">1</span>) *c_ptr++ = *p;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        *c_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &gt; <span class="number">0</span> &amp;&amp; mystrcmp(components[comp_idx - <span class="number">1</span>], <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) comp_idx--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute) &#123;</span><br><span class="line">                <span class="keyword">if</span> (comp_idx &lt; MAX_CMD_ARGS) mystrncpy(components[comp_idx++], <span class="string">&quot;..&quot;</span>, MAXNAMELEN<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; current_comp_val[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &lt; MAX_CMD_ARGS) mystrncpy(components[comp_idx++], current_comp_val, MAXNAMELEN<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *write_ptr = path_buf;</span><br><span class="line">    <span class="keyword">if</span> (is_absolute) *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; comp_idx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> || (is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i==<span class="number">0</span> &amp;&amp; write_ptr &gt; path_buf &amp;&amp; *(write_ptr<span class="number">-1</span>) != <span class="string">&#x27;/&#x27;</span>)) &#123; <span class="comment">// ensure slash for non-first components or if root isn&#x27;t only thing</span></span><br><span class="line">             <span class="keyword">if</span>(write_ptr == path_buf &amp;&amp; is_absolute &amp;&amp; *path_buf == <span class="string">&#x27;/&#x27;</span>)&#123;<span class="comment">/* no extra slash if only / */</span>&#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (write_ptr &gt; path_buf &amp;&amp; *(write_ptr<span class="number">-1</span>) != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (write_ptr - path_buf &gt;= MAXPATHLEN <span class="number">-1</span>) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">                *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (write_ptr == path_buf &amp;&amp; !is_absolute &amp;&amp; i &gt; <span class="number">0</span>) &#123; <span class="comment">// relative path, non-first component</span></span><br><span class="line">                <span class="keyword">if</span> (write_ptr - path_buf &gt;= MAXPATHLEN <span class="number">-1</span>) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">                 *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = mystrlen(components[i]);</span><br><span class="line">        <span class="keyword">if</span> ((write_ptr - path_buf) + len &gt;= MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        <span class="built_in">memcpy</span>(write_ptr, components[i], len);</span><br><span class="line">        write_ptr += len;</span><br><span class="line">    &#125;</span><br><span class="line">    *write_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (path_buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_absolute) mystrcpy(path_buf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> mystrcpy(path_buf, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; write_ptr == path_buf + <span class="number">1</span> &amp;&amp; path_buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; comp_idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Path was like &quot;//&quot; or &quot;/./&quot; or &quot;/foo/..&quot;, normalized to just &quot;/&quot;</span></span><br><span class="line">        <span class="comment">// Ensure it&#x27;s exactly &quot;/&quot; and not &quot;/\0&quot; if write_ptr is path_buf+1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; path_buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path_buf[<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path_buf[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123; <span class="comment">// Fix &quot;///&quot; to &quot;/&quot;</span></span><br><span class="line">	path_buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_ast</span><span class="params">(ASTNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> child_pid;</span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (node-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> NODE_COMMAND: &#123;</span><br><span class="line">            CMDNodeData *cmd = &amp;node-&gt;data.command;</span><br><span class="line">            <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">0</span> &amp;&amp; cmd-&gt;redirects == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">0</span> &amp;&amp; cmd-&gt;redirects != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 <span class="comment">// Handle redirection-only command if necessary, or error</span></span><br><span class="line">                 <span class="comment">// For now, if no command, but redirects, it&#x27;s tricky.</span></span><br><span class="line">                 <span class="comment">// Bash creates files but doesn&#x27;t run anything. Let&#x27;s assume error for simplicity.</span></span><br><span class="line">                 debugf(<span class="string">&quot;sh: missing command for redirection\n&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	    <span class="keyword">if</span> (is_inner_cmd(cmd)) &#123;</span><br><span class="line">	    	execute_inner_cmd(cmd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;execute_ast: fork failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">                RedirNode *redir = cmd-&gt;redirects;</span><br><span class="line">                <span class="keyword">while</span> (redir) &#123;</span><br><span class="line">                    <span class="type">int</span> open_flags = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> target_fd_std = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_IN) &#123; open_flags = O_RDONLY; target_fd_std = <span class="number">0</span>; &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_OUT) &#123; open_flags = O_WRONLY | O_CREAT | O_TRUNC; target_fd_std = <span class="number">1</span>; &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_APP) &#123; open_flags = O_WRONLY | O_CREAT | O_APPEND; target_fd_std = <span class="number">1</span>; &#125;</span><br><span class="line">                    <span class="type">int</span> opened_fd = open(redir-&gt;filename, open_flags);</span><br><span class="line">                    <span class="keyword">if</span> (opened_fd &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sh: cannot open %s\n&quot;</span>, redir-&gt;filename); <span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">                    dup(opened_fd, target_fd_std);</span><br><span class="line">                    close(opened_fd);</span><br><span class="line">                    redir = redir-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">		<span class="type">int</span> spawn_ret;</span><br><span class="line">		<span class="type">char</span> *spawn_argv[MAX_CMD_ARGS + MAX_SHELL_VARS + <span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> spawn_argc = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;sh.b&quot;</span>) == <span class="number">0</span> || mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;sh&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">		    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;/sh.b&quot;</span>) == <span class="number">0</span> || mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;/sh&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cmd-&gt;argc; ++i) spawn_argv[spawn_argc++] = cmd-&gt;argv[i];</span><br><span class="line">            <span class="type">char</span> env_str_pool[MAX_SHELL_VARS][MAX_VAR_NAME_LEN + MAX_VAR_VALUE_LEN + <span class="number">3</span>]; <span class="comment">// +2 for =,\0, +1 for readonly flag</span></span><br><span class="line">            <span class="type">int</span> env_str_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shell_vars[i].is_set &amp;&amp; shell_vars[i].is_exported) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (spawn_argc &lt; (MAX_CMD_ARGS + MAX_SHELL_VARS) &amp;&amp; env_str_idx &lt; MAX_SHELL_VARS) &#123;</span><br><span class="line">                        <span class="type">char</span> *current_env_str = env_str_pool[env_str_idx++];</span><br><span class="line">                        current_env_str[<span class="number">0</span>] = shell_vars[i].is_readonly ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>; <span class="comment">// Prepend readonly flag</span></span><br><span class="line">                        current_env_str[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// Null terminate after flag</span></span><br><span class="line">                        mystrcat(current_env_str, shell_vars[i].name);</span><br><span class="line">                        mystrcat(current_env_str, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">                        mystrcat(current_env_str, shell_vars[i].value);</span><br><span class="line">                        spawn_argv[spawn_argc++] = current_env_str;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            spawn_argv[spawn_argc] = <span class="literal">NULL</span>;</span><br><span class="line">			spawn_ret = spawn(cmd-&gt;argv[<span class="number">0</span>], spawn_argv);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               		spawn_ret = spawn(cmd-&gt;argv[<span class="number">0</span>], (<span class="type">char</span> **)cmd-&gt;argv);</span><br><span class="line">		&#125;</span><br><span class="line">                <span class="keyword">if</span> (spawn_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: failed to spawn &#x27;%s&#x27; (err %d)\n&quot;</span>, cmd-&gt;argv[<span class="number">0</span>], spawn_ret);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">127</span>); <span class="comment">// Standard for command not found</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Default success if spawn *somehow* returns but didn&#x27;t error.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wait(child_pid, <span class="literal">NULL</span>); <span class="comment">// Parent waits, ignore status for now</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NODE_PIPELINE: &#123;</span><br><span class="line">            <span class="keyword">if</span> (pipe(pipe_fds) &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;pipe creation failed&quot;</span>);</span><br><span class="line">            <span class="type">int</span> pid1 = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid1 &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for pipe left failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pid1 == <span class="number">0</span>) &#123;</span><br><span class="line">                close(pipe_fds[<span class="number">0</span>]); dup(pipe_fds[<span class="number">1</span>], <span class="number">1</span>); close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.left); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> pid2 = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid2 &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for pipe right failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pid2 == <span class="number">0</span>) &#123;</span><br><span class="line">                close(pipe_fds[<span class="number">1</span>]); dup(pipe_fds[<span class="number">0</span>], <span class="number">0</span>); close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            close(pipe_fds[<span class="number">0</span>]); close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">            wait(pid1, <span class="literal">NULL</span>); wait(pid2, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NODE_LIST_SEMI:</span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_LIST_AMP:</span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for &amp; failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123; execute_ast(node-&gt;data.binary_op.left); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_AND:</span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left); <span class="comment">// Needs status</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) execute_ast(node-&gt;data.binary_op.right); <span class="comment">// Temp</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_OR:</span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left); <span class="comment">// Needs status</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) execute_ast(node-&gt;data.binary_op.right); <span class="comment">// Temp</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            user_panic(<span class="string">&quot;Unknown AST node type: %d&quot;</span>, node-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> outbuf[<span class="number">20000</span>];</span><br><span class="line"><span class="type">char</span> now_cmd_buf[<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> all_line_count;</span><br><span class="line"><span class="type">int</span> now_line_index;</span><br><span class="line"><span class="type">char</span> all_lines[<span class="number">25</span>][<span class="number">1025</span>];</span><br><span class="line"><span class="type">char</span> copy_buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n, <span class="type">int</span> interactive)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int current_len; </span><br><span class="line">    u_int cursor_pos;  </span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    u_int onscreen_cmd_len = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">        mystrcpy(buf, current_typed_line); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">        <span class="keyword">if</span> (history_count &gt; <span class="number">0</span> &amp;&amp; history_current_nav_offset &lt;= history_count) &#123; </span><br><span class="line">             mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    current_len = mystrlen(buf);</span><br><span class="line">    cursor_pos = current_len; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive &amp;&amp; current_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r$ &quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; current_len; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">        onscreen_cmd_len = current_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = read(<span class="number">0</span>, &amp;c, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (interactive &amp;&amp; current_len == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buf[current_len] = <span class="number">0</span>; <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> requires_full_reprint = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0x1b</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123;</span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0x1b</span>) &#123; </span><br><span class="line">            <span class="type">char</span> seq[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;seq[<span class="number">0</span>], <span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (seq[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;seq[<span class="number">1</span>], <span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (history_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">                            mystrcpy(current_typed_line, buf); </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset &lt; history_count) &#123;</span><br><span class="line">                            history_current_nav_offset++;</span><br><span class="line">                            <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">                            mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">                            current_len = mystrlen(buf);</span><br><span class="line">                            cursor_pos = current_len;</span><br><span class="line">                            requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (history_current_nav_offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        history_current_nav_offset--;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">                            mystrcpy(buf, current_typed_line);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">                            mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        current_len = mystrlen(buf);</span><br><span class="line">                        cursor_pos = current_len;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        cursor_pos--;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;C&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                        cursor_pos++;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\b&#x27;</span> || c == <span class="number">0x7f</span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mymemmove(&amp;buf[cursor_pos - <span class="number">1</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                cursor_pos--;</span><br><span class="line">                current_len--;</span><br><span class="line">                requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x01</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (cursor_pos != <span class="number">0</span>) &#123; cursor_pos = <span class="number">0</span>; requires_full_reprint = <span class="number">1</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x05</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (cursor_pos != current_len) &#123; cursor_pos = current_len; requires_full_reprint = <span class="number">1</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x0B</span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                buf[cursor_pos] = <span class="string">&#x27;\0&#x27;</span>; current_len = cursor_pos; requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x15</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mymemmove(&amp;buf[<span class="number">0</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                current_len -= cursor_pos; cursor_pos = <span class="number">0</span>; requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x17</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                u_int original_cursor_pos = cursor_pos;</span><br><span class="line">                u_int end_of_deletion_span = cursor_pos;</span><br><span class="line">                <span class="keyword">while</span> (cursor_pos &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot; \t&quot;</span>, buf[cursor_pos - <span class="number">1</span>])) cursor_pos--;</span><br><span class="line">                u_int start_of_word_to_delete = cursor_pos;</span><br><span class="line">                <span class="keyword">while</span> (start_of_word_to_delete &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">strchr</span>(<span class="string">&quot; \t&quot;</span>, buf[start_of_word_to_delete - <span class="number">1</span>])) &#123;</span><br><span class="line">                    start_of_word_to_delete--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (start_of_word_to_delete &lt; end_of_deletion_span) &#123;</span><br><span class="line">                    mymemmove(&amp;buf[start_of_word_to_delete], &amp;buf[end_of_deletion_span], current_len - end_of_deletion_span + <span class="number">1</span>);</span><br><span class="line">                    current_len -= (end_of_deletion_span - start_of_word_to_delete);</span><br><span class="line">                    cursor_pos = start_of_word_to_delete;</span><br><span class="line">                    requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor_pos = original_cursor_pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span> || c == <span class="string">&#x27;\n&#x27;</span>) &#123; </span><br><span class="line">            buf[current_len] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interactive) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="number">0x20</span> &amp;&amp; c &lt; <span class="number">0x7f</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_len &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                    mymemmove(&amp;buf[cursor_pos + <span class="number">1</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buf[cursor_pos] = c;</span><br><span class="line">                current_len++;</span><br><span class="line">                cursor_pos++;</span><br><span class="line">                requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requires_full_reprint &amp;&amp; interactive) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; current_len; ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current_len &lt; onscreen_cmd_len) &#123;</span><br><span class="line">                <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; (onscreen_cmd_len - current_len); ++i) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u_int effective_displayed_cmd_len = (current_len &gt; onscreen_cmd_len) ? current_len : onscreen_cmd_len;</span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; (effective_displayed_cmd_len - cursor_pos); ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            onscreen_cmd_len = current_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> input_buf[MAX_INPUT_BUF];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usage: sh [-ix] [script-file]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_history</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd, r, i;</span><br><span class="line">    <span class="type">char</span> line_buf[MAX_INPUT_BUF];</span><br><span class="line">    <span class="type">int</span> line_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    history_count = <span class="number">0</span>;</span><br><span class="line">    history_add_idx = <span class="number">0</span>;</span><br><span class="line">    history_latest_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(HISTORY_FILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> temp_history_load[HISTFILESIZE][MAX_INPUT_BUF];</span><br><span class="line">    <span class="type">int</span> temp_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((r = read(fd, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                line_buf[line_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">                    mystrcpy(temp_history_load[temp_count++], line_buf);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; HISTFILESIZE - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                        mystrcpy(temp_history_load[i], temp_history_load[i+<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mystrcpy(temp_history_load[HISTFILESIZE<span class="number">-1</span>], line_buf);</span><br><span class="line">                &#125;</span><br><span class="line">                line_len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line_len &lt; MAX_INPUT_BUF - <span class="number">1</span>) &#123;</span><br><span class="line">            line_buf[line_len++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (line_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        line_buf[line_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">            mystrcpy(temp_history_load[temp_count++], line_buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; HISTFILESIZE - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                mystrcpy(temp_history_load[i], temp_history_load[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            mystrcpy(temp_history_load[HISTFILESIZE<span class="number">-1</span>], line_buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; temp_count; ++i) &#123;</span><br><span class="line">        mystrcpy(history_lines[history_add_idx], temp_history_load[i]);</span><br><span class="line">        history_latest_idx = history_add_idx;</span><br><span class="line">        history_add_idx = (history_add_idx + <span class="number">1</span>) % HISTFILESIZE;</span><br><span class="line">        <span class="keyword">if</span> (history_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">            history_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_history</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd, i, r;</span><br><span class="line">    <span class="type">int</span> start_idx;</span><br><span class="line"></span><br><span class="line">    fd = open(HISTORY_FILE, O_WRONLY | O_CREAT | O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sh: error saving history to %s\n&quot;</span>, HISTORY_FILE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_count == <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">        start_idx = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start_idx = history_add_idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; history_count; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> current_entry_idx = (start_idx + i) % HISTFILESIZE;</span><br><span class="line">        r = write(fd, history_lines[current_entry_idx], mystrlen(history_lines[current_entry_idx]));</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        r = write(fd, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_to_history</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd_line)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cmd_line[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_count &gt; <span class="number">0</span> &amp;&amp; mystrcmp(history_lines[history_latest_idx], cmd_line) == <span class="number">0</span>) &#123;</span><br><span class="line">        history_current_nav_offset = <span class="number">0</span>; <span class="comment">// Still reset nav offset</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mystrcpy(history_lines[history_add_idx], cmd_line);</span><br><span class="line">    history_latest_idx = history_add_idx;</span><br><span class="line">    history_add_idx = (history_add_idx + <span class="number">1</span>) % HISTFILESIZE;</span><br><span class="line">    <span class="keyword">if</span> (history_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">        history_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    init_shell_vars();</span><br><span class="line">    <span class="type">int</span> interactive = iscons(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> echocmds = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *command_string_from_arg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> arg_idx_after_opts = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; mystrcmp(argv[<span class="number">1</span>], <span class="string">&quot;-c&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            command_string_from_arg = argv[<span class="number">2</span>];</span><br><span class="line">            interactive = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Process other options if any for sh -c ... sh_options ... &quot;cmd&quot; arg1 arg2</span></span><br><span class="line">            <span class="comment">// For now, assume argv[0]=sh, argv[1]=-c, argv[2]=cmd_string</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh: -c option requires an argument\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123; <span class="comment">// Potential script file if not an option</span></span><br><span class="line">         <span class="comment">// This logic needs to be integrated with ARGBEGIN or done before.</span></span><br><span class="line">         <span class="comment">// Simplified: If first arg after &quot;sh&quot; is not an option, assume it&#x27;s a script file.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command_string_from_arg) &#123;</span><br><span class="line">        reset_allocators();</span><br><span class="line">        mystrcpy(input_buf, command_string_from_arg);</span><br><span class="line">        <span class="keyword">if</span> (echocmds) <span class="built_in">printf</span>(<span class="string">&quot;+ %s\n&quot;</span>, input_buf);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* temp_scan = input_buf;</span><br><span class="line">        <span class="keyword">while</span> (*temp_scan &amp;&amp; <span class="built_in">strchr</span>(WHITESPACE, *temp_scan)) temp_scan++;</span><br><span class="line">        <span class="keyword">if</span> (*temp_scan != <span class="string">&#x27;#&#x27;</span> &amp;&amp; *temp_scan != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            tokenizer_init(input_buf);</span><br><span class="line">            ASTNode *ast = parse_line();</span><br><span class="line">            <span class="keyword">if</span> (ast) execute_ast(ast);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (input_buf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;sh: syntax error in command string\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Shell exits after -c</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!command_string_from_arg) &#123; <span class="comment">// only parse options if not already in -c mode</span></span><br><span class="line">        ARGBEGIN &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: interactive = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: echocmds = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: usage();</span><br><span class="line">        &#125; ARGEND</span><br><span class="line">        arg_idx_after_opts = ARGC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arg_idx_after_opts; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> *arg = argv[i];</span><br><span class="line">        <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (arg[<span class="number">1</span>] == <span class="string">&#x27;c&#x27;</span> || arg[<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span> || arg[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span>)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (arg[<span class="number">1</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; i + <span class="number">1</span> &lt; argc) i++; <span class="comment">// skip command string for -c</span></span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *eq_ptr = <span class="built_in">strchr</span>(arg, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eq_ptr &amp;&amp; (eq_ptr != arg) &amp;&amp; <span class="built_in">strchr</span>(arg, <span class="string">&#x27;/&#x27;</span>) == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strlen</span>(arg) &gt; <span class="number">2</span>) &#123; <span class="comment">// Heuristic for env var</span></span><br><span class="line">            <span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            <span class="type">char</span> value_buf[MAX_VAR_VALUE_LEN + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> is_ro_flag = arg[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// First char is &#x27;0&#x27; or &#x27;1&#x27; for readonly</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *name_start = arg + <span class="number">1</span>; <span class="comment">// Name starts after the flag</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> name_len = eq_ptr - name_start;</span><br><span class="line">            <span class="keyword">if</span> (name_len &gt; <span class="number">0</span> &amp;&amp; name_len &lt;= MAX_VAR_NAME_LEN) &#123;</span><br><span class="line">                mystrncpy(name, name_start, name_len);</span><br><span class="line">                name[name_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (mystrlen(eq_ptr + <span class="number">1</span>) &lt;= MAX_VAR_VALUE_LEN) &#123;</span><br><span class="line">                    mystrcpy(value_buf, eq_ptr + <span class="number">1</span>);</span><br><span class="line">                    set_variable(name, value_buf, <span class="number">1</span>, is_ro_flag, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">/* value too long, skip */</span> &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">/* name too long or empty, skip */</span> &#125;</span><br><span class="line">            arg_idx_after_opts = i + <span class="number">1</span>; <span class="comment">// Update index of potential script file</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is now considered the script file if present</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; arg_idx_after_opts &amp;&amp; !command_string_from_arg) &#123; <span class="comment">// Script file if not -c mode</span></span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r_open = open(argv[arg_idx_after_opts], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (r_open &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;open %s: %d&quot;</span>, argv[arg_idx_after_opts], r_open);</span><br><span class="line">        <span class="keyword">if</span> (r_open != <span class="number">0</span>) &#123; dup(r_open, <span class="number">0</span>); close(r_open); &#125;</span><br><span class="line">        interactive = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;::                                                         ::\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;::                 MOS Shell (Command Control)             ::\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;::                                                         ::\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    load_history();</span><br><span class="line">    <span class="type">int</span> first_prompt_cycle = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        reset_allocators();</span><br><span class="line">        <span class="built_in">memset</span>(input_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(input_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first_prompt_cycle) <span class="built_in">printf</span>(<span class="string">&quot;\n$ &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123;</span><br><span class="line">            current_typed_line[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readline(input_buf, <span class="keyword">sizeof</span> input_buf, interactive);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input_buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">                first_prompt_cycle = <span class="number">0</span>; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        first_prompt_cycle = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (echocmds) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;+ %s\n&quot;</span>, input_buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* temp_scan = input_buf;</span><br><span class="line">        <span class="keyword">while</span> (*temp_scan &amp;&amp; <span class="built_in">strchr</span>(WHITESPACE, *temp_scan)) temp_scan++;</span><br><span class="line">        <span class="keyword">if</span> (*temp_scan == <span class="string">&#x27;#&#x27;</span> || *temp_scan == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            first_prompt_cycle = <span class="number">0</span>; <span class="comment">// Comment or empty line, next prompt doesn&#x27;t need extra \n</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	    add_to_history(input_buf);</span><br><span class="line">        save_history();</span><br><span class="line">        tokenizer_init(input_buf);</span><br><span class="line">        ASTNode *ast = parse_line();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ast) &#123;</span><br><span class="line">            execute_ast(ast);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(input_buf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; input_buf[<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (current_token.type != TOKEN_EOF &amp;&amp; current_token.type != TOKEN_EOL &amp;&amp; current_token.type != TOKEN_ERROR &amp;&amp; current_token.type != <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: syntax error near token &#x27;%s&#x27;\n&quot;</span>, current_token.value);</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_token.type == TOKEN_ERROR &amp;&amp; current_token.value[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: tokenizer error near &#x27;%s&#x27;\n&quot;</span>, current_token.value);</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_token.type != TOKEN_EOF &amp;&amp; current_token.type != TOKEN_EOL)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: syntax error\n&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrncpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">	<span class="type">char</span>* start = dest;</span><br><span class="line">	<span class="keyword">while</span> (count &amp;&amp; (*dest++ = *src++)) &#123;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count) &#123;</span><br><span class="line">		<span class="keyword">while</span> (--count) &#123;</span><br><span class="line">			*dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; (<span class="type">size_t</span>)n &amp;&amp; s1[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; s2[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>)s1[i] - (<span class="type">unsigned</span> <span class="type">char</span>)s2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; (<span class="type">size_t</span>)n) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>)s1[i] - (<span class="type">unsigned</span> <span class="type">char</span>)s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; (*str1 == *str2)) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)str1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* ptr = dest;</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="string">&#x27;\0&#x27;</span>) ptr++;</span><br><span class="line">    <span class="keyword">while</span> ((*ptr++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[length] != <span class="string">&#x27;\0&#x27;</span>) length++;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_shell_vars</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">        shell_vars[i].is_set = <span class="number">0</span>;</span><br><span class="line">        shell_vars[i].name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        shell_vars[i].value[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        shell_vars[i].is_exported = <span class="number">0</span>;</span><br><span class="line">        shell_vars[i].is_readonly = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num_set_vars = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShellVar* <span class="title function_">find_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!name) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shell_vars[i].is_set &amp;&amp; mystrcmp(shell_vars[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;shell_vars[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShellVar* <span class="title function_">find_free_slot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shell_vars[i].is_set) <span class="keyword">return</span> &amp;shell_vars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> export_flag, <span class="type">int</span> readonly_flag, <span class="type">int</span> update_flags_if_exists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mystrlen(name) &gt; MAX_VAR_NAME_LEN) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; mystrlen(value) &gt; MAX_VAR_VALUE_LEN) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ShellVar *var = find_variable(name);</span><br><span class="line">    <span class="keyword">if</span> (var) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var-&gt;is_readonly) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        mystrcpy(var-&gt;value, value ? value : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (update_flags_if_exists) &#123;</span><br><span class="line">            var-&gt;is_exported = export_flag;</span><br><span class="line">            <span class="keyword">if</span> (readonly_flag) var-&gt;is_readonly = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        var = find_free_slot();</span><br><span class="line">        <span class="keyword">if</span> (!var) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        mystrcpy(var-&gt;name, name);</span><br><span class="line">        mystrcpy(var-&gt;value, value ? value : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        var-&gt;is_exported = export_flag;</span><br><span class="line">        var-&gt;is_readonly = readonly_flag;</span><br><span class="line">        var-&gt;is_set = <span class="number">1</span>;</span><br><span class="line">        num_set_vars++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unset_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    ShellVar *var = find_variable(name);</span><br><span class="line">    <span class="keyword">if</span> (!var) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (var-&gt;is_readonly) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    var-&gt;is_set = <span class="number">0</span>;</span><br><span class="line">    var-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    num_set_vars--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_all_variables</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shell_vars[i].is_set) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%s%s=%s\n&quot;</span>,</span><br><span class="line">                   shell_vars[i].is_exported ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   shell_vars[i].is_readonly ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   shell_vars[i].name,</span><br><span class="line">                   shell_vars[i].value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_variable_value</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    ShellVar *var = find_variable(name);</span><br><span class="line">    <span class="keyword">if</span> (var &amp;&amp; var-&gt;is_set) <span class="keyword">return</span> var-&gt;value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">mystrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == c) <span class="keyword">return</span> (<span class="type">char</span> *)str;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">return</span> (<span class="type">char</span> *)str;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymemmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *d = (<span class="type">unsigned</span> <span class="type">char</span> *)dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)src;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) d[i] = s[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) d[i - <span class="number">1</span>] = s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个架构流程大致可以分为：<strong>输入读入(readline)，生成AST树(parse_line)，执行AST树(execute_ast)，执行内部指令(execute_inner_command)&#x2F;外部指令(spawn)。</strong></p>
<p>首先是输入读入，调用readline函数来完成从标准输入中读入，readline函数如下（实现了快捷键）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n, <span class="type">int</span> interactive)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int current_len; </span><br><span class="line">    u_int cursor_pos;  </span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    u_int onscreen_cmd_len = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">        mystrcpy(buf, current_typed_line); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">        <span class="keyword">if</span> (history_count &gt; <span class="number">0</span> &amp;&amp; history_current_nav_offset &lt;= history_count) &#123; </span><br><span class="line">             mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    current_len = mystrlen(buf);</span><br><span class="line">    cursor_pos = current_len; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive &amp;&amp; current_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r$ &quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; current_len; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">        onscreen_cmd_len = current_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = read(<span class="number">0</span>, &amp;c, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (interactive &amp;&amp; current_len == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buf[current_len] = <span class="number">0</span>; <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> requires_full_reprint = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0x1b</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123;</span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0x1b</span>) &#123; </span><br><span class="line">            <span class="type">char</span> seq[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;seq[<span class="number">0</span>], <span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (seq[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;seq[<span class="number">1</span>], <span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (history_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">                            mystrcpy(current_typed_line, buf); </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset &lt; history_count) &#123;</span><br><span class="line">                            history_current_nav_offset++;</span><br><span class="line">                            <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">                            mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">                            current_len = mystrlen(buf);</span><br><span class="line">                            cursor_pos = current_len;</span><br><span class="line">                            requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (history_current_nav_offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        history_current_nav_offset--;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">                            mystrcpy(buf, current_typed_line);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">                            mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        current_len = mystrlen(buf);</span><br><span class="line">                        cursor_pos = current_len;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        cursor_pos--;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;C&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                        cursor_pos++;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\b&#x27;</span> || c == <span class="number">0x7f</span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mymemmove(&amp;buf[cursor_pos - <span class="number">1</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                cursor_pos--;</span><br><span class="line">                current_len--;</span><br><span class="line">                requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x01</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (cursor_pos != <span class="number">0</span>) &#123; cursor_pos = <span class="number">0</span>; requires_full_reprint = <span class="number">1</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x05</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (cursor_pos != current_len) &#123; cursor_pos = current_len; requires_full_reprint = <span class="number">1</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x0B</span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                buf[cursor_pos] = <span class="string">&#x27;\0&#x27;</span>; current_len = cursor_pos; requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x15</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mymemmove(&amp;buf[<span class="number">0</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                current_len -= cursor_pos; cursor_pos = <span class="number">0</span>; requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x17</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                u_int original_cursor_pos = cursor_pos;</span><br><span class="line">                u_int end_of_deletion_span = cursor_pos;</span><br><span class="line">                <span class="keyword">while</span> (cursor_pos &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot; \t&quot;</span>, buf[cursor_pos - <span class="number">1</span>])) cursor_pos--;</span><br><span class="line">                u_int start_of_word_to_delete = cursor_pos;</span><br><span class="line">                <span class="keyword">while</span> (start_of_word_to_delete &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">strchr</span>(<span class="string">&quot; \t&quot;</span>, buf[start_of_word_to_delete - <span class="number">1</span>])) &#123;</span><br><span class="line">                    start_of_word_to_delete--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (start_of_word_to_delete &lt; end_of_deletion_span) &#123;</span><br><span class="line">                    mymemmove(&amp;buf[start_of_word_to_delete], &amp;buf[end_of_deletion_span], current_len - end_of_deletion_span + <span class="number">1</span>);</span><br><span class="line">                    current_len -= (end_of_deletion_span - start_of_word_to_delete);</span><br><span class="line">                    cursor_pos = start_of_word_to_delete;</span><br><span class="line">                    requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor_pos = original_cursor_pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span> || c == <span class="string">&#x27;\n&#x27;</span>) &#123; </span><br><span class="line">            buf[current_len] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interactive) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="number">0x20</span> &amp;&amp; c &lt; <span class="number">0x7f</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_len &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                    mymemmove(&amp;buf[cursor_pos + <span class="number">1</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buf[cursor_pos] = c;</span><br><span class="line">                current_len++;</span><br><span class="line">                cursor_pos++;</span><br><span class="line">                requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requires_full_reprint &amp;&amp; interactive) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; current_len; ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current_len &lt; onscreen_cmd_len) &#123;</span><br><span class="line">                <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; (onscreen_cmd_len - current_len); ++i) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u_int effective_displayed_cmd_len = (current_len &gt; onscreen_cmd_len) ? current_len : onscreen_cmd_len;</span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; (effective_displayed_cmd_len - cursor_pos); ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            onscreen_cmd_len = current_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是解析输入。首先需要明确AST语法树的结构和节点内容：</p>
<p>整体的思路是递归下降，先定义出最小的Token单元，然后用get_new_raw_token来获取下一个Token，最后根据当前的token来构建不同的ASTNode节点。</p>
<p>枚举类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> <span class="title">ASTNode</span>;</span></span><br><span class="line"><span class="comment">// --- AST Node Types Enum ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NODE_ILLEGAL = <span class="number">0</span>,</span><br><span class="line">    NODE_COMMAND,</span><br><span class="line">    NODE_PIPELINE,</span><br><span class="line">    NODE_LIST_SEMI,  <span class="comment">// For &#x27;;&#x27;</span></span><br><span class="line">    NODE_AND,        <span class="comment">// For &#x27;&amp;&amp;&#x27;</span></span><br><span class="line">    NODE_OR,         <span class="comment">// For &#x27;||&#x27;</span></span><br><span class="line">&#125; ASTNodeType;</span><br><span class="line"><span class="comment">// --- Token Types Enum (based on EBNF) ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TOKEN_ERROR = <span class="number">0</span>,   <span class="comment">// Error or uninitialized</span></span><br><span class="line">    TOKEN_EOF = <span class="number">1</span>,     <span class="comment">// End of input (actual end)</span></span><br><span class="line">    TOKEN_EOL = <span class="number">2</span>,     <span class="comment">// End of line (newline or effective end via &#x27;#&#x27;)</span></span><br><span class="line">    TOKEN_WORD,        <span class="comment">// Command, argument, filename</span></span><br><span class="line">    TOKEN_PIPE,        <span class="comment">// |</span></span><br><span class="line">    TOKEN_SEMI,        <span class="comment">// ;</span></span><br><span class="line">    TOKEN_AND,         <span class="comment">// &amp;&amp;</span></span><br><span class="line">    TOKEN_OR,          <span class="comment">// ||</span></span><br><span class="line">    TOKEN_REDIR_IN,    <span class="comment">// &lt;</span></span><br><span class="line">    TOKEN_REDIR_OUT,   <span class="comment">// &gt;</span></span><br><span class="line">    TOKEN_REDIR_APP,   <span class="comment">// &gt;&gt;</span></span><br><span class="line">&#125; TokenType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    REDIR_TYPE_IN,   <span class="comment">// &lt;</span></span><br><span class="line">    REDIR_TYPE_OUT,  <span class="comment">// &gt;</span></span><br><span class="line">    REDIR_TYPE_APP,  <span class="comment">// &gt;&gt;</span></span><br><span class="line">&#125; RedirType;</span><br></pre></td></tr></table></figure>

<p>包含了ASTNodeType，用来标记ASTNode的节点类型。TokenType，用来标记每个token的类型。</p>
<p>之后是ASTNode和Token结构定义。<br><strong>Token</strong>包含一个TokenType，用来标志Token的类型，以及一个value。如果TokenType是TOKEN_WORD，那么这个字符串会被存到value中。<br><strong>ASTNode</strong>包含一个ASTNodeType，用来标志这个ASTNode节点的类型，以及data。data分为两种，如果是command类型，则data是CMDNodeData；如果是；&amp;&amp; || |，那么data是BinaryOpNodeData。<br><strong>CMDNodeData</strong>包括argv，用来涵盖一个指令的几个由空白字符分割的片段，argv[0]是指令的名字，后面是指令参数。argc是有效argv的数目，RedirNode是指令中包含的重定向指针。<br><strong>BinaryOpNodeData</strong>类似于二叉树，由左右节点组成，类型都是ASTNode。<br><strong>RedirNode</strong>包含重定向的类型RedirType，用来区分 &lt; &gt; &gt;&gt;，同时还有重定向操作的文件名filename，同时还有指向下一个RedirNode的指针，用来链式存储连续重定向。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- Token Structure ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TokenType type;</span><br><span class="line">    <span class="type">char</span> value[MAX_TOKEN_LEN]; <span class="comment">// String value of the token</span></span><br><span class="line">&#125; Token;</span><br><span class="line"><span class="comment">// --- Redirection Structure ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RedirNode</span> &#123;</span></span><br><span class="line">    RedirType type;</span><br><span class="line">    <span class="type">char</span> *filename;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RedirNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RedirNode;</span><br><span class="line"><span class="comment">// --- AST Node Structures ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *argv[MAX_CMD_ARGS];</span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    RedirNode *redirects; <span class="comment">// Linked list of redirections</span></span><br><span class="line">&#125; CMDNodeData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ASTNode *left;</span><br><span class="line">    ASTNode *right;</span><br><span class="line">&#125; BinaryOpNodeData; <span class="comment">// For Pipeline, List, And, Or</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> &#123;</span></span><br><span class="line">    ASTNodeType type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        CMDNodeData command;</span><br><span class="line">        BinaryOpNodeData binary_op;</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析层级如下：<br>parse_line &#x3D; parse_list<br>parse_list &#x3D; parse_and_or ( ; parse_and_or)<br>parse_and_or &#x3D; parse_pipeline ( &amp;&amp;&#x2F;| | parse_pipeline)<br>parse_pipeline &#x3D; parse_command ( | parse_command)<br>parse_command &#x3D; command (redirect command)</p>
<p>具体函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">ASTNode *<span class="title function_">parse_line</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parse_list();</span><br><span class="line">&#125;</span><br><span class="line">ASTNode *<span class="title function_">parse_list</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_and_or();</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_SEMI || current_token.type == TOKEN_AMP) &#123;</span><br><span class="line">        TokenType op_type = current_token.type;</span><br><span class="line">        consume_token();</span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) &#123; </span><br><span class="line">            ASTNode *new_list_node = alloc_ast_node(op_type == TOKEN_SEMI ? NODE_LIST_SEMI : NODE_LIST_AMP);</span><br><span class="line">            new_list_node-&gt;data.binary_op.left = node;</span><br><span class="line">            new_list_node-&gt;data.binary_op.right = <span class="literal">NULL</span>;</span><br><span class="line">            node = new_list_node;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *right_node = parse_and_or();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error after &#x27;%s&#x27;\n&quot;</span>, op_type == TOKEN_SEMI ? <span class="string">&quot;;&quot;</span> : <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_list_node = alloc_ast_node(op_type == TOKEN_SEMI ? NODE_LIST_SEMI : NODE_LIST_AMP);</span><br><span class="line">        new_list_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_list_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_list_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">ASTNode *<span class="title function_">parse_and_or</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_pipeline();</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_AND || current_token.type == TOKEN_OR) &#123;</span><br><span class="line">        TokenType op_type = current_token.type;</span><br><span class="line">        consume_token();</span><br><span class="line">        ASTNode *right_node = parse_pipeline();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error: &#x27;%s&#x27; not followed by pipeline\n&quot;</span>, op_type == TOKEN_AND ? <span class="string">&quot;&amp;&amp;&quot;</span> : <span class="string">&quot;||&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_op_node = alloc_ast_node(op_type == TOKEN_AND ? NODE_AND : NODE_OR);</span><br><span class="line">        new_op_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_op_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_op_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">ASTNode *<span class="title function_">parse_pipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_command();</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_PIPE) &#123;</span><br><span class="line">        consume_token();</span><br><span class="line">        ASTNode *right_node = parse_command();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error: &#x27;|&#x27; not followed by command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_pipe_node = alloc_ast_node(NODE_PIPELINE);</span><br><span class="line">        new_pipe_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_pipe_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_pipe_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">ASTNode *<span class="title function_">parse_command</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type != TOKEN_WORD &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_IN &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_OUT &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_APP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    ASTNode *cmd_node_ast = alloc_ast_node(NODE_COMMAND);</span><br><span class="line">    CMDNodeData *cmd_data = &amp;cmd_node_ast-&gt;data.command;</span><br><span class="line">    RedirNode **next_redir_ptr = &amp;cmd_data-&gt;redirects;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> parent_shell_is_interactive = iscons(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// Changed to infinite loop, break out explicitly</span></span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_WORD) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cmd_data-&gt;argc &lt; MAX_CMD_ARGS - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> *arg_after_var_expansion = expand_string_variables(current_token.value);</span><br><span class="line">                <span class="type">char</span> *final_arg_for_argv = arg_after_var_expansion; <span class="comment">// Start with variable-expanded arg</span></span><br><span class="line">                <span class="type">char</span> rebuilt_arg_buffer[MAX_EXPANDED_STR_LEN * <span class="number">2</span>]; <span class="comment">// Temporary buffer for rebuilding arg</span></span><br><span class="line">                rebuilt_arg_buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="type">char</span> *current_rebuilt_ptr = rebuilt_arg_buffer;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *scan_ptr = arg_after_var_expansion;</span><br><span class="line">		<span class="comment">//printf(&quot;command word: %s\n&quot;, scan_ptr);</span></span><br><span class="line">                <span class="keyword">while</span> (*scan_ptr) &#123;</span><br><span class="line">                    <span class="type">char</span> *backtick_start = <span class="built_in">strchr</span>(scan_ptr, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (backtick_start) &#123;</span><br><span class="line">                        <span class="type">char</span> *backtick_end = <span class="built_in">strchr</span>(backtick_start + <span class="number">1</span>, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (backtick_end) &#123;</span><br><span class="line">                            <span class="comment">// Copy part before the first backtick</span></span><br><span class="line">                            <span class="keyword">if</span> (backtick_start &gt; scan_ptr) &#123;</span><br><span class="line">                                mystrncpy(current_rebuilt_ptr, scan_ptr, backtick_start - scan_ptr);</span><br><span class="line">                                current_rebuilt_ptr += (backtick_start - scan_ptr);</span><br><span class="line">				<span class="comment">//printf(&quot;rebuilt: %s\n&quot;, current_rebuilt_ptr);</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Extract command for substitution</span></span><br><span class="line">                            <span class="type">char</span> cmd_to_subst[MAX_INPUT_BUF];</span><br><span class="line">                            <span class="type">int</span> cmd_len = backtick_end - (backtick_start + <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span> (cmd_len &gt;= MAX_INPUT_BUF) cmd_len = MAX_INPUT_BUF <span class="number">-1</span>; <span class="comment">// Truncate if too long</span></span><br><span class="line">                            mystrncpy(cmd_to_subst, backtick_start + <span class="number">1</span>, cmd_len);</span><br><span class="line">                            cmd_to_subst[cmd_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			    <span class="comment">//printf(&quot;cmd_to_subst: %s\n&quot;, cmd_to_subst);</span></span><br><span class="line">                            <span class="comment">// Execute substitution</span></span><br><span class="line">                            <span class="type">char</span> *subst_output = execute_command_substitution(cmd_to_subst, parent_shell_is_interactive);</span><br><span class="line">                            <span class="keyword">if</span> (subst_output) &#123; <span class="comment">// subst_output is already processed (newlines stripped/replaced)</span></span><br><span class="line">                                mystrcat(current_rebuilt_ptr, subst_output); <span class="comment">// Append result</span></span><br><span class="line">                                current_rebuilt_ptr += mystrlen(subst_output);</span><br><span class="line">                            &#125;</span><br><span class="line">                            scan_ptr = backtick_end + <span class="number">1</span>; <span class="comment">// Continue scanning after the closing backtick</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Unmatched opening backtick, treat literally</span></span><br><span class="line">                            mystrcat(current_rebuilt_ptr, scan_ptr);</span><br><span class="line">                            current_rebuilt_ptr += mystrlen(scan_ptr);</span><br><span class="line">                            scan_ptr += mystrlen(scan_ptr); <span class="comment">// Go to end</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// No more backticks in the remainder of the string</span></span><br><span class="line">                        mystrcat(current_rebuilt_ptr, scan_ptr);</span><br><span class="line">                        current_rebuilt_ptr += mystrlen(scan_ptr);</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// Done with this argument string</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                *current_rebuilt_ptr = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// Null terminate the rebuilt argument</span></span><br><span class="line">                <span class="keyword">if</span> (rebuilt_arg_buffer[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span> || arg_after_var_expansion[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123; <span class="comment">// If something was rebuilt or original was empty</span></span><br><span class="line">                    final_arg_for_argv = user_strdup(rebuilt_arg_buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// No substitutions, or only var expansion happened</span></span><br><span class="line">                    final_arg_for_argv = user_strdup(arg_after_var_expansion); <span class="comment">// strdup the var-expanded one</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// --- End Command Substitution Pass ---</span></span><br><span class="line">                cmd_data-&gt;argv[cmd_data-&gt;argc++] = final_arg_for_argv;</span><br><span class="line">		<span class="comment">//printf(&quot;final_arg_for_argv: %s\n&quot;, final_arg_for_argv);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ... too many args ... */</span> <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">            consume_token();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_token.type == TOKEN_REDIR_IN ||</span><br><span class="line">                   current_token.type == TOKEN_REDIR_OUT ||</span><br><span class="line">                   current_token.type == TOKEN_REDIR_APP) &#123;</span><br><span class="line">            TokenType redir_op_type = current_token.type;</span><br><span class="line">            consume_token(); </span><br><span class="line">            <span class="keyword">if</span> (current_token.type != TOKEN_WORD) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;Syntax error: Redirection operator not followed by filename\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            RedirNode *redir_node = alloc_redir_node();</span><br><span class="line">            <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_IN) redir_node-&gt;type = REDIR_TYPE_IN;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_OUT) redir_node-&gt;type = REDIR_TYPE_OUT;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_APP) redir_node-&gt;type = REDIR_TYPE_APP;</span><br><span class="line">	     <span class="comment">// Expand variables in the filename</span></span><br><span class="line">            <span class="type">char</span> *expanded_filename = expand_string_variables(current_token.value);</span><br><span class="line">            redir_node-&gt;filename = expanded_filename; <span class="comment">// user_strdup is now done by expand_string_variables</span></span><br><span class="line">            consume_token();</span><br><span class="line">            *next_redir_ptr = redir_node;</span><br><span class="line">            next_redir_ptr = &amp;redir_node-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Not a word or redirection, end of simple command</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cmd_data-&gt;argv[cmd_data-&gt;argc] = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">if</span> (cmd_data-&gt;argc == <span class="number">0</span> &amp;&amp; cmd_data-&gt;redirects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cmd_node_ast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解析完AST语法树后，会返回语法树的根节点 ASTNode * node。</p>
<p>之后就进入执行语法树的过程了。执行语法树的过程主要是根据当前ASTNode的类型来进行不同的操作。</p>
<p>如果当前是NODE_COMMAND，则利用当前节点包含的command来运行指令。运行的过程为，先判断该指令是否是内部指令，如果是的话直接调用函数运行，否则用spawn创建子进程运行。</p>
<p>如果当前是NODE_PIPELINE，则先创建管道，之后新开两个子进程，分别运行管道左右两边的命令。运行左边的命令时，将标准输出与管道的写端共享页面，即往标准输出的写入被视为写入管道；运行右边的命令时，将标准输入与管道的读端共享页面，即从标准输入的读取被视为读取管道。这样执行右边命令的进程在读取时，读取到的就是执行左边命令的进程的输出，也就是完成管道的作用。</p>
<p>如果是NODE_AND或者NODE_OR，则先递归运行左边的命令，之后根据管道来传输运行返回值，再根据条件运行的条件判断来确定是否运行右边的指令。</p>
<p>如果是NODE_LIST_SEMI，则是多条指令在同一行运行的情况。只需要按顺序依次从左到右运行指令即可。</p>
<p>总体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">execute_ast</span><span class="params">(ASTNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> child_pid;</span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">switch</span> (node-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> NODE_COMMAND: &#123;</span><br><span class="line">            CMDNodeData *cmd = &amp;node-&gt;data.command;</span><br><span class="line">            <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">0</span> &amp;&amp; cmd-&gt;redirects == <span class="literal">NULL</span>) &#123; <span class="comment">// Should be caught by parser</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">0</span>) &#123; </span><br><span class="line">                debugf(<span class="string">&quot;sh: missing command for redirection\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	    <span class="keyword">if</span> (is_inner_cmd(cmd)) &#123;</span><br><span class="line">	    	execute_inner_cmd(cmd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//printf(&quot;%s is outer command\n&quot;, cmd-&gt;argv[0]);</span></span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;execute_ast: fork for command failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123; <span class="comment">// Child process</span></span><br><span class="line">                RedirNode *redir = cmd-&gt;redirects;</span><br><span class="line">                <span class="keyword">while</span> (redir) &#123;</span><br><span class="line">                    <span class="type">int</span> open_flags = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> target_fd_std = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_IN) &#123;</span><br><span class="line">                        open_flags = O_RDONLY;</span><br><span class="line">                        target_fd_std = <span class="number">0</span>; </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_OUT) &#123;</span><br><span class="line">                        open_flags = O_WRONLY | O_CREAT | O_TRUNC;</span><br><span class="line">                        target_fd_std = <span class="number">1</span>; </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_APP) &#123;</span><br><span class="line">                        open_flags = O_WRONLY | O_CREAT | O_APPEND; </span><br><span class="line">                        target_fd_std = <span class="number">1</span>; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> opened_fd = open(redir-&gt;filename, open_flags);</span><br><span class="line">                    <span class="keyword">if</span> (opened_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;sh: cannot open %s\n&quot;</span>, redir-&gt;filename); <span class="comment">// Use printf for user messages</span></span><br><span class="line">                        <span class="built_in">exit</span>(); </span><br><span class="line">                    &#125;</span><br><span class="line">                    dup(opened_fd, target_fd_std);</span><br><span class="line">                    close(opened_fd);</span><br><span class="line">                    redir = redir-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">		<span class="type">int</span> spawn_ret;</span><br><span class="line">		<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;sh.b&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">		    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;sh&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">		    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;/sh.b&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">		    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;/sh&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> *spawn_argv[MAX_CMD_ARGS + MAX_SHELL_VARS + <span class="number">1</span>]; <span class="comment">// Max possible size</span></span><br><span class="line">            <span class="type">int</span> spawn_argc = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 1. Copy command and its arguments</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cmd-&gt;argc; ++i) &#123;</span><br><span class="line">                spawn_argv[spawn_argc++] = cmd-&gt;argv[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. Append exported environment variables</span></span><br><span class="line">            <span class="type">char</span> env_str_pool[MAX_SHELL_VARS][MAX_VAR_NAME_LEN + MAX_VAR_VALUE_LEN + <span class="number">2</span>]; <span class="comment">// Pool for &quot;NAME=VALUE&quot; strings</span></span><br><span class="line">            <span class="type">int</span> env_str_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shell_vars[i].is_set &amp;&amp; shell_vars[i].is_exported) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (spawn_argc &lt; (MAX_CMD_ARGS + MAX_SHELL_VARS) &amp;&amp; env_str_idx &lt; MAX_SHELL_VARS) &#123;</span><br><span class="line">                        <span class="type">char</span> *current_env_str = env_str_pool[env_str_idx++];</span><br><span class="line">			<span class="keyword">if</span> (shell_vars[i].is_readonly) &#123;mystrcat(current_env_str, <span class="string">&quot;1&quot;</span>);	&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;mystrcat(current_env_str, <span class="string">&quot;0&quot;</span>);&#125;</span><br><span class="line">			mystrcat(current_env_str, shell_vars[i].name);</span><br><span class="line">			mystrcat(current_env_str, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">			mystrcat(current_env_str, shell_vars[i].value);</span><br><span class="line">                        spawn_argv[spawn_argc++] = current_env_str;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* too many args or env vars, handle error */</span> <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            spawn_argv[spawn_argc] = <span class="literal">NULL</span>; <span class="comment">// Null-terminate argv for spawn</span></span><br><span class="line">			<span class="comment">//printf(&quot;create a child shell\n&quot;);</span></span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spawn_argc; i++) &#123;</span><br><span class="line">				<span class="comment">//printf(&quot;%s\n&quot;, spawn_argv[i]);</span></span><br><span class="line">			&#125;</span><br><span class="line">			spawn_ret = spawn(cmd-&gt;argv[<span class="number">0</span>], spawn_argv);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="type">char</span> **argv2 = (<span class="type">char</span> **)cmd-&gt;argv;</span><br><span class="line">			<span class="keyword">while</span>(argv2[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>,argv2[i++]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">               		spawn_ret = spawn(cmd-&gt;argv[<span class="number">0</span>], (<span class="type">char</span> **)cmd-&gt;argv); </span><br><span class="line">		&#125;</span><br><span class="line">                <span class="keyword">if</span> (spawn_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Error message printed by spawn or child itself if command not found by spawn</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: failed to spawn &#x27;%s&#x27; (err %d)\n&quot;</span>, cmd-&gt;argv[<span class="number">0</span>], spawn_ret);</span><br><span class="line">                &#125;</span><br><span class="line">		wait(spawn_ret);</span><br><span class="line">                <span class="built_in">exit</span>(); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Parent process</span></span><br><span class="line">                wait(child_pid); </span><br><span class="line">                <span class="comment">// After child exits, its stdout should have been flushed by its own exit sequence</span></span><br><span class="line">                <span class="comment">// or by kernel if it&#x27;s a direct syscall write.</span></span><br><span class="line">                <span class="comment">// No explicit fflush needed here for child&#x27;s output by parent.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NODE_PIPELINE: &#123;</span><br><span class="line">            <span class="keyword">if</span> (pipe(pipe_fds) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;pipe creation failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> pid1 = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid1 &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for pipe left failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pid1 == <span class="number">0</span>) &#123; </span><br><span class="line">                close(pipe_fds[<span class="number">0</span>]); </span><br><span class="line">                dup(pipe_fds[<span class="number">1</span>], <span class="number">1</span>);  </span><br><span class="line">                close(pipe_fds[<span class="number">1</span>]); </span><br><span class="line">                execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">                <span class="built_in">exit</span>(); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> pid2 = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 user_panic(<span class="string">&quot;fork for pipe right failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pid2 == <span class="number">0</span>) &#123;</span><br><span class="line">                close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">                dup(pipe_fds[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">                close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">                <span class="built_in">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">            close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">            wait(pid1);</span><br><span class="line">            wait(pid2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NODE_LIST_SEMI:</span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) &#123; </span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> NODE_LIST_AMP: </span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for &amp; failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">                <span class="built_in">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) &#123; </span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_AND: </span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Proper exit status handling needed</span></span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">            <span class="comment">// For now, simplified: always execute right if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right &amp;&amp; mystrcmp(node-&gt;data.binary_op.left-&gt;data.command.argv[<span class="number">0</span>], <span class="string">&quot;/mkdir&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                 execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_OR: </span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Proper exit status handling needed</span></span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">            <span class="comment">// For now, simplified: always execute right if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right  &amp;&amp; mystrcmp(node-&gt;data.binary_op.left-&gt;data.command.argv[<span class="number">0</span>], <span class="string">&quot;/mkdir&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            user_panic(<span class="string">&quot;Unknown AST node type: %d&quot;</span>, node-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，我重构的AST语法树结构就基本完成了，下面开始新增指令运行。</p>
<h3 id="不带-b-后缀指令"><a href="#不带-b-后缀指令" class="headerlink" title="不带 .b 后缀指令"></a>不带 <code>.b</code> 后缀指令</h3><p>你需要实现不带 <code>.b</code> 后缀的指令，但仍需兼容带有 <code>.b</code> 后缀的指令，如 <code>ls</code> 与 <code>ls.b</code> 都应能够正确列出当前目录下的文件。<br>只需要在第一次打开文件失败后手动在prog后面添加 .b 字符再次尝试打开即可。</p>
<p><img src="/pictures/image-6.png" alt="alt text"><br><img src="/pictures/image-7.png" alt="alt text"></p>
<h3 id="实现注释功能"><a href="#实现注释功能" class="headerlink" title="实现注释功能"></a>实现注释功能</h3><p>你需要使用 <code>#</code> 实现注释功能，例如 <code>ls | cat # this is a comment meow</code>，<code>ls | cat</code> 会被正确执行，而后面的注释则会被抛弃<br>当解析输出读取到#时，会之间移动到输入的末尾，期间的内容不会被解析</p>
<p><img src="/pictures/image-8.png" alt="alt text"></p>
<h3 id="支持相对路径"><a href="#支持相对路径" class="headerlink" title="支持相对路径"></a>支持相对路径</h3><p>MOS 中现有的文件系统操作并不支持相对路径，对于一切路径都从根目录开始查找，因此在 shell 命令中也需要用绝对路径指代文件，这为命令的描述带来了不便。你需要为每个进程维护<strong>工作目录</strong>这一状态，实现相关内建指令，并为其他与路径相关的指令提供路径支持。</p>
<p>首先，为了让进程维护自己的工作路径，需要在进程控制块中加入工作路径这一成员。</p>
<p><img src="/pictures/image-9.png" alt="alt text"></p>
<p>然后在创建进程的时候，默认将进程的cwd初始化为根目录。也就是当shell被创建的时候所在的默认目录。要时刻保证进程的工作路径与实际所在路径一致。</p>
<p><img src="/pictures/image-10.png" alt="alt text"></p>
<p>之后在进行sys_exofork系统调用的时候，将新申请的进程的cwd赋值为父进程的cwd。这样做是因为，子进程是父进程创建出来的，因此子进程所在的工作路径应该与父进程保持一致，这样执行外部指令时，采用相对地址才能保持一致。</p>
<p><img src="/pictures/image-11.png" alt="alt text"></p>
<p>然后编写两个系统调用：sys_get_cwd, sys_set_cwd，分别用来获得和更新当前进程的cwd。<br>之后由于cd、pwd是内部指令，因此其应当由shell进程执行，具体过程为在shell进程中编写函数，执行cd和pwd的相关行为。</p>
<p>先判断当前指令是否是cd或者pwd，如果是的话，进入内部命令执行函数。如果当前指令是pwd，则直接输出当前工作路径即可。如果是cd，那么如果按照题目要求实现。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">execute_inner_cmd</span><span class="params">(CMDNodeData *cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;pwd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pwd: expected 0 arguments; got %d\n&quot;</span>, cmd-&gt;argc - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			syscall_get_cwd(buf);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">char</span> finalpath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span> (cmd-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">			mystrcpy(finalpath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">char</span> cwd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			syscall_get_cwd(cwd);</span><br><span class="line">			<span class="type">int</span> r;</span><br><span class="line">			<span class="keyword">if</span> ((r = get_final_path(cwd, cmd-&gt;argv[<span class="number">1</span>], finalpath)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//printf(&quot;absolute path: %s\n&quot;, finalpath);</span></span><br><span class="line">				syscall_set_cwd(finalpath);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: The directory &#x27;%s&#x27; does not exist\n&quot;</span>, cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: &#x27;%s&#x27; is not a directory\n&quot;</span>, cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cwd or relcwd does not exists\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-2</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;path is too long\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-3</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;fail to normalize path\n&quot;</span>);</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Too many args for cd command\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;declare&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> export_f = <span class="number">0</span>;</span><br><span class="line">       		<span class="type">int</span> readonly_f = <span class="number">0</span>;</span><br><span class="line">        	<span class="type">int</span> arg_idx = <span class="number">1</span>;</span><br><span class="line">        	<span class="type">char</span> *name_val_pair = <span class="literal">NULL</span>;</span><br><span class="line">        	<span class="comment">// Parse flags</span></span><br><span class="line">        	<span class="keyword">while</span> (cmd-&gt;argv[arg_idx] &amp;&amp; cmd-&gt;argv[arg_idx][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            		<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-x&quot;</span>) == <span class="number">0</span>) export_f = <span class="number">1</span>;</span><br><span class="line">            		<span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-r&quot;</span>) == <span class="number">0</span>) readonly_f = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-xr&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">				 mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-rx&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				export_f = <span class="number">1</span>;</span><br><span class="line">				readonly_f = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            		<span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="built_in">printf</span>(<span class="string">&quot;declare: invalid option %s\n&quot;</span>, cmd-&gt;argv[arg_idx]);</span><br><span class="line">                		<span class="keyword">return</span>; <span class="comment">// Indicate error if builtins had return values</span></span><br><span class="line">            		&#125;</span><br><span class="line">            		arg_idx++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (cmd-&gt;argv[arg_idx]) &#123; <span class="comment">// NAME[=VALUE] part</span></span><br><span class="line">            		name_val_pair = cmd-&gt;argv[arg_idx];</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (!name_val_pair) &#123; <span class="comment">// Just &quot;declare&quot; or &quot;declare -xr&quot;</span></span><br><span class="line">            		print_all_variables();</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            		<span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            		<span class="type">char</span> value_buf[MAX_VAR_VALUE_LEN + <span class="number">1</span>]; <span class="comment">// Buffer for value if parsed</span></span><br><span class="line">            		<span class="type">char</span> *value_ptr = <span class="literal">NULL</span>;</span><br><span class="line">            		<span class="type">char</span> *eq_ptr = <span class="built_in">strchr</span>(name_val_pair, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            		<span class="keyword">if</span> (eq_ptr) &#123; <span class="comment">// NAME=VALUE</span></span><br><span class="line">                		<span class="type">int</span> name_len = eq_ptr - name_val_pair;</span><br><span class="line">                		<span class="keyword">if</span> (name_len &gt; MAX_VAR_NAME_LEN) &#123; <span class="comment">/* error */</span> <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrncpy(name, name_val_pair, name_len);</span><br><span class="line">                		name[name_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                		value_ptr = eq_ptr + <span class="number">1</span>; <span class="comment">// Can be empty string</span></span><br><span class="line">                		<span class="keyword">if</span> (mystrlen(value_ptr) &gt; MAX_VAR_VALUE_LEN) &#123; <span class="comment">/* error */</span> <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrcpy(value_buf, value_ptr);</span><br><span class="line">                		value_ptr = value_buf;</span><br><span class="line">            		&#125; <span class="keyword">else</span> &#123; <span class="comment">// Just NAME</span></span><br><span class="line">                		<span class="keyword">if</span> (mystrlen(name_val_pair) &gt; MAX_VAR_NAME_LEN) &#123; <span class="comment">/* error */</span> <span class="keyword">return</span>; &#125;</span><br><span class="line">                			mystrcpy(name, name_val_pair);</span><br><span class="line">                			value_ptr = <span class="string">&quot;&quot;</span>; <span class="comment">// Default to empty string</span></span><br><span class="line">            		&#125;</span><br><span class="line">            		set_variable(name, value_ptr, export_f, readonly_f, <span class="number">1</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;unset&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (cmd-&gt;argc != <span class="number">2</span>) &#123;</span><br><span class="line">            		<span class="built_in">printf</span>(<span class="string">&quot;unset: usage: unset NAME\n&quot;</span>);</span><br><span class="line">            		<span class="keyword">return</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	unset_variable(cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">&quot;history: too many arguments\n&quot;</span>);</span><br><span class="line">        		<span class="keyword">return</span>; <span class="comment">// Or return an error code for builtins</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="type">int</span> start_idx;</span><br><span class="line">    		<span class="keyword">if</span> (history_count == <span class="number">0</span>) &#123;</span><br><span class="line">        		<span class="keyword">return</span>; <span class="comment">// Nothing to print</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> (history_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">        		start_idx = <span class="number">0</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		start_idx = history_add_idx; <span class="comment">// Oldest is where next add would go</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; history_count; ++i) &#123;</span><br><span class="line">        		<span class="type">int</span> current_entry_idx = (start_idx + i) % HISTFILESIZE;</span><br><span class="line">        		<span class="comment">// Bash history usually prints with line numbers. For MOS, just the command.</span></span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, history_lines[current_entry_idx]);</span><br><span class="line">    		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键是利用当前工作路径和传入的路径参数计算绝对路径，函数如下：</p>
<p>核心思路是先检验传入的path开头是否是&#x2F;，如果是说明传入的就是绝对路径，那么直接使用即可，如果不是说明是绝对路径，此时需要进行拼接。进行拼接的操作是，先将当前工作路径和传入的相对路径进行字符串拼接，之后进行路径标准化。</p>
<p>路径标准化的方式是，遇到.&#x2F;可以去掉，遇到..&#x2F;则去掉上一级目录，如果没有上一级则保留根目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_final_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cwd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *finalpath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cwd || !path || !finalpath) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Invalid arguments</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> constructed_path[MAXPATHLEN * <span class="number">2</span>]; <span class="comment">// Intermediate buffer for path construction</span></span><br><span class="line">    <span class="comment">// 1. Determine if &#x27;path&#x27; is absolute or relative and construct initial full path</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// Absolute path</span></span><br><span class="line">        <span class="keyword">if</span> (mystrlen(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Error: Absolute path too long.\n&quot;); // Optional debug</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// Path too long</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcpy(constructed_path, path);</span><br><span class="line">        <span class="comment">// As per your spec: &quot;绝对路径，此时将这个绝对路径复制到第三个参数finalpath即可，返回0&quot;</span></span><br><span class="line">        <span class="comment">// This means no stat check for absolute paths here.</span></span><br><span class="line">        <span class="comment">// Normalization is still good practice.</span></span><br><span class="line">	<span class="comment">//printf(&quot;rel is abs, raw finalpath: %s\n&quot;, constructed_path);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Relative path</span></span><br><span class="line">        <span class="comment">// Construct full path: cwd + &quot;/&quot; + path</span></span><br><span class="line">        <span class="keyword">if</span> (mystrlen(cwd) + <span class="number">1</span> + mystrlen(path) + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(constructed_path)) &#123; <span class="comment">// +1 for potential slash, +1 for null</span></span><br><span class="line">            <span class="comment">// printf(&quot;Error: Constructed relative path too long.\n&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mystrcpy(constructed_path, cwd);</span><br><span class="line">        <span class="comment">// Add slash if cwd is not &quot;/&quot; and path is not empty</span></span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span> &amp;&amp; constructed_path[mystrlen(constructed_path) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            mystrcat(constructed_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span> &amp;&amp; mystrlen(constructed_path) &gt; <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="comment">// If cwd was &quot;/&quot; and something got appended making it &quot;//path&quot;, fix to &quot;/path&quot;</span></span><br><span class="line">            <span class="comment">// This case is usually handled by normalize_path later.</span></span><br><span class="line">            <span class="comment">// More simply, if cwd is &quot;/&quot;, just don&#x27;t add another slash if path is not empty.</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcat(constructed_path, path);</span><br><span class="line">	<span class="comment">//printf(&quot;rel is rel, raw finalpath: %s\n&quot;, constructed_path);</span></span><br><span class="line">        <span class="comment">// Normalize the constructed path (handles &quot;.&quot;, &quot;..&quot;, &quot;//&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (normalize_path(constructed_path) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Error: Failed to normalize constructed path &#x27;%s&#x27;\n&quot;, temp_path);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>; <span class="comment">// Normalization error</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For relative paths, after normalization, perform stat check</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">        <span class="type">int</span> r_stat = stat(constructed_path, &amp;st); <span class="comment">// stat uses the (now absolute) constructed_path</span></span><br><span class="line">        <span class="keyword">if</span> (r_stat &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Error from stat typically means not found (check specific error codes if MOS stat provides them)</span></span><br><span class="line">            <span class="comment">// Assuming -E_NOT_FOUND or similar is returned by stat()</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// &quot;does not exist&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.st_isdir == <span class="number">0</span>) &#123; <span class="comment">// FTYPE_DIR is 1, regular file is 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// &quot;is not a directory&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Path exists and is a directory</span></span><br><span class="line">        mystrcpy(finalpath, constructed_path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Success</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normalize_path function (copied from previous response for completeness if not in a shared lib)</span></span><br><span class="line"><span class="comment">// Ensure MAXNAMELEN and MAXPATHLEN are defined (typically from fs.h)</span></span><br><span class="line"><span class="comment">// Ensure mystrcmp, mystrncpy, mymemcpy, mystrlen are available</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">normalize_path</span><span class="params">(<span class="type">char</span> *path_buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path_buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> components[MAX_CMD_ARGS][MAXNAMELEN]; </span><br><span class="line">    <span class="type">int</span> comp_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = path_buf;</span><br><span class="line">    <span class="type">int</span> is_absolute = (*p == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="comment">// Phase 1: Parse into components, handling &quot;.&quot; and &quot;..&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        p++; </span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="type">char</span> current_comp_val[MAXNAMELEN];</span><br><span class="line">        <span class="type">char</span> *c_ptr = current_comp_val;</span><br><span class="line">        <span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c_ptr - current_comp_val &lt; MAXNAMELEN - <span class="number">1</span>) *c_ptr++ = *p;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        *c_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &gt; <span class="number">0</span> &amp;&amp; mystrcmp(components[comp_idx - <span class="number">1</span>], <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                comp_idx--; <span class="comment">// Pop if last wasn&#x27;t &quot;..&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute) &#123; <span class="comment">// Relative path: push &quot;..&quot; or if stack top is &quot;..&quot; push another</span></span><br><span class="line">                <span class="keyword">if</span> (comp_idx &lt; MAX_CMD_ARGS) mystrncpy(components[comp_idx++], <span class="string">&quot;..&quot;</span>, MAXNAMELEN<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH; <span class="comment">// Path too complex/long</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If absolute and comp_idx is 0 (or was &quot;..&quot;), &quot;..&quot; from root is ignored or handled by pop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; current_comp_val[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &lt; MAX_CMD_ARGS) mystrncpy(components[comp_idx++], current_comp_val, MAXNAMELEN<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Phase 2: Reconstruct the path from components</span></span><br><span class="line">    <span class="type">char</span> *write_ptr = path_buf;</span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; comp_idx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123; <span class="comment">// Need a separator for components after the first</span></span><br><span class="line">            <span class="keyword">if</span> (write_ptr - path_buf &gt;= MAXPATHLEN - <span class="number">1</span>) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">            *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// First component of a relative path, no leading slash needed from here.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &amp;&amp; write_ptr == path_buf + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Absolute path, first component after root &#x27;/&#x27;, no extra slash if write_ptr is right after it.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = mystrlen(components[i]);</span><br><span class="line">        <span class="keyword">if</span> ((write_ptr - path_buf) + len &gt;= MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        <span class="built_in">memcpy</span>(write_ptr, components[i], len);</span><br><span class="line">        write_ptr += len;</span><br><span class="line">    &#125;</span><br><span class="line">    *write_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// Final fixups for empty or root results</span></span><br><span class="line">    <span class="keyword">if</span> (path_buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_absolute) mystrcpy(path_buf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> mystrcpy(path_buf, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; path_buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path_buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; comp_idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This case means something like &quot;/foo/..&quot; resolved to &quot;/&quot;.</span></span><br><span class="line">        <span class="comment">// If comp_idx is &gt; 0, it means there *were* components that simplified away.</span></span><br><span class="line">        <span class="comment">// If comp_idx became 0 (e.g. /.. or /foo/..), path_buf should correctly be just &quot;/&quot;</span></span><br><span class="line">        <span class="comment">// No specific action needed here if reconstruction is correct.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; write_ptr == path_buf) &#123; </span><br><span class="line">        <span class="comment">// This can happen if input was &quot;/&quot; and comp_idx remained 0.</span></span><br><span class="line">        <span class="comment">// Ensure it&#x27;s at least &quot;/&quot;.</span></span><br><span class="line">        path_buf[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>; path_buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，由于外部指令也需要实现相对路径，因此要确保外部指令在open的时候能够正确打开绝对路径。因此需要改写open函数，在open刚开始的时候，需要先获取当前工作路径并进行路径拼接，之后再利用拼接好的绝对路径来在磁盘中访问文件。</p>
<h3 id="环境变量管理"><a href="#环境变量管理" class="headerlink" title="环境变量管理"></a>环境变量管理</h3><p>MOS 中的Shell目前并不支持环境变量,你需要在shell中增加对环境变量的支持。</p>
<p>规定环境变量在命令中以<code>$</code>开头，名称与C语言变量命名要求，且长度不超过16，环境变量的值长度同样不超过16。环境变量可分为局部变量与非局部变量，仅非局部变量可传入子Shell中，并且只有非只读变量可被修改。</p>
<p><strong>核心数据结构与变量:</strong></p>
<ul>
<li><p><strong>ShellVar shell_vars[MAX_SHELL_VARS];</strong>: 这是实现环境变量管理的核心。它是一个结构体数组，每个 ShellVar 结构体代表一个变量。</p>
<ul>
<li><p>name[MAX_VAR_NAME_LEN + 1]: 变量名。</p>
</li>
<li><p>value[MAX_VAR_VALUE_LEN + 1]: 变量值。</p>
</li>
<li><p>is_exported: 一个标志，表示变量是否为环境变量（非局部变量）。1 表示是环境变量，0 表示是局部变量。</p>
</li>
<li><p>is_readonly: 一个标志，表示变量是否为只读。1 表示只读，0 表示可写。</p>
</li>
<li><p>is_set: 一个标志，表示该 ShellVar 槽是否被使用（即是否设置了变量）。</p>
</li>
</ul>
</li>
<li><p><strong>num_set_vars</strong>: 记录当前已设置的变量数量，用于快速判断是否满了。</p>
</li>
<li><p><strong>expansion_buffer_pool 和 expansion_buffer_pool_index</strong>: 用于存储变量展开后的临时结果。get_expansion_buffer 函数从池中获取一个缓冲区供 expand_string_variables 使用。</p>
</li>
</ul>
<p><strong>实现的功能与对应代码分析:</strong></p>
<ol>
<li><p><strong>变量创建与查找 (find_variable, find_free_slot, set_variable)</strong></p>
<ul>
<li><p>**find_variable(const char *name)**:</p>
<ul>
<li><p>遍历 shell_vars 数组。</p>
</li>
<li><p>如果找到一个槽 is_set 为 1 且 name 与输入 name 相符，则返回指向该 ShellVar 结构体的指针。</p>
</li>
<li><p>否则返回 NULL。</p>
</li>
</ul>
</li>
<li><p><strong>find_free_slot()</strong>:</p>
<ul>
<li><p>遍历 shell_vars 数组，寻找第一个 is_set 为 0 的槽。</p>
</li>
<li><p>返回指向该空槽的指针。如果所有槽都已使用，返回 NULL。</p>
</li>
</ul>
</li>
<li><p>**set_variable(const char *name, const char *value, int export_flag, int readonly_flag, int update_flags_if_exists)**:</p>
<ul>
<li><p><strong>名称和值长度检查</strong>: 检查 name 和 value 的长度是否超过 MAX_VAR_NAME_LEN 和 MAX_VAR_VALUE_LEN。</p>
</li>
<li><p><strong>查找变量</strong>: 首先调用 find_variable 检查变量是否已存在。</p>
</li>
<li><p><strong>修改现有变量</strong>:</p>
<ul>
<li><p>如果变量存在且是只读的 (var-&gt;is_readonly &#x3D;&#x3D; 1)，则不允许修改，打印错误信息并返回 -1。</p>
</li>
<li><p>如果变量存在且可写，则更新其 value。</p>
</li>
<li><p>如果 update_flags_if_exists 为真，则更新 is_exported 和 is_readonly 标志。注意，这里只允许将变量设置为只读，不能从只读变为可写（因为上面的 is_readonly 检查已经捕获了尝试修改只读变量值的情况）。</p>
</li>
</ul>
</li>
<li><p><strong>创建新变量</strong>:</p>
<ul>
<li><p>如果变量不存在，则调用 find_free_slot 寻找空槽。</p>
</li>
<li><p>如果找到空槽，则填充 name、value、is_exported、is_readonly，并将 is_set 设置为 1。</p>
</li>
<li><p>num_set_vars 递增。</p>
</li>
<li><p>如果找不到空槽，打印错误信息并返回 -1。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>变量删除 (unset_variable)</strong></p>
<ul>
<li><p>**unset_variable(const char *name)**:</p>
<ul>
<li><p>调用 find_variable 查找变量。</p>
</li>
<li><p>如果变量不存在，打印错误信息并返回 -1。</p>
</li>
<li><p>如果变量存在但 is_readonly 为 1，打印错误信息（不可删除只读变量）并返回 -1。</p>
</li>
<li><p>如果变量存在且可删除，则将其 is_set 设置为 0，清空 name（方便 find_free_slot），并递减 num_set_vars。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>显示所有变量 (print_all_variables)</strong></p>
<ul>
<li><p><strong>print_all_variables()</strong>:</p>
<ul>
<li>遍历 shell_vars 数组。</li>
<li>对于每个 is_set 为 1 的变量，按照 &lt;var&gt;&#x3D;&lt;val&gt; 的格式打印其 name 和 value。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>变量展开 (expand_string_variables, get_variable_value)</strong></p>
<ul>
<li><p><strong>get_variable_value(const char *name)</strong>:</p>
<ul>
<li>非常简单：查找变量，如果找到并已设置，返回其 value 指针；否则返回 NULL。</li>
</ul>
</li>
<li><p>**expand_string_variables(char *input_str)**:</p>
<ul>
<li><p>这是处理 $VAR 语法的核心。</p>
</li>
<li><p>**检查是否有 ‘</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">′∗∗:如果输入字符串中没有‘′∗∗:如果输入字符串中没有‘</span><br></pre></td></tr></table></figure>
<p>  &#96;，直接复制一份原字符串并返回（避免修改原始字符串，并从池中分配）。</p>
</li>
<li><p><strong>逐字符扫描</strong>:</p>
<ul>
<li><p>遇到 $ 时：</p>
<ul>
<li><p>跳过 $。</p>
</li>
<li><p><strong>解析变量名</strong>: 从 $ 后开始，读取符合变量命名规则的字符（这里允许字母、数字、下划线，直到遇到空格、$、操作符或字符串结束，且不超过 MAX_VAR_NAME_LEN）。</p>
</li>
<li><p><strong>查找变量值</strong>: 调用 get_variable_value 获取变量名对应的值。</p>
</li>
<li><p><strong>追加到输出</strong>: 如果找到变量值，将其追加到输出缓冲区。如果变量不存在，则什么也不追加（相当于展开为空）。</p>
</li>
<li><p><strong>处理单个 $</strong>: 如果 $ 后没有有效变量名（例如 $$ 或 $ 后面紧跟分隔符），则将 $ 字面量添加到输出。</p>
</li>
</ul>
</li>
<li><p>遇到非 $ 字符时：</p>
<ul>
<li>直接将其追加到输出缓冲区。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>缓冲区管理</strong>: 使用 get_expansion_buffer() 从池中获取缓冲区，并检查是否会溢出 MAX_EXPANDED_STR_LEN。</p>
</li>
<li><p><strong>结果返回</strong>: 返回一个指向已展开字符串的指针（在 expansion_buffer_pool 中）。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>环境变量继承与子 Shell (main 函数中 spawn 相关的部分, execute_ast 中 NODE_COMMAND 的 child 进程部分)</strong></p>
<ul>
<li><p><strong>main 函数 (处理传递给 sh.b 的参数)</strong>:</p>
<ul>
<li><p>在 main 函数的开头，当解析到参数列表时，代码遍历 argv。</p>
</li>
<li><p>它检查形如 NAME&#x3D;VALUE 的参数，并将其视为从父 Shell 传递过来的环境变量。</p>
</li>
<li><p>对于这些参数，它会解析出 NAME 和 VALUE，并调用 set_variable 将它们设置为<strong>环境变量</strong> (is_exported &#x3D; 1)，并且<strong>不是只读</strong> (is_readonly &#x3D; 0，除非参数以 ‘1’ 开头，但这个逻辑不太符合标准环境变量传递方式，可能是特定实现)。</p>
</li>
</ul>
</li>
<li><p><strong>execute_ast (处理 NODE_COMMAND)</strong>:</p>
<ul>
<li><p>当执行一个 NODE_COMMAND 节点时，如果是执行 sh.b 或 sh 命令本身：</p>
<ul>
<li><p>它会准备一个 spawn_argv 数组。</p>
</li>
<li><p>首先复制命令和它的参数。</p>
</li>
<li><p>然后，它遍历 shell_vars 数组，查找所有 is_exported 为 1 的变量。</p>
</li>
<li><p>对于每一个导出的环境变量，它会构建一个 “NAME&#x3D;VALUE” 的字符串（<strong>这里有一个小问题，代码中 env_str_pool 的构建逻辑似乎是 strcat(current_env_str, “1”); 然后 strcat(current_env_str, shell_vars[i].name); … 看起来像是把 is_readonly 标志放在了环境变量字符串的开头，这可能不是标准方式，标准是直接传 NAME&#x3D;VALUE，父进程的 envp 数组包含这些。但对于子 shell 的 spawn 函数来说，只要它能正确解析，就可以工作。</strong>）。</p>
</li>
<li><p>将这些 “NAME&#x3D;VALUE” 字符串添加到 spawn_argv 中，最后以 NULL 结束。</p>
</li>
<li><p>最后调用 spawn(cmd-&gt;argv[0], spawn_argv)，这将创建一个子进程，并将这些环境变量作为子进程的环境传递（通常 spawn 函数会处理 argv 的格式来设置子进程的环境）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结实现情况:</strong></p>
<ul>
<li><p><strong>环境变量管理 (局部&#x2F;环境变量, 读写性)</strong>: <strong>已实现</strong>。通过 ShellVar 结构体的 is_exported 和 is_readonly 标志以及 set_variable 函数来管理。</p>
</li>
<li><p><strong>declare 内建指令</strong>: <strong>已实现</strong>。</p>
<ul>
<li><p>支持 -x (is_exported) 和 -r (is_readonly) 标志。</p>
</li>
<li><p>支持 NAME[&#x3D;VALUE] 格式的设置。</p>
</li>
<li><p>支持缺省 VALUE 为空字符串。</p>
</li>
<li><p>支持只输入 declare 显示所有变量。</p>
</li>
<li><p><strong>注意</strong>: 对于 declare 输出所有变量部分，它只打印 name&#x3D;value，没有显示 export 或 readonly 标记。</p>
</li>
</ul>
</li>
<li><p><strong>unset 内建指令</strong>: <strong>已实现</strong>。</p>
<ul>
<li><p>支持删除非只读变量。</p>
</li>
<li><p>对只读变量的操作会报错。</p>
</li>
</ul>
</li>
<li><p><strong>变量展开 ($NAME)</strong>: <strong>已实现</strong>。在 expand_string_variables 函数中完成，能够处理 $VAR，并从环境变量池中取值。支持对文件名和命令参数中的变量进行展开。</p>
</li>
<li><p><strong>环境变量继承</strong>: <strong>已实现</strong>。在子 Shell (sh.b) 启动时，将导出的变量以 NAME&#x3D;VALUE 的形式传递给 spawn 函数。</p>
</li>
<li><p><strong>子 Shell 修改环境变量不影响父 Shell</strong>: <strong>已实现</strong>。当子 Shell 修改或添加其自己的变量时，这些修改只发生在子 Shell 的进程空间内，不会影响父 Shell 的 shell_vars 数组。父 Shell 在执行完子进程后（通过 wait）继续自己的 shell_vars。</p>
</li>
<li><p><strong>只读变量的修改和删除限制</strong>: <strong>已实现</strong>。在 set_variable 和 unset_variable 中都有相应的检查。</p>
</li>
</ul>
<p><strong>潜在的改进或注意事项:</strong></p>
<ul>
<li><strong>declare 输出格式</strong>: print_all_variables 可以修改以更像 bash，显示 export 和 readonly 等修饰符。</li>
</ul>
<h3 id="指令自由输入"><a href="#指令自由输入" class="headerlink" title="指令自由输入"></a>指令自由输入</h3><p>现有的 shell 不支持在输入命令时移动光标。你需要实现：键入命令时，可以使用 Left 和 Right 移动光标位置，并可以在当前光标位置进行字符的增加与删除。要求每次在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。</p>
<p><strong>实现机制分析:</strong></p>
<ol>
<li><p><strong>缓冲区与光标管理:</strong></p>
<ul>
<li><p>buf: 存储用户当前输入的命令字符串。</p>
</li>
<li><p>n: buf 的总大小。</p>
</li>
<li><p>current_len: 当前 buf 中已输入的字符数量。</p>
</li>
<li><p>cursor_pos: 当前光标在 buf 中的位置（从 0 开始，表示在第一个字符之前）。</p>
</li>
<li><p>onscreen_cmd_len: 记录了上次在屏幕上显示了多少个命令字符。这对于正确地擦除旧内容（通过打印空格）和定位光标非常重要。</p>
</li>
</ul>
</li>
<li><p><strong>按键读取与分类:</strong></p>
<ul>
<li><p>read(0, &amp;c, 1): 这是核心的输入读取操作，每次读取一个字节（一个字符）。</p>
</li>
<li><p><strong>特殊字符处理</strong>: 代码对各种按键进行了分类处理：</p>
<ul>
<li><p><strong>0x1b (ESC 序列)</strong>: 用于处理方向键 (Left, Right, Up, Down) 和其他特殊组合键。</p>
<ul>
<li><p>读取完 ESC (0x1b) 后，会尝试读取接下来的两个字符 (seq[0], seq[1]) 来识别具体的控制序列。</p>
</li>
<li><p>seq[1] &#x3D;&#x3D; ‘A’ (Up Arrow): 触发历史记录向上浏览（后面会详细讲）。</p>
</li>
<li><p>seq[1] &#x3D;&#x3D; ‘B’ (Down Arrow): 触发历史记录向下浏览。</p>
</li>
<li><p>seq[1] &#x3D;&#x3D; ‘D’ (Left Arrow): 将 cursor_pos 减 1，如果 cursor_pos &gt; 0。</p>
</li>
<li><p>seq[1] &#x3D;&#x3D; ‘C’ (Right Arrow): 将 cursor_pos 加 1，如果 cursor_pos &lt; current_len。</p>
</li>
</ul>
</li>
<li><p><strong>\b 或 0x7f (Backspace&#x2F;Delete)</strong>:</p>
<ul>
<li><p>如果光标不在行首 (cursor_pos &gt; 0)：</p>
<ul>
<li><p>使用 mymemmove 将光标位置后的所有字符向前移动一位，覆盖掉被删除的字符。</p>
</li>
<li><p>current_len 减 1。</p>
</li>
<li><p>cursor_pos 减 1。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1 以便重新绘制。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>\r 或 \n (回车)</strong>:</p>
<ul>
<li><p>表示命令输入完成。</p>
</li>
<li><p>将 buf 的当前内容保存到 current_typed_line（用于下次输入时恢复）。</p>
</li>
<li><p>调用 add_to_history 和 save_history。</p>
</li>
<li><p>返回 readline 函数，将 buf 的内容传递给解析器。</p>
</li>
</ul>
</li>
<li><p><strong>可打印字符 ( c &gt;&#x3D; 0x20 &amp;&amp; c &lt; 0x7f)</strong>:</p>
<ul>
<li><p>如果光标不在行尾 (cursor_pos &lt; current_len)：</p>
<ul>
<li>使用 mymemmove 将光标位置及之后的字符向后移动一位，为新字符腾出空间。</li>
</ul>
</li>
<li><p>将新字符 c 插入到 buf[cursor_pos]。</p>
</li>
<li><p>current_len 加 1。</p>
</li>
<li><p>cursor_pos 加 1。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p><strong>其他特殊控制键</strong>: 代码还处理了一些常见的编辑组合键，如 Ctrl+A (移到行首), Ctrl+E (移到行尾), Ctrl+K (剪切到行尾), Ctrl+U (剪切到行首), Ctrl+W (删除一个词)。这些功能也依赖于 cursor_pos 和 mymemmove 来修改 buf。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>完整回显 (requires_full_reprint 和屏幕刷新逻辑)</strong>:</p>
<ul>
<li><p>每当输入导致 buf 内容发生变化（插入、删除、移动光标）时，requires_full_reprint 标志会被设置为 1。</p>
</li>
<li><p>在每次循环的结尾，如果 requires_full_reprint 为真并且 interactive 为真：</p>
<ul>
<li><p><strong>printf(“\r”);</strong>: 将光标移动到当前行的开头。</p>
</li>
<li><p><strong>printf(“$ “);</strong>: 重新打印提示符。</p>
</li>
<li><p><strong>打印命令内容</strong>: 遍历 buf 中当前长度的字符并打印出来。</p>
</li>
<li><p><strong>擦除多余字符</strong>: 如果当前输入的命令比上次显示的内容短 (current_len &lt; onscreen_cmd_len)，则需要打印空格来覆盖掉旧的（现在不存在的）字符。</p>
</li>
<li><p><strong>定位光标</strong>:</p>
<ul>
<li><p>effective_displayed_cmd_len 用于计算当前行实际显示了多少字符（包括提示符后的命令部分）。</p>
</li>
<li><p>for (u_int i &#x3D; 0; i &lt; (effective_displayed_cmd_len - cursor_pos); ++i) { printf(“\b”); }: 这是一个关键的回显技巧。它通过打印 \b (退格符) 来将光标移动到正确的位置。例如，如果命令是 ls -l，onscreen_cmd_len 是 4，current_len 是 3，cursor_pos 是 1 (在 l 和 - 之间)，那么需要回退 (4 - 1) &#x3D; 3 步，才能回到新内容的正确位置。</p>
</li>
</ul>
</li>
<li><p><strong>onscreen_cmd_len &#x3D; current_len;</strong>: 更新 onscreen_cmd_len 以便下次回显时知道屏幕上显示了多少内容。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>与历史记录的集成 (history_current_nav_offset, current_typed_line)</strong>:</p>
<ul>
<li><p>history_current_nav_offset: 当用户按下向上或向下箭头时，这个变量用于跟踪用户在历史记录中的位置。0 表示当前正在输入的行；1 表示上一条历史记录；2 表示上两条历史记录，依此类推。</p>
</li>
<li><p>current_typed_line: 当用户从历史记录中选择一条命令并开始编辑它时，readline 会将当前输入的 buf 内容复制到 current_typed_line。这使得用户可以“退出”历史记录浏览模式，回到编辑当前输入行。</p>
</li>
<li><p><strong>历史记录浏览</strong>:</p>
<ul>
<li><p>当按下向上箭头 (seq[1] &#x3D;&#x3D; ‘A’)：</p>
<ul>
<li><p>如果用户正在编辑新行 (history_current_nav_offset &#x3D;&#x3D; 0)，先将当前输入的内容保存到 current_typed_line。</p>
</li>
<li><p>如果还有更早的历史记录可供访问 (history_current_nav_offset &lt; history_count)，则 history_current_nav_offset 增加。</p>
</li>
<li><p>根据新的 history_current_nav_offset 从 history_lines 数组中计算出要显示的旧命令（利用了循环缓冲区索引的计算）。</p>
</li>
<li><p>将该历史命令复制到 buf，更新 current_len 和 cursor_pos，并设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p>当按下向下箭头 (seq[1] &#x3D;&#x3D; ‘B’)：</p>
<ul>
<li><p>如果 history_current_nav_offset &gt; 0，则 history_current_nav_offset 减小。</p>
</li>
<li><p>如果 history_current_nav_offset 变为了 0，表示用户回到了最初的 current_typed_line，此时将 current_typed_line 的内容复制回 buf。</p>
</li>
<li><p>否则，从历史记录中加载旧命令，更新 buf 和相关变量，并重绘。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结实现细节:</strong></p>
<ul>
<li><p><strong>光标移动</strong>: 通过精确控制 cursor_pos 变量，并在每次改动后使用退格符 \b 来重定位光标，实现左右光标移动。</p>
</li>
<li><p><strong>字符插入</strong>: 使用 mymemmove 将光标后的内容后移，腾出空间，然后在 buf[cursor_pos] 插入字符。</p>
</li>
<li><p><strong>字符删除</strong>: 使用 mymemmove 将光标后的内容前移，覆盖被删除字符。</p>
</li>
<li><p><strong>完整回显</strong>: 通过 onscreen_cmd_len 和 requires_full_reprint 标志，在每次输入改动后，重新绘制整个命令行的内容，并精确地将光标放回正确位置。这保证了用户看到的是一个连续的、正确的编辑界面。</p>
</li>
<li><p><strong>历史记录集成</strong>: 通过 history_current_nav_offset 和 current_typed_line 实现了在输入行和历史记录之间的切换和编辑。</p>
</li>
</ul>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>你需要在Shell中实现以下快捷键:<br>快捷键行为:<br>left-arrow    光标尝试向左移动，如果可以移动则移动<br>right-arrow    光标尝试向右移动，如果可以移动则移动<br>backspace    删除光标左侧 1 个字符并将光标向左移动 1 列；若已在行首则无动作<br>Ctrl-E    光标跳至最后<br>Ctrl-A    光标跳至最前<br>Ctrl-K    删除从当前光标处到最后的文本<br>Ctrl-U    删除从最开始到光标前的文本<br>Ctrl-W    向左删除最近一个 word：先越过空白(如果有)，再删除连续非空白字符</p>
<p>*<em>核心函数: readline(char <em>buf, u_int n, int interactive)</em></em></p>
<p>这个函数是处理所有用户输入的入口，它负责识别按键，执行相应的操作，并在必要时更新屏幕显示。</p>
<p><strong>快捷键实现分析:</strong></p>
<ol>
<li><p><strong>光标移动 (Left&#x2F;Right Arrow)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x1b (ESC), seq[0] &#x3D;&#x3D; ‘[‘, seq[1] &#x3D;&#x3D; ‘D’ (Left) 或 ‘C’ (Right)。</p>
</li>
<li><p><strong>Left Arrow (seq[1] &#x3D;&#x3D; ‘D’)</strong>:</p>
<ul>
<li><p>检查 cursor_pos &gt; 0。</p>
</li>
<li><p>如果条件为真，则 cursor_pos–。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1，表示屏幕需要重绘以反映光标位置的变化。</p>
</li>
</ul>
</li>
<li><p><strong>Right Arrow (seq[1] &#x3D;&#x3D; ‘C’)</strong>:</p>
<ul>
<li><p>检查 cursor_pos &lt; current_len。</p>
</li>
<li><p>如果条件为真，则 cursor_pos++。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: requires_full_reprint 标志会在循环末尾触发屏幕重绘，根据新的 cursor_pos 定位光标，确保用户看到正确的显示。</p>
</li>
</ul>
</li>
<li><p><strong>Backspace (删除光标左侧字符)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; ‘\b’ 或 c &#x3D;&#x3D; 0x7f (通常是 Backspace 或 Delete 键)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>首先检查 history_current_nav_offset !&#x3D; 0。如果用户正在浏览历史记录，按下 Backspace 会将其从历史记录模式切换回正常编辑模式，并将当前显示的历史记录复制到 current_typed_line。这是一个重要的 UX 考虑。</p>
</li>
<li><p>检查 cursor_pos &gt; 0 (确保不在行首)。</p>
</li>
<li><p>如果光标不在行首：</p>
<ul>
<li><p>mymemmove(&amp;buf[cursor_pos - 1], &amp;buf[cursor_pos], current_len - cursor_pos + 1): 这是核心操作。它将光标位置 cursor_pos 处的字符（包括光标本身）以及之后的所有字符，向前移动一个位置。这effectively抹去了光标左侧的字符。</p>
</li>
<li><p>cursor_pos–: 光标位置随之向左移动一位。</p>
</li>
<li><p>current_len–: 输入的字符总数减少一个。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>行首处理</strong>: 如果 cursor_pos &#x3D;&#x3D; 0，则 Backspace 键被忽略，不做任何操作。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-E (光标跳至最后)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x05 (Ctrl-E 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>检查 cursor_pos !&#x3D; current_len。</p>
</li>
<li><p>如果光标不在行尾，则 cursor_pos &#x3D; current_len。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，光标会直接定位到行尾。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-A (光标跳至最前)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x01 (Ctrl-A 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>检查 cursor_pos !&#x3D; 0。</p>
</li>
<li><p>如果光标不在行首，则 cursor_pos &#x3D; 0。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，光标会直接定位到行首。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-K (删除从当前光标处到最后的文本)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x0B (Ctrl-K 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>首先，检查用户是否在浏览历史记录，如果是，则将其切换到正常编辑模式（同 Backspace）。</p>
</li>
<li><p>检查 cursor_pos &lt; current_len。</p>
</li>
<li><p>如果光标不在行尾（即有文本可删）：</p>
<ul>
<li><p>buf[cursor_pos] &#x3D; ‘\0’;: 在当前光标位置直接截断字符串，将该位置之后的所有内容视为无效。</p>
</li>
<li><p>current_len &#x3D; cursor_pos;: 更新当前字符串长度为光标位置。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，只会显示从行首到新 current_len 的内容。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-U (删除从最开始到光标前的文本)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x15 (Ctrl-U 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>首先，检查用户是否在浏览历史记录，如果是，则将其切换到正常编辑模式。</p>
</li>
<li><p>检查 cursor_pos &gt; 0。</p>
</li>
<li><p>如果光标不在行首（即有文本可删）：</p>
<ul>
<li><p>mymemmove(&amp;buf[0], &amp;buf[cursor_pos], current_len - cursor_pos + 1);: 这是核心操作。它将光标位置 cursor_pos 开始的所有字符（包括光标位置后的文本），移动到缓冲区的开头 (buf[0])。这 effectively 丢弃了光标之前（包括光标位置前的）的所有字符。</p>
</li>
<li><p>current_len -&#x3D; cursor_pos;: 更新当前字符串长度，减去被删除的字符数量。</p>
</li>
<li><p>cursor_pos &#x3D; 0;: 光标被重置到行首，因为所有内容都从那里开始显示了。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，从 buf[0] 开始显示，并且光标定位在行首。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-W (向左删除最近一个 word)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x17 (Ctrl-W 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>首先，检查用户是否在浏览历史记录，如果是，则将其切换到正常编辑模式。</p>
</li>
<li><p><strong>查找删除范围</strong>:</p>
<ul>
<li><p>original_cursor_pos &#x3D; cursor_pos;: 保存当前光标位置，以便后续处理。</p>
</li>
<li><p><strong>越过尾部空白</strong>: 从 cursor_pos 开始，向前查找第一个非空白字符 (while (cursor_pos &gt; 0 &amp;&amp; strchr(“ \t”, buf[cursor_pos - 1])) cursor_pos–;)。这一步是为了处理用户可能在词后输入了空格的情况。</p>
</li>
<li><p>end_of_deletion_span &#x3D; cursor_pos;: 记录当前光标位置（即词的末尾，或尾部空白的起始位置）。</p>
</li>
<li><p><strong>查找词的起始</strong>: 从 cursor_pos 开始，向前查找第一个空白字符 (while (start_of_word_to_delete &gt; 0 &amp;&amp; !strchr(“ \t”, buf[start_of_word_to_delete - 1])) { start_of_word_to_delete–; })。这会找到词（或词前面空白串）的起始位置。</p>
</li>
</ul>
</li>
<li><p><strong>执行删除</strong>:</p>
<ul>
<li><p>如果找到了需要删除的有效范围 (start_of_word_to_delete &lt; end_of_deletion_span)：</p>
<ul>
<li><p>mymemmove(&amp;buf[start_of_word_to_delete], &amp;buf[end_of_deletion_span], current_len - end_of_deletion_span + 1);: 将词（和它前面的空白）之后的文本移动到词的起始位置，覆盖掉词及其前面的空白。</p>
</li>
<li><p>current_len -&#x3D; (end_of_deletion_span - start_of_word_to_delete);: 更新总长度。</p>
</li>
<li><p>cursor_pos &#x3D; start_of_word_to_delete;: 将光标定位到删除区域的起始位置。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p>如果未找到有效删除范围（例如在行首或者只有空白），光标会回到 original_cursor_pos（基本上无变化）。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，显示被修改后的 buf，并将光标定位到删除词的起始位置。</p>
</li>
</ul>
</li>
</ol>
<p><strong>回显更新逻辑的关键点:</strong></p>
<p>requires_full_reprint 配合 onscreen_cmd_len 和退格符 \b 是实现精确回显的关键。当需要更新屏幕时：</p>
<ol>
<li><p>移动光标到行首 (\r)。</p>
</li>
<li><p>重绘提示符 ($)。</p>
</li>
<li><p>打印新的命令内容。</p>
</li>
<li><p>如果新内容比旧内容短，则打印足够多的空格来“擦除”旧内容中多余的部分。</p>
</li>
<li><p>关键是根据新光标位置，通过连续打印 \b 来将光标准确地放回显示内容的正确位置。</p>
</li>
</ol>
<h3 id="历史指令"><a href="#历史指令" class="headerlink" title="历史指令"></a>历史指令</h3><p>你需要实现 shell 中保存历史指令的功能，可以通过 Up 和 Down 选择所保存的指令并执行。你需要将历史指令保存到根目录的 <code>.mos_history</code> 文件中（一条指令一行），为了评测的方便，我们设定 <code>$HISTFILESIZE=20</code>（bash 中默认为 500），即在 <code>.mos_history</code> 中至多保存最近的 20 条指令。你还需要支持通过 <code>history</code> 命令输出 <code>.mos_history</code> 文件中的内容。</p>
<p><strong>核心数据结构与变量:</strong></p>
<ul>
<li><p><strong>HISTFILESIZE 20</strong>: 定义了历史记录文件和内存中最多保存的指令条数。</p>
</li>
<li><p><strong>HISTORY_FILE “&#x2F;.mos_history”</strong>: 定义了存储历史记录的文件路径。</p>
</li>
<li><p><strong>char history_lines[HISTFILESIZE][MAX_INPUT_BUF]</strong>: 这是一个二维字符数组，用于在内存中存储历史指令。它被实现为一个<strong>循环缓冲区</strong>。</p>
</li>
<li><p><strong>int history_count &#x3D; 0;</strong>: 当前内存中实际存储的历史指令条数。</p>
</li>
<li><p><strong>int history_add_idx &#x3D; 0;</strong>: 在循环缓冲区中，下一个要添加的新指令的索引。当缓冲区满时，这个索引会指向最旧的那个指令，新指令会覆盖它。</p>
</li>
<li><p><strong>int history_latest_idx &#x3D; -1;</strong>: 在循环缓冲区中，最近添加的指令的索引。-1 表示历史记录为空。</p>
</li>
<li><p><strong>int history_current_nav_offset &#x3D; 0;</strong>: 用户在浏览历史记录时的偏移量。</p>
<ul>
<li><p>0: 表示用户当前正在输入新的命令，或者已经回到了输入的新命令。</p>
</li>
<li><p>1: 表示用户选择的是上一条历史记录。</p>
</li>
<li><p>N: 表示用户选择的是第 N 条历史记录。</p>
</li>
</ul>
</li>
<li><p><strong>char current_typed_line[MAX_INPUT_BUF] &#x3D; {0};</strong>: 用于暂存用户在浏览历史记录时（按下 Up Arrow）之前输入的、未提交的命令。当用户按下 Down Arrow 并且 history_current_nav_offset 变为 0 时，会从这里恢复。</p>
</li>
</ul>
<p><strong>实现的功能与对应代码分析:</strong></p>
<ol>
<li><p><strong>加载历史记录 (load_history())</strong></p>
<ul>
<li><p><strong>目的</strong>: Shell 启动时，从 HISTORY_FILE 读取最近 HISTFILESIZE 条指令到内存中的 history_lines。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>打开 HISTORY_FILE (只读 O_RDONLY)。如果文件不存在或无法打开，则静默失败（不加载历史）。</p>
</li>
<li><p>逐行读取文件内容到 line_buf。</p>
</li>
<li><p>使用一个临时缓冲区 temp_history_load 来存储从文件读取的行。</p>
</li>
<li><p><strong>循环缓冲区填充逻辑</strong>:</p>
<ul>
<li><p>如果 temp_count (临时缓冲区中的条数) 小于 HISTFILESIZE，则直接添加到 temp_history_load。</p>
</li>
<li><p>如果 temp_count 达到 HISTFILESIZE，则在添加新行之前，将 temp_history_load 中的所有旧条目向前移动一位，覆盖掉最旧的条目，然后将新行添加到最后。这是一个模拟循环缓冲区的策略。</p>
</li>
</ul>
</li>
<li><p>文件读取完毕后，将 temp_history_load 中的内容按照正确的顺序（从旧到新）复制到实际的 history_lines 循环缓冲区中，并更新 history_add_idx 和 history_latest_idx。</p>
</li>
<li><p>最后，将 history_current_nav_offset 重置为 0。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>保存历史记录 (save_history())</strong></p>
<ul>
<li><p><strong>目的</strong>: Shell 退出时，将内存中的 history_lines（最新的 HISTFILESIZE 条）写回 HISTORY_FILE。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>打开 HISTORY_FILE (写模式 O_WRONLY，创建 O_CREAT，截断 O_TRUNC)。如果打开失败则打印错误。</p>
</li>
<li><p>根据 history_count 和 history_add_idx 确定历史记录的起始索引 (start_idx)。如果历史记录未满 (history_count &lt; HISTFILESIZE)，则从索引 0 开始；如果已满或溢出，则从 history_add_idx 开始（这是最旧的记录）。</p>
</li>
<li><p>从 start_idx 开始，循环 history_count 次，将 history_lines[current_entry_idx] 的内容和换行符写入文件。</p>
</li>
<li><p>关闭文件。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>*<em>添加指令到历史记录 (add_to_history(const char <em>cmd_line))</em></em></p>
<ul>
<li><p><strong>目的</strong>: 在用户执行一条指令后，将其添加到内存中的历史记录。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>忽略空命令。</p>
</li>
<li><p><strong>去重</strong>: 检查新命令是否与最后一条历史记录相同。如果相同，则不添加，避免重复项。</p>
</li>
<li><p>将新命令 cmd_line 复制到 history_lines[history_add_idx]。</p>
</li>
<li><p>更新 history_latest_idx &#x3D; history_add_idx。</p>
</li>
<li><p>更新 history_add_idx &#x3D; (history_add_idx + 1) % HISTFILESIZE，移动到下一个可用位置。</p>
</li>
<li><p>如果 history_count &lt; HISTFILESIZE，则 history_count++，表示记录数增加。</p>
</li>
<li><p><strong>重置导航状态</strong>: history_current_nav_offset &#x3D; 0，表示用户回到了当前输入的行，而不是在浏览历史记录。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用 Up&#x2F;Down Arrow 选择历史记录 (在 readline 函数中)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: 读取到 ESC 序列，并且是 ‘[‘ 后面跟着 ‘A’ (Up) 或 ‘B’ (Down)。</p>
</li>
<li><p><strong>Up Arrow (seq[1] &#x3D;&#x3D; ‘A’)</strong>:</p>
<ul>
<li><p>首先，如果用户当前正在编辑新行 (history_current_nav_offset &#x3D;&#x3D; 0)，则将 buf 的内容保存到 current_typed_line，为稍后恢复输入提供基础。</p>
</li>
<li><p>检查 history_current_nav_offset &lt; history_count。这确保了我们不会越过最早的记录。</p>
</li>
<li><p>如果可以向上浏览：</p>
<ul>
<li><p>history_current_nav_offset++。</p>
</li>
<li><p>根据新的 history_current_nav_offset 和 history_latest_idx 计算出要加载的历史记录在 history_lines 数组中的实际索引 (nav_idx_in_hist_array)。</p>
</li>
<li><p>将该历史记录复制到 buf，更新 current_len 和 cursor_pos。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1 以更新屏幕显示。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Down Arrow (seq[1] &#x3D;&#x3D; ‘B’)</strong>:</p>
<ul>
<li><p>检查 history_current_nav_offset &gt; 0。这确保了我们不会越过当前输入的行。</p>
</li>
<li><p>如果可以向下浏览：</p>
<ul>
<li><p>history_current_nav_offset–。</p>
</li>
<li><p>如果 history_current_nav_offset &#x3D;&#x3D; 0，表示用户回到了最初的输入行，将 current_typed_line 的内容复制回 buf。</p>
</li>
<li><p>否则（仍然在浏览历史记录），计算要加载的历史记录索引，加载并显示。</p>
</li>
<li><p>更新 buf，current_len，cursor_pos，并设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>history 内建命令 (execute_inner_cmd 函数)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: 当 execute_ast 检测到 NODE_COMMAND 的第一个参数是 “history” 且没有其他参数时。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>检查 cmd-&gt;argc &gt; 1。如果命令带了除 history 之外的参数，会打印用法错误。</p>
</li>
<li><p>如果 history_count &#x3D;&#x3D; 0，则什么也不做。</p>
</li>
<li><p><strong>确定起始打印位置</strong>:</p>
<ul>
<li><p>如果 history_count &lt; HISTFILESIZE (历史记录未满)，从索引 0 开始打印。</p>
</li>
<li><p>如果 history_count &gt;&#x3D; HISTFILESIZE (历史记录已满或已循环)，则从 history_add_idx 开始打印（因为 history_add_idx 指向的是下一个要添加的位置，也就是最旧的那个元素）。</p>
</li>
</ul>
</li>
<li><p><strong>遍历并打印</strong>: 从确定的 start_idx 开始，循环 history_count 次，使用模运算 (% HISTFILESIZE) 来正确地在循环缓冲区中获取和打印每一条历史记录。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>与主循环的交互:</strong></p>
<ul>
<li><p>Shell 的主循环 (main 函数) 在每次迭代开始时：</p>
<ul>
<li><p>调用 load_history() 加载历史记录。</p>
</li>
<li><p>调用 readline() 获取用户输入。</p>
</li>
<li><p>readline 返回后，将用户的输入（可能经过历史记录选择和编辑）复制到 input_buf。</p>
</li>
<li><p>然后调用 add_to_history() 将这条输入的命令添加到内存历史记录中。</p>
</li>
<li><p>接着调用 save_history() 将最新的历史记录写回文件。</p>
</li>
</ul>
</li>
</ul>
<p><strong>总结:</strong></p>
<p>MOS Shell 通过以下方式实现了历史指令功能：</p>
<ul>
<li><p><strong>内存存储</strong>: 使用一个循环缓冲区 history_lines 在内存中保存最近的 HISTFILESIZE 条指令。</p>
</li>
<li><p><strong>文件持久化</strong>: 在启动时加载，退出时保存到 .mos_history 文件，确保历史记录的持久性。</p>
</li>
<li><p><strong>历史记录浏览</strong>: 在 readline 函数中通过解析方向键序列，利用 history_current_nav_offset 来跟踪用户在历史记录中的位置，并动态加载和显示历史命令到输入行。</p>
</li>
<li><p><strong>编辑与恢复</strong>: 使用 current_typed_line 变量，允许用户在浏览历史记录后编辑选择的命令，并将编辑后的命令作为新的当前输入行处理。</p>
</li>
<li><p><strong>history 命令</strong>: 实现了一个内建命令，可以方便地查看当前内存中的所有历史指令。</p>
</li>
</ul>
<h3 id="实现反引号"><a href="#实现反引号" class="headerlink" title="实现反引号"></a>实现反引号</h3><p>你需要使用反引号实现指令替换。你需要将反引号内指令执行的所有标准输出代替原有指令中的反引号内容。</p>
<p><strong>关键函数与逻辑:</strong></p>
<ol>
<li><p><strong>识别反引号</strong>:</p>
<ul>
<li><p>反引号  被识别为一种特殊的 TOKEN_WORD。</p>
</li>
<li><p>在 get_next_raw_token() 函数中，当遇到`时，它会捕获从开头的  到匹配的结尾  的所有内容，并将这个字符串（包括反引号）作为一个 TOKEN_WORD 返回。</p>
</li>
<li><p><strong>注意</strong>: 当前的 get_next_raw_token 实现对于反引号的识别很简单，它会把  包裹的内容作为一个单独的 TOKEN_WORD。它<strong>不处理嵌套反引号</strong>，<strong>也不处理反引号内的转义字符</strong>（例如 \ 后面跟着 ）。</p>
</li>
</ul>
</li>
<li><p><strong>命令替换的执行 (execute_command_substitution)</strong></p>
<ul>
<li><p><strong>被调用时机</strong>: 这个函数在 parse_command() 函数内部被调用。当 parse_command() 处理一个 TOKEN_WORD 时，它会先调用 expand_string_variables 来展开变量，然后对展开后的字符串执行一个<strong>二次扫描</strong>，查找其中的反引号对。</p>
</li>
<li><p><strong>get_subst_output_buffer()</strong>: 这个函数从一个预分配的缓冲区池中获取一个空缓冲区，用于存储被替换命令的输出。这限制了同时进行的命令替换的数量和单个替换输出的最大长度。</p>
</li>
<li><p><strong>创建管道</strong>: pipe(pipe_fds) 创建一个匿名管道。管道的读端 (pipe_fds[0]) 和写端 (pipe_fds[1]) 会被用来连接父 Shell 和子命令的输出。</p>
</li>
<li><p><strong>fork() 子进程</strong>:</p>
<ul>
<li><p>在父 Shell（即当前 MOS Shell 进程）中 fork() 出一个子进程。</p>
</li>
<li><p><strong>子进程</strong>:</p>
<ul>
<li><p>关闭管道的读端 (pipe_fds[0])。</p>
</li>
<li><p><strong>重定向标准输出</strong>: dup(pipe_fds[1], 1) 将子进程的标准输出文件描述符 (1) 重定向到管道的写端 (pipe_fds[1])。</p>
</li>
<li><p>关闭原始的管道写端描述符 pipe_fds[1]。</p>
</li>
<li><p><strong>执行命令</strong>: 使用 spawn(“&#x2F;sh.b”, sh_argv) 来执行一个独立的 sh.b shell 实例，并传递 -c 参数以及反引号内的实际命令字符串 (command_to_run)。这个 sh.b 进程会执行 command_to_run，并且其输出会被重定向到管道的写端。</p>
</li>
<li><p>如果 spawn 失败，子进程会打印错误并退出。</p>
</li>
</ul>
</li>
<li><p><strong>父进程</strong>:</p>
<ul>
<li><p>关闭管道的写端 (pipe_fds[1])。</p>
</li>
<li><p><strong>读取管道输出</strong>: 在一个循环中，从管道的读端 (pipe_fds[0]) 读取子进程的标准输出。每次读取一个字符 read_char，并将其追加到预先获取的缓冲区 output_buffer 中。</p>
</li>
<li><p><strong>缓冲区溢出处理</strong>: 如果输出超出了 MAX_CMD_SUBST_OUTPUT_LEN，则打印截断警告，然后丢弃管道中剩余的所有数据，以允许子进程正常结束。</p>
</li>
<li><p>在读取完成后，为 output_buffer 添加 null 终止符。</p>
</li>
<li><p>关闭管道的读端 pipe_fds[0]。</p>
</li>
<li><p><strong>wait(child_pid_for_sh_c)</strong>: 父进程等待执行 sh -c “…” 的子进程完成。</p>
</li>
<li><p><strong>后处理输出</strong>:</p>
<ul>
<li><p>移除末尾的换行符和回车符。</p>
</li>
<li><p>将内部的换行符和回车符替换为空字符 \0。这个处理方式是将多个换行符替换成多个 \0，然后 mystrcat 会将它们连接起来，最终形成一个由 \0 分隔的字符串。</p>
</li>
</ul>
</li>
<li><p>返回处理后的 output_buffer 指针。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>在 parse_command 中集成</strong>:</p>
<ul>
<li><p>当 parse_command 遇到一个 TOKEN_WORD 时，它会首先对 current_token.value 进行<strong>变量展开</strong>（调用 expand_string_variables）。</p>
</li>
<li><p>然后，对变量展开后的字符串（存储在 arg_after_var_expansion 中），进行<strong>二次扫描</strong>来处理命令替换。</p>
</li>
<li><p><strong>处理反引号</strong>:</p>
<ul>
<li><p>使用 scan_ptr 遍历字符串。</p>
</li>
<li><p>查找第一个反引号  (backtick_start)。</p>
</li>
<li><p>查找匹配的第二个反引号  (backtick_end)。</p>
</li>
<li><p>如果找到了成对的反引号：</p>
<ul>
<li><p>将反引号前的部分（scan_ptr 到 backtick_start）复制到 rebuilt_arg_buffer。</p>
</li>
<li><p>提取反引号之间的命令字符串 cmd_to_subst。</p>
</li>
<li><p>调用 execute_command_substitution(cmd_to_subst, …) 来执行命令替换。</p>
</li>
<li><p>将 execute_command_substitution 返回的（已处理的）输出追加到 rebuilt_arg_buffer。</p>
</li>
<li><p>更新 scan_ptr 到 backtick_end + 1，继续扫描。</p>
</li>
</ul>
</li>
<li><p>如果只找到开头的反引号但没有匹配的结尾反引号，则将该部分作为字面量处理。</p>
</li>
<li><p>如果字符串中没有反引号，则直接将 arg_after_var_expansion 复制到 rebuilt_arg_buffer。</p>
</li>
</ul>
</li>
<li><p>最后，将 rebuilt_arg_buffer 中的内容 user_strdup，作为最终的参数传给 cmd_data-&gt;argv。</p>
</li>
</ul>
</li>
</ol>
<p><strong>总结实现机制:</strong></p>
<ol>
<li><p><strong>标记</strong>: 反引号被 tokenizer 识别为特殊的 TOKEN_WORD。</p>
</li>
<li><p><strong>解析与处理</strong>: parse_command 在处理 TOKEN_WORD 时，先执行变量展开，然后扫描展开后的字符串，查找  对。</p>
</li>
<li><p><strong>分离命令</strong>: 反引号内的命令被提取出来。</p>
</li>
<li><p><strong>子 Shell 执行</strong>: 创建一个子进程，通过 sh -c “…” 来执行提取出的命令。</p>
</li>
<li><p><strong>输出重定向</strong>: 子进程的标准输出被重定向到一个管道。</p>
</li>
<li><p><strong>捕获输出</strong>: 父进程从管道中读取子进程的所有输出。</p>
</li>
<li><p><strong>后处理</strong>: 输出的换行符被移除或替换，然后成为最终的替换文本。</p>
</li>
<li><p><strong>组装参数</strong>: 最终的参数（包含命令替换结果的参数）被构建并传递给命令的执行。</p>
</li>
</ol>
<p><strong>局限性 (基于代码分析):</strong></p>
<ul>
<li><p><strong>无嵌套反引号支持</strong>: 如果命令中存在嵌套的反引号（例如 echoecho &#96;date&#96;&#96;），当前的实现将无法正确处理，可能会导致错误或意外行为。</p>
</li>
<li><p><strong>无转义反引号支持</strong>: 如果用户想在反引号内包含字面上的反引号（例如 echoecho a&#96;b&#96;&#96;），当前的实现会认为第二个  是结束反引号的标志，导致错误。</p>
</li>
<li><p><strong>输出缓冲区限制</strong>: MAX_CMD_SUBST_OUTPUT_LEN 和 MAX_CMD_SUBST_BUFFERS 的限制意味着不能执行产生非常大输出或在同一行有太多命令替换的命令。</p>
</li>
<li><p><strong>换行符处理</strong>: 将内部换行符替换为 \0 是一个特定实现，它会将内部的多行输出合并成一个用 \0 分隔的“单词”，然后可能被 shell 进一步解析。不同的 shell 对此行为有细微差别。</p>
</li>
</ul>
<h3 id="指令条件执行"><a href="#指令条件执行" class="headerlink" title="指令条件执行"></a>指令条件执行</h3><p>你需要实现 Linux shell 中的 <code>&amp;&amp;</code> 与 <code>||</code>。 对于 <code>command1 &amp;&amp; command2</code>，<code>command2</code> 被执行当且仅当 <code>command1</code> 返回 0；对于 <code>command1 || command2</code>，<code>command2</code> 被执行当且仅当 <code>command1</code> 返回非 0 值。</p>
<p>条件指令与反引号指令执行同理，开子进程并将指令执行的结果通过管道通信，父进程再根据条件符号的类型和返回值来判断是否运行下一个指令。</p>
<h3 id="更多指令"><a href="#更多指令" class="headerlink" title="更多指令"></a>更多指令</h3><p>你需要实现 <code>touch</code>，<code>mkdir</code>，<code>rm</code> 指令以及内建指令<code>exit</code>，只需要考虑如下情形：</p>
<ul>
<li><code>touch</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>touch &lt;file&gt;</code>：创建空文件 <code>file</code>，若文件存在则放弃创建，正常退出无输出。 若创建文件的父目录不存在则输出 <code>touch: cannot touch &#39;&lt;file&gt;&#39;: No such file or directory</code>。 例如 <code>touch nonexistent/dir/a.txt</code> 时应输出 <code>touch: cannot touch &#39;nonexistent/dir/a.txt&#39;: No such file or directory</code>。</li>
</ul>
</blockquote>
<ul>
<li><code>mkdir</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>mkdir &lt;dir&gt;</code>：若目录已存在则输出 <code>mkdir: cannot create directory &#39;&lt;dir&gt;&#39;: File exists</code>，若创建目录的父目录不存在则输出 <code>mkdir: cannot create directory &#39;&lt;dir&gt;&#39;: No such file or directory</code>，否则正常创建目录。</li>
<li><code>mkdir -p &lt;dir&gt;</code>：当使用 <code>-p</code> 选项时忽略错误，若目录已存在则直接退出，若创建目录的父目录不存在则递归创建目录。</li>
</ul>
</blockquote>
<ul>
<li><code>rm</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>rm &lt;file&gt;</code>：若文件存在则删除 <code>&lt;file&gt;</code>，否则输出 <code>rm: cannot remove &#39;&lt;file&gt;&#39;: No such file or directory</code>。</li>
<li><code>rm &lt;dir&gt;</code>：命令行输出: <code>rm: cannot remove &#39;&lt;dir&gt;&#39;: Is a directory</code>。</li>
<li><code>rm -r &lt;dir&gt;|&lt;file&gt;</code>：若文件或文件夹存在则删除，否则输出 <code>rm: cannot remove &#39;&lt;dir&gt;|&lt;file&gt;&#39;: No such file or directory</code>。</li>
<li><code>rm -rf &lt;dir&gt;|&lt;file&gt;</code>：如果对应文件或文件夹存在则删除，否则直接退出。</li>
</ul>
</blockquote>
<ul>
<li>（内建指令）<code>exit</code>:执行后退出当前shell</li>
</ul>
<p>注:对于<code>rm</code>,<code>mkdir</code>,<code>touch</code>指令，若成功执行则返回0，否则返回非零值即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">touch</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open(path, O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;touch: cannot touch &#x27;%s&#x27;: No such file or directory\n&quot;</span>, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;other error when touch %s, error code is %d\n&quot;</span>, path, fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nothing to touch\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            touch(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; path[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            str[i] = path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; path[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                fd = open(str, O_MKDIR);</span><br><span class="line">                <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;other error when mkdir %s, error code is %d\n&quot;</span>, path, fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str[i] = path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        fd = open(str, O_MKDIR);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other error when mkdir %s, error code is %d\n&quot;</span>, path, fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mkdir: cannot create directory &#x27;%s&#x27;: File exists\n&quot;</span>, path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(path, O_MKDIR);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-10</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mkdir: cannot create directory &#x27;%s&#x27;: No such file or directory\n&quot;</span>, path);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other error when mkdir %s, error code is %d\n&quot;</span>, path, fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">5</span>] = <span class="string">&quot;-p&quot;</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;receive mkdir command:\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	<span class="type">char</span> *p = argv[i];</span><br><span class="line">	<span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			*p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    	<span class="comment">//printf(&quot;\&quot;%s\&quot;&quot;, argv[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], s) == <span class="number">0</span>) &#123;</span><br><span class="line">            argv[i] = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nothing to mkdir\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mkdir(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag_r;</span><br><span class="line"><span class="type">int</span> flag_f;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rm</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag_f) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove &#x27;%s&#x27;: No such file or directory\n&quot;</span>, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    stat(path, &amp;st);</span><br><span class="line">    <span class="keyword">if</span> (st.st_isdir &amp;&amp; !flag_r) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove &#x27;%s&#x27;: Is a directory\n&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> cwd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    syscall_get_cwd(cwd);</span><br><span class="line">    <span class="type">char</span> finalpath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    get_final_path(cwd, path, finalpath);</span><br><span class="line">    <span class="comment">//printf(&quot;rm finalpath: %s\n&quot;, finalpath);</span></span><br><span class="line">    remove(finalpath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_final_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cwd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *finalpath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cwd || !path || !finalpath) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Invalid arguments</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> constructed_path[MAXPATHLEN * <span class="number">2</span>]; <span class="comment">// Intermediate buffer for path construction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Determine if &#x27;path&#x27; is absolute or relative and construct initial full path</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// Absolute path</span></span><br><span class="line">        <span class="keyword">if</span> (mystrlen(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Error: Absolute path too long.\n&quot;); // Optional debug</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcpy(constructed_path, path);</span><br><span class="line">        <span class="comment">// As per your spec: &quot;绝对路径，此时将这个绝对路径复制到第三个参数finalpath即可，返回0&quot;</span></span><br><span class="line">        <span class="comment">// This means no stat check for absolute paths here.</span></span><br><span class="line">        <span class="comment">// Normalization is still good practice.</span></span><br><span class="line">	<span class="comment">//printf(&quot;rel is abs, raw finalpath: %s\n&quot;, constructed_path);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Relative path</span></span><br><span class="line">        <span class="comment">// Construct full path: cwd + &quot;/&quot; + path</span></span><br><span class="line">        <span class="keyword">if</span> (mystrlen(cwd) + <span class="number">1</span> + mystrlen(path) + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(constructed_path)) &#123; <span class="comment">// +1 for potential slash, +1 for null</span></span><br><span class="line">            <span class="comment">// printf(&quot;Error: Constructed relative path too long.\n&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcpy(constructed_path, cwd);</span><br><span class="line">        <span class="comment">// Add slash if cwd is not &quot;/&quot; and path is not empty</span></span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span> &amp;&amp; constructed_path[mystrlen(constructed_path) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            mystrcat(constructed_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span> &amp;&amp; mystrlen(constructed_path) &gt; <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="comment">// If cwd was &quot;/&quot; and something got appended making it &quot;//path&quot;, fix to &quot;/path&quot;</span></span><br><span class="line">            <span class="comment">// This case is usually handled by normalize_path later.</span></span><br><span class="line">            <span class="comment">// More simply, if cwd is &quot;/&quot;, just don&#x27;t add another slash if path is not empty.</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcat(constructed_path, path);</span><br><span class="line">	<span class="comment">//printf(&quot;rel is rel, raw finalpath: %s\n&quot;, constructed_path);</span></span><br><span class="line">        <span class="comment">// Normalize the constructed path (handles &quot;.&quot;, &quot;..&quot;, &quot;//&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (normalize_path(constructed_path) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Error: Failed to normalize constructed path &#x27;%s&#x27;\n&quot;, temp_path);</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For relative paths, after normalization, perform stat check</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Path exists and is a directory</span></span><br><span class="line">        mystrcpy(finalpath, constructed_path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Success</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normalize_path function (copied from previous response for completeness if not in a shared lib)</span></span><br><span class="line"><span class="comment">// Ensure MAXNAMELEN and MAXPATHLEN are defined (typically from fs.h)</span></span><br><span class="line"><span class="comment">// Ensure mystrcmp, mystrncpy, mymemcpy, mystrlen are available</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">normalize_path</span><span class="params">(<span class="type">char</span> *path_buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path_buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> components[<span class="number">128</span>][<span class="number">128</span>]; </span><br><span class="line">    <span class="type">int</span> comp_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = path_buf;</span><br><span class="line">    <span class="type">int</span> is_absolute = (*p == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Phase 1: Parse into components, handling &quot;.&quot; and &quot;..&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        p++; </span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="type">char</span> current_comp_val[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> *c_ptr = current_comp_val;</span><br><span class="line">        <span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c_ptr - current_comp_val &lt; <span class="number">128</span> - <span class="number">1</span>) *c_ptr++ = *p;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        *c_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &gt; <span class="number">0</span> &amp;&amp; mystrcmp(components[comp_idx - <span class="number">1</span>], <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                comp_idx--; <span class="comment">// Pop if last wasn&#x27;t &quot;..&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute) &#123; <span class="comment">// Relative path: push &quot;..&quot; or if stack top is &quot;..&quot; push another</span></span><br><span class="line">                <span class="keyword">if</span> (comp_idx &lt; <span class="number">128</span>) mystrncpy(components[comp_idx++], <span class="string">&quot;..&quot;</span>, <span class="number">128</span><span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH; <span class="comment">// Path too complex/long</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If absolute and comp_idx is 0 (or was &quot;..&quot;), &quot;..&quot; from root is ignored or handled by pop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; current_comp_val[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &lt; <span class="number">128</span>) mystrncpy(components[comp_idx++], current_comp_val, <span class="number">128</span><span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Phase 2: Reconstruct the path from components</span></span><br><span class="line">    <span class="type">char</span> *write_ptr = path_buf;</span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; comp_idx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123; <span class="comment">// Need a separator for components after the first</span></span><br><span class="line">            <span class="keyword">if</span> (write_ptr - path_buf &gt;= MAXPATHLEN - <span class="number">1</span>) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">            *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// First component of a relative path, no leading slash needed from here.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &amp;&amp; write_ptr == path_buf + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Absolute path, first component after root &#x27;/&#x27;, no extra slash if write_ptr is right after it.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = mystrlen(components[i]);</span><br><span class="line">        <span class="keyword">if</span> ((write_ptr - path_buf) + len &gt;= MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        <span class="built_in">memcpy</span>(write_ptr, components[i], len);</span><br><span class="line">        write_ptr += len;</span><br><span class="line">    &#125;</span><br><span class="line">    *write_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Final fixups for empty or root results</span></span><br><span class="line">    <span class="keyword">if</span> (path_buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_absolute) mystrcpy(path_buf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> mystrcpy(path_buf, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; path_buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path_buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; comp_idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This case means something like &quot;/foo/..&quot; resolved to &quot;/&quot;.</span></span><br><span class="line">        <span class="comment">// If comp_idx is &gt; 0, it means there *were* components that simplified away.</span></span><br><span class="line">        <span class="comment">// If comp_idx became 0 (e.g. /.. or /foo/..), path_buf should correctly be just &quot;/&quot;</span></span><br><span class="line">        <span class="comment">// No specific action needed here if reconstruction is correct.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; write_ptr == path_buf) &#123; </span><br><span class="line">        <span class="comment">// This can happen if input was &quot;/&quot; and comp_idx remained 0.</span></span><br><span class="line">        <span class="comment">// Ensure it&#x27;s at least &quot;/&quot;.</span></span><br><span class="line">        path_buf[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>; path_buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrncpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* start = dest; </span><br><span class="line">	<span class="keyword">while</span> (count &amp;&amp; (*dest++ = *src++)) </span><br><span class="line">	&#123;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--count)</span><br><span class="line">		&#123;</span><br><span class="line">			*dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; (<span class="type">size_t</span>)n &amp;&amp; s1[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; s2[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>)s1[i] - (<span class="type">unsigned</span> <span class="type">char</span>)s2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; (<span class="type">size_t</span>)n) &#123; </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>)s1[i] - (<span class="type">unsigned</span> <span class="type">char</span>)s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; (*str1 == *str2)) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)str1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* ptr = dest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到 dest 的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 src 的内容复制到 dest 的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *ptr = *src;</span><br><span class="line">        ptr++;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加字符串结束符</span></span><br><span class="line">    *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* original_dest = dest; <span class="comment">// 保存目标字符串的起始地址</span></span><br><span class="line">    <span class="keyword">while</span> ((*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>); <span class="comment">// 逐字符复制，直到遇到 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回目标字符串的起始地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[length] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span> s_r[<span class="number">5</span>] = <span class="string">&quot;-r&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s_rf[<span class="number">5</span>] = <span class="string">&quot;-rf&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], s_r) == <span class="number">0</span>) &#123;</span><br><span class="line">            argv[i] = <span class="number">0</span>;</span><br><span class="line">            flag_r = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], s_rf) == <span class="number">0</span>) &#123;</span><br><span class="line">            argv[i] = <span class="number">0</span>;</span><br><span class="line">            flag_f = <span class="number">1</span>;</span><br><span class="line">            flag_r = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nothing to rm\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rm(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要注意在rm中，传递的路径必须是绝对路径，因为后续remove调用ipc后的serve_remove中没有用到open，并且文件系统服务进程的工作路径与shell的工作路径不同，没法将相对路径转换成绝对路径，因此必须在rm内部就转换成绝对路径。</p>
<p>exit是内建指令，只需要调用exit()即可。</p>
<h3 id="追加重定向"><a href="#追加重定向" class="headerlink" title="追加重定向"></a>追加重定向</h3><p>你需要实现 shell 中 <code>&gt;&gt;</code> 追加重定向的功能，例如：</p>
<p><code>ls &gt;&gt; file1 ls &gt;&gt; file1</code></p>
<p>实现追加重定向首先需要新定义一种文件打开方式APPEND，在识别到redirect类型是APPEND时，就把文件打开方式设置为APPEND，之后在serve_open的时候，如果检测到文件打开方式是APPEND时，就把offset设置为size，这样之后再写入文件的时候就会从data+offset的位置开始写入，也就是在文件末尾追加内容。</p>
<p>至此，挑战性任务的所有内容都已经完成，我在此期间收获了很多，也对操作系统有了更加深入的了解！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Jiyuan Zhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/06/29/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-shell-%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1/">http://example.com/2025/06/29/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-shell-%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MOS/">MOS</a><a class="post-meta__tags" href="/tags/shell/">shell</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/29/%E5%8C%97%E8%88%AA-OO-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83/" title="北航 OO 面向对象 第三单元"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">北航 OO 面向对象 第三单元</div></div><div class="info-2"><div class="info-item-1"> 本单元重点学习了JML规格代码的书写、阅读，以及体验规格化设计实现。本单元学习的内容可谓是金刚钻，也许将来在工作的时候不一定会用到，但是掌握一项高专业化的能力不是一件坏事，况且一旦用到了那我们便能得心应手的应对，因此也是要好好对待JML的！  1. 测试过程1.1 单元测试单元测试指的是，对软件中的函数、方法或类进行正确性验证。通过验证程序的函数是否正确，能够尽早发现代码逻辑错误，隔离缺陷，方便代码重构。单元测试过程自动化程度高，执行速度快，定位问题准确，成本最低。在我的程序中，我使用JUnit来进行单元测试，测试函数行为。 1.2 **功能测试功能测试是指，基于软件需求规格说明书对软件功能进行验证。关注“软件做什么”，而不是“怎么做”。主要以黑盒测试为主，根据需求文档设计测试用例。在自动化测试的同时也包含大量手动测试，需要手搓一些极端样例来保证代码在极端情况下的健壮性。在我的程序中，我手搓了很多极端数据来保证函数功能的正确实现。 1.3 集成测试...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab0-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="北航操作系统-OS-lab0-实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">北航操作系统-OS-lab0-实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 &#x3D;&#x3D;不一样&#x3D;&#x3D;。在第一次 git add 之前文件 README.txt 属于未跟踪的文件，此时 git 是无法管理这个文件的，因此 git status 显示未跟踪的文件；而在 git add 并 git commit 之后，git 开始管理这个文件，此时再修改后其状态就会变成已修改未暂存的文件。&#x3D;&#x3D;其根本原因就是 git 是否管理了这个文件&#x3D;&#x3D;。如果 git 不管理这个文件，那么这个文件的状态一直都是 untracked ，一旦 git 管理了这个文件，那么经过修改后就会变成 changes not staged for commit ，git add 之后就都是 changes to be committed。  图中，add the file 对应指令 git add，stage the file 对应指令 git add，commit 对应 git commit。  当删除了 print.c 后，可以用 git restore print.c &#x2F; git...</div></div></div></a><a class="pagination-related" href="/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="北航操作系统-OS-lab1-实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">北航操作系统-OS-lab1-实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 首先利用如下简单C语言程序(hello.c)来研究x86工具链和mips工具链的区别    先利用x86工具链编译并反汇编目标文件代码，并观察 12gcc -c hello.c -o hello.oobjdump -DS hello.o &gt; text.txt  最终text.txt内容如下：  再利用mips工具链编译后反汇编： 12mips-linux-gnu-gcc -c hello.c -o hello.omips-linux-gnu-objdump -DS hello.o &gt; text.txt  最终输出如下：  之后再让x86的gcc把hello.c编译成可执行文件，之后再反汇编，代码如下： 12gcc hello.c -o helloobjdump -DS hello &gt; text.txt  结果如下：  可以看到call指令后面填充了 puts@plt，说明在链接的时候这块函数地址被填上了。 再用mips工具链重复以上步骤： 12mips-linux-gnu-gcc hello.c -o...</div></div></div></a><a class="pagination-related" href="/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="北航操作系统-OS-lab3-实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover1.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">北航操作系统-OS-lab3-实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 首先，MIPS中的虚拟内存结构如下： 因此，base_pgdir中建立了pages和envs的物理地址与虚存中pages和envs的虚拟地址之间的关系，这也同样解释了在map_segment中传入的UPAGES和UENVS的含义，就是pages和envs的虚存首地址。 之后，由于MOS的内核数据共享机制，需要把UTOP以上UVPT以下，即pages和envs的数据暴露给用户空间，因为base_pgdir中已经有分配好的映射关系，因此需要把UTOP到UVPT所对应的页目录项赋值给每个进程的页目录。又由于用户自身的4MB页表放置在UVPT，因此页目录自映射项相对于页目录的偏移即为PDX(UVPT)，因此需要把e-&gt;env_pgdir[PDX(UVPT)] &#x3D; PADDR(e-&gt;env_pgdir) |...</div></div></div></a><a class="pagination-related" href="/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="北航操作系统-OS-lab2-实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">北航操作系统-OS-lab2-实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，MIPS 汇编程序中 lw 和 sw 指令使用的地址也被视为虚拟地址。CPU访问的都是虚拟地址，通过MMU来转换成对应的物理地址，最后访问内存中的数据。  首先，用宏来处理链表可以化简链表的操作，通过将特定功能的代码封装在宏定义中，可以在实现特定功能时简化操作，增加代码可读性和可维护性。其次，当链表的操作需要修改时，由于该操作会被大量复用，如果逐一修改工作量太大，而用宏则可以只修改宏定义，方便更改。最后，很多种类的链表都包含相似的操作，只要这些链表结构相同，就都可以用这些宏定义来实现相似的操作，只是传入的参数不同，方便了众多链表的使用。 在实验环境中，有单向链表、双向链表、单向队列、双向队列、循环队列。  ...</div></div></div></a><a class="pagination-related" href="/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="北航操作系统-OS-lab4-实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">北航操作系统-OS-lab4-实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题  内核在保存现场的时候，通过 SAVE_ALL 宏操作，来将通用寄存器中的值保存在内核栈指针所指向的位置，在异常处理结束时恢复现场，从而防止通用寄存器的值被破坏改变。 可以从当时的 $a0 - $a3 寄存器中得到用户调用 msyscall 时传入的参数。因为在系统调用的时候，这几个寄存器的值不会被改变，因此可以直接获取。 方式就是让sys开头的函数通过正常获取参数的方式，能够获取正确的参数。而这样做的保证是，在用户调用syscall相关函数后，会进行传参，此时会在$a0 - $a3寄存器中保存值，并在用户栈中开辟栈帧，存入相关参数。之后调用msyscall函数，这个函数是个页函数，因此没有栈帧，不会改变栈指针的位置，这个函数直接调用了syscall，陷入了内核态，因此此时 $a0 - $a3...</div></div></div></a><a class="pagination-related" href="/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="北航操作系统-OS-lab5-实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">北航操作系统-OS-lab5-实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 使用kseg0去读写设备，会导致读取的数据可能不正确。因为kseg0段使用cache来访存，当CPU访问一个物理地址时，会先检查该地址所在块是否在cache中，如果在那么直接从cache中进行读或写，如果不在那么申请一块并从内存中读取该块的内容到cache中，并重新访问。这样做之所以可行是因为对cache中的块的数据进行操作等效于对内存直接操作。但是如果外设对内存的操作不会引起cache的变化，如果外设对内存中的数据进行了修改，那么cache中对应块没有随之修改，这就会导致cache中的块的数据和内存中块数据不一致，导致CPU访问的时候读取到了错误的数据。同理CPU的写入也会先写进cache，之后再回写到内存中，这样会导致外设有可能读不到CPU写入的数据。  一个磁盘块的大小是4KB，也就是4096字节；而一个文件控制块FCB的大小固定为256字节，因此一个磁盘块中最多能存储16个文件控制块。一个目录最多拥有1024个磁盘块，因此最多能有16384个文件。我们文件系统支持单个文件最多拥有1024个磁盘块，也就是4MB。 缓冲区的范围是 [DISKMAP,...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Jiyuan Zhao</div><div class="author-info-description">这里是keshi的博客网站，联系作者：zhaojiyuan0721</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lucky-sheltered-boy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lucky-sheltered-boy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:23371524@buaa.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99-sh-c-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">重写 sh.c 架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6-b-%E5%90%8E%E7%BC%80%E6%8C%87%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">不带 .b 后缀指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%A8%E9%87%8A%E5%8A%9F%E8%83%BD"><span class="toc-number">3.</span> <span class="toc-text">实现注释功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">4.</span> <span class="toc-text">支持相对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">环境变量管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%87%AA%E7%94%B1%E8%BE%93%E5%85%A5"><span class="toc-number">6.</span> <span class="toc-text">指令自由输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">7.</span> <span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E6%8C%87%E4%BB%A4"><span class="toc-number">8.</span> <span class="toc-text">历史指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%BC%95%E5%8F%B7"><span class="toc-number">9.</span> <span class="toc-text">实现反引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">10.</span> <span class="toc-text">指令条件执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%8C%87%E4%BB%A4"><span class="toc-number">11.</span> <span class="toc-text">更多指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">12.</span> <span class="toc-text">追加重定向</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="2025-北航编译技术设计文档"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-北航编译技术设计文档"/></a><div class="content"><a class="title" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="2025-北航编译技术设计文档">2025-北航编译技术设计文档</a><time datetime="2026-02-05T17:42:59.000Z" title="Created 2026-02-06 01:42:59">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/" title="2025-北航编译技术实验文法定义及相关说明"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-北航编译技术实验文法定义及相关说明"/></a><div class="content"><a class="title" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/" title="2025-北航编译技术实验文法定义及相关说明">2025-北航编译技术实验文法定义及相关说明</a><time datetime="2026-02-05T17:28:57.000Z" title="Created 2026-02-06 01:28:57">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/19/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E4%B8%AD%E6%9C%9F%E6%9C%AB%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/" title="2025 北航编译原理期中期末题目回顾"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover5.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025 北航编译原理期中期末题目回顾"/></a><div class="content"><a class="title" href="/2026/01/19/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E4%B8%AD%E6%9C%9F%E6%9C%AB%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/" title="2025 北航编译原理期中期末题目回顾">2025 北航编译原理期中期末题目回顾</a><time datetime="2026-01-19T07:21:54.000Z" title="Created 2026-01-19 15:21:54">2026-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/23/LLM-MoE-RL-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/" title="LLM MoE RL 学习报告"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LLM MoE RL 学习报告"/></a><div class="content"><a class="title" href="/2025/08/23/LLM-MoE-RL-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/" title="LLM MoE RL 学习报告">LLM MoE RL 学习报告</a><time datetime="2025-08-23T02:15:17.000Z" title="Created 2025-08-23 10:15:17">2025-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab6-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="北航操作系统-OS-lab6-实验报告"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="北航操作系统-OS-lab6-实验报告"/></a><div class="content"><a class="title" href="/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab6-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="北航操作系统-OS-lab6-实验报告">北航操作系统-OS-lab6-实验报告</a><time datetime="2025-07-01T06:35:01.000Z" title="Created 2025-07-01 14:35:01">2025-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By Jiyuan Zhao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>