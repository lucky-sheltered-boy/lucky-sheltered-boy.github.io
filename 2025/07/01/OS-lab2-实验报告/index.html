<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OS_lab2_实验报告 | lucky-sheltered-boy's Blog</title><meta name="author" content="Jiyuan Zhao"><meta name="copyright" content="Jiyuan Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 思考题 在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，MIPS 汇编程序中 lw 和 sw 指令使用的地址也被视为虚拟地址。CPU访问的都是虚拟地址，通过MMU来转换成对应的物理地址，最后访问内存中的数据。  首先，用宏来处理链表可以化简链表的操作，通过将特定功能的代码封装在宏定义中，可以在实现特定功能时简化操作，增加代码可读性和可维护性。其次，当链表的操作需要修改时，由于该操作">
<meta property="og:type" content="article">
<meta property="og:title" content="OS_lab2_实验报告">
<meta property="og:url" content="http://example.com/2025/07/01/OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html">
<meta property="og:site_name" content="lucky-sheltered-boy&#39;s Blog">
<meta property="og:description" content="1. 思考题 在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，MIPS 汇编程序中 lw 和 sw 指令使用的地址也被视为虚拟地址。CPU访问的都是虚拟地址，通过MMU来转换成对应的物理地址，最后访问内存中的数据。  首先，用宏来处理链表可以化简链表的操作，通过将特定功能的代码封装在宏定义中，可以在实现特定功能时简化操作，增加代码可读性和可维护性。其次，当链表的操作需要修改时，由于该操作">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG">
<meta property="article:published_time" content="2025-07-01T06:34:33.000Z">
<meta property="article:modified_time" content="2025-07-03T17:09:13.876Z">
<meta property="article:author" content="Jiyuan Zhao">
<meta property="article:tag" content="MOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OS_lab2_实验报告",
  "url": "http://example.com/2025/07/01/OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/",
  "image": "https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG",
  "datePublished": "2025-07-01T06:34:33.000Z",
  "dateModified": "2025-07-03T17:09:13.876Z",
  "author": [
    {
      "@type": "Person",
      "name": "Jiyuan Zhao",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/01/OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS_lab2_实验报告',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lucky-sheltered-boy's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">OS_lab2_实验报告</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">OS_lab2_实验报告</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-01T06:34:33.000Z" title="Created 2025-07-01 14:34:33">2025-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-03T17:09:13.876Z" title="Updated 2025-07-04 01:09:13">2025-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">2.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>7mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1. 思考题"></a>1. 思考题</h1><ol>
<li><p>在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，MIPS 汇编程序中 lw 和 sw 指令使用的地址也被视为虚拟地址。CPU访问的都是虚拟地址，通过MMU来转换成对应的物理地址，最后访问内存中的数据。</p>
</li>
<li><p>首先，用宏来处理链表可以化简链表的操作，通过将特定功能的代码封装在宏定义中，可以在实现特定功能时简化操作，增加代码可读性和可维护性。其次，当链表的操作需要修改时，由于该操作会被大量复用，如果逐一修改工作量太大，而用宏则可以只修改宏定义，方便更改。最后，很多种类的链表都包含相似的操作，只要这些链表结构相同，就都可以用这些宏定义来实现相似的操作，只是传入的参数不同，方便了众多链表的使用。</p>
<p>在实验环境中，有单向链表、双向链表、单向队列、双向队列、循环队列。   单向链表插入只需前者指向新者，新者指向后者即可。双向链表插入操作需要新的节点指向前后节点，前后节点再指向新的节点，需要额外判断是否next指向了NULL。循环链表与双向链表运行代码量基本相等，需额外判断是否next指向了头指针。特别的是，插入到头结点对三种链表而言性能相似，单向链表与双向链表插入到尾结点均要遍历完整个链表。 单向链表的删除操作复杂度为O(n)，因为需要靠循环才能找到上一个链表节点的位置，双向链表及循环链表的删除操作与插入性能相近，也还是需要额外判断NULL或HEAD。删除头结点对三种链表而言性能相似，而单向链表与双向链表删除尾结点还是要遍历。</p>
</li>
<li><p>结构如下：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> struct Page &#123;</span><br><span class="line">     Page_LIST_entry_t pp_link;   </span><br><span class="line">     u_short pp_ref;</span><br><span class="line"> &#125;;</span><br><span class="line"> ​</span><br><span class="line">struct Page_list &#123;</span><br><span class="line">	struct Page *lh_first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	struct Page *le_next;</span><br><span class="line">	struct Page **le_prev;</span><br><span class="line">&#125; Page_LIST_entry_t;</span><br></pre></td></tr></table></figure>

<p>答案选C。Page_list中含有的是Page结构体指针头。每一个Page内存控制块都有一个<code>pp_ref</code>用于表示其引用次数（为0时便可remove)，还有一个结构体用于存放实现双向链表的指针。</p>
<ol start="4">
<li><p>ASID的必要性： 同一虚拟地址在不同地址空间中通常映射到不同物理地址，ASID可以判断是在哪个地址空间。例如有多个进程都用到了这个虚拟地址，但若该虚拟地址对应的数据不是共享的，则基本可以表明指向的是不同物理地址，这也是一种对地址空间的保护。</p>
<p>可容纳不同地址空间的最大数量： 64个，参考原文如下： Instead, the OS assigns a 6-bit unique code to each task’s distinct address space. Since the ASID is only 6 bits long, OS software does have to lend a hand if there are ever more than <strong>64 address spaces</strong> in concurrent use; but it probably won’t happen too often.</p>
</li>
<li><p>tlb_invalidate 中 调用了 tlb_out。</p>
<p>tlb_invalidate 的作用是：找到tlb中对需要清除的虚拟地址对应的页表项，并将其全部清零。</p>
</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> LEAF(tlb_out)</span><br><span class="line"> <span class="keyword">nop</span></span><br><span class="line">     mtc0    a0,CP0_ENTRYHI  <span class="comment">//将传进来的参数放进ENTRYHI中</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     tlbp<span class="comment">// insert tlbp or tlbwi //检测ENTRYHI中的虚拟地址在tlb中是否有对应项，并保存下标</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     mfc0    k0,CP0_INDEX    <span class="comment">//INDEX可以用来判断是否命中</span></span><br><span class="line">     bltz    k0,NOFOUND  <span class="comment">//若未命中，则跳转</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     mtc0    zero,CP0_ENTRYHI    <span class="comment">//将ENTRYHI清零</span></span><br><span class="line">     mtc0    zero,CP0_ENTRYLO0   <span class="comment">//将ENTRYLO清零</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     tlbwi<span class="comment">// insert tlbp or tlbwi    //将清零后的两寄存器值写入到对应tlb表项中</span></span><br><span class="line">                                     <span class="comment">//相当于删除原有的tlb表项</span></span><br><span class="line"> NOFOUND:</span><br><span class="line">     </span><br><span class="line">     j   ra  <span class="comment">//return address</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line"> <span class="meta">END</span>(tlb_out)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p><img src="/pictures/1744383493288.png"></p>
<p>CPU一开始先探测可用的物理内存，数据由QEMU给出，之后根据页面大小计算出物理页框数量。然后根据对应数量alloc出来相同数量的页控制块，之后将已经被kseg0中代码占据的页控制块标记，将剩余的页控制块加入空闲页面队列。由于kseg0段的访存不需要用到tlb和页表，因此MMU仅通过映射的方式即可得到物理地址，然后将CPU初始化的代码存入物理内存中。之后空间页表队列建立好了，用户发出访存请求后，CPU就先访问tlb，如果找到物理地址则直接访问。若没有找到则进行缺页中断，进行tlb重填，其中就会用到我们写的函数和空间队列。</p>
</li>
<li><p>X86用到三个地址空间的概念：物理地址、线性地址和逻辑地址。而MIPS只有物理地址和虚拟地址两个概念。相对而言，段机制对大量应用程序分散地使用大内存的支持能力较弱。所以Intel公司又加入了页机制，每个页的大小是固定的（一般为4KB），也可完成对内存单元的安全保护，隔离，且可有效支持大量应用程序分散地使用大内存的情况。<br>x86体系中，TLB表项更新能够由硬件自己主动发起，也能够有软件主动更新。分段机制和分页机制都启动：逻辑地址—&gt;<strong>段机制处理</strong>—&gt;线性地址—&gt;<strong>页机制处理</strong>—&gt;物理地址。RISC-V提供三种权限模式（MSU），而MIPS只提供内核态和用户态两种权限状态。<br>RISC-V SV39支持39位虚拟内存空间，每一页占用4KB，使用三级页表访存。</p>
</li>
<li><p>页表基地址(page table) 为PTbase。<br>页中间目录基地址(page middle directory) PMDbase：<br>(PTbase &lt;&lt; 12) &gt;&gt; 3 + PTbase<br>页全局目录(page global directory) PGDbase：<br>(PTbase &lt;&lt; 21) &gt;&gt; 3 + PMDbase（三级页表页目录的基地址）<br>页全局目录项（page global directory entry）PGDE：<br>(PTbase &lt;&lt; 30) &gt;&gt; 3 + PGDbase（映射到页目录自身的页目录项）</p>
</li>
</ol>
<h1 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2. 难点分析"></a>2. 难点分析</h1><ol>
<li><p>理解CPU访问的都是虚拟地址，而虚拟地址到底是哪个实际的物理地址，这个是由MMU来决定的。在MIPS框架中，有四块内存区域，分别是kseg0，kseg1，kseg2，kuseg。其中前两个通过高位置零的操作就可以映射到物理地址中，不需要借助tlb，因此想要访问某一个具体的物理地址，可以直接通过kseg0段的虚拟地址来访问。</p>
</li>
<li><p>kseg0段一开始存储了操作系统内核的代码，以及页控制块等，这些代码已经存储到了对应的物理内存中，剩余可用的物理内存组成空闲页控制块，用来分配给kuseg。</p>
</li>
<li><p>链表的宏定义。链表的结构是，有一个指针结构体和一个被引用次数。其中指针结构体有指向下一个链表节点的指针，和指向前一个链表中指向下一个节点指针的指针。通过这样的设计，可以很轻易地修改链表，方便插入和删除操作。</p>
</li>
<li><p>页表分析。页表定义了很多的函数。page_walk函数的作用是，在二级页表结构中查找返回虚拟地址的页表项指针。如果二级页表缺页，会尝试创建一个。page_lookup函数既可以返回在二级页表结构中查找返回虚拟地址的页表项指针，同时也可以返回物理地址所对应的页控制块。page_insert函数可以建立虚拟地址和页控制块的联系。page_remove可以清除虚拟地址和页控制块的关联。page_decref可以减少页控制块被引用次数，如果减少到0则调用page_free将该页框加入空闲页表队列。</p>
</li>
<li><p>宏定义分析。<img src="/pictures/228e2c1dfec2c8a87a3bcbbc1bad41a.png"></p>
</li>
<li><p>tlb_invalidate的作用是删除虚拟地址和物理地址在tlb中的对应关系，其中调用了tlb_out。如果CPU访问失败，则会触发缺页中断，调用do_tlb_refill函数，该函数会先为虚拟地址分配一个物理页框，然后填写到tlb中。</p>
</li>
</ol>
<h1 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3. 实验体会"></a>3. 实验体会</h1><p>链表的宏定义需要熟练掌握应用，今后还有很多能用到的机会。同时自己实现的宏定义也要好好检查，否则课下的问题有可能会引发课上的错误。<br>虚拟地址和物理地址和页控制块的转换宏定义也需要熟练掌握，熟练掌握这些宏定义可以让我们快速完成想要的操作，更加方便简洁。<br>要好好理解多级页表的访存机制，十分清楚，这样才能在底层去操作。</p>
<h1 id="4-原创声明"><a href="#4-原创声明" class="headerlink" title="4. 原创声明"></a>4. 原创声明</h1><p>本实验报告大部分原创，少部分参考了<a target="_blank" rel="noopener" href="https://www.cnblogs.com/emodiary121/p/16142108.html">北航操作系统课程lab2实验报告 - 南风北辰 - 博客园 (cnblogs.com)</a>该博客。全部内容都带有自己的思考。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Jiyuan Zhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/01/OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">http://example.com/2025/07/01/OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MOS/">MOS</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/01/OS-lab1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab1_实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">OS_lab1_实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 首先利用如下简单C语言程序(hello.c)来研究x86工具链和mips工具链的区别    先利用x86工具链编译并反汇编目标文件代码，并观察 12gcc -c hello.c -o hello.oobjdump -DS hello.o &gt; text.txt  最终text.txt内容如下：  再利用mips工具链编译后反汇编： 12mips-linux-gnu-gcc -c hello.c -o hello.omips-linux-gnu-objdump -DS hello.o &gt; text.txt  最终输出如下：  之后再让x86的gcc把hello.c编译成可执行文件，之后再反汇编，代码如下： 12gcc hello.c -o helloobjdump -DS hello &gt; text.txt  结果如下：  可以看到call指令后面填充了 puts@plt，说明在链接的时候这块函数地址被填上了。 再用mips工具链重复以上步骤： 12mips-linux-gnu-gcc hello.c -o...</div></div></div></a><a class="pagination-related" href="/2025/07/01/OS-lab3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab3_实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover5.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">OS_lab3_实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 首先，MIPS中的虚拟内存结构如下： 因此，base_pgdir中建立了pages和envs的物理地址与虚存中pages和envs的虚拟地址之间的关系，这也同样解释了在map_segment中传入的UPAGES和UENVS的含义，就是pages和envs的虚存首地址。 之后，由于MOS的内核数据共享机制，需要把UTOP以上UVPT以下，即pages和envs的数据暴露给用户空间，因为base_pgdir中已经有分配好的映射关系，因此需要把UTOP到UVPT所对应的页目录项赋值给每个进程的页目录。又由于用户自身的4MB页表放置在UVPT，因此页目录自映射项相对于页目录的偏移即为PDX(UVPT)，因此需要把e-&gt;env_pgdir[PDX(UVPT)] &#x3D; PADDR(e-&gt;env_pgdir) |...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/01/OS-lab0-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab0_实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover1.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">OS_lab0_实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 &#x3D;&#x3D;不一样&#x3D;&#x3D;。在第一次 git add 之前文件 README.txt 属于未跟踪的文件，此时 git 是无法管理这个文件的，因此 git status 显示未跟踪的文件；而在 git add 并 git commit 之后，git 开始管理这个文件，此时再修改后其状态就会变成已修改未暂存的文件。&#x3D;&#x3D;其根本原因就是 git 是否管理了这个文件&#x3D;&#x3D;。如果 git 不管理这个文件，那么这个文件的状态一直都是 untracked ，一旦 git 管理了这个文件，那么经过修改后就会变成 changes not staged for commit ，git add 之后就都是 changes to be committed。  图中，add the file 对应指令 git add，stage the file 对应指令 git add，commit 对应 git commit。  当删除了 print.c 后，可以用 git restore print.c &#x2F; git...</div></div></div></a><a class="pagination-related" href="/2025/07/01/OS-lab1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab1_实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">OS_lab1_实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 首先利用如下简单C语言程序(hello.c)来研究x86工具链和mips工具链的区别    先利用x86工具链编译并反汇编目标文件代码，并观察 12gcc -c hello.c -o hello.oobjdump -DS hello.o &gt; text.txt  最终text.txt内容如下：  再利用mips工具链编译后反汇编： 12mips-linux-gnu-gcc -c hello.c -o hello.omips-linux-gnu-objdump -DS hello.o &gt; text.txt  最终输出如下：  之后再让x86的gcc把hello.c编译成可执行文件，之后再反汇编，代码如下： 12gcc hello.c -o helloobjdump -DS hello &gt; text.txt  结果如下：  可以看到call指令后面填充了 puts@plt，说明在链接的时候这块函数地址被填上了。 再用mips工具链重复以上步骤： 12mips-linux-gnu-gcc hello.c -o...</div></div></div></a><a class="pagination-related" href="/2025/07/01/OS-lab3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab3_实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover5.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">OS_lab3_实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 首先，MIPS中的虚拟内存结构如下： 因此，base_pgdir中建立了pages和envs的物理地址与虚存中pages和envs的虚拟地址之间的关系，这也同样解释了在map_segment中传入的UPAGES和UENVS的含义，就是pages和envs的虚存首地址。 之后，由于MOS的内核数据共享机制，需要把UTOP以上UVPT以下，即pages和envs的数据暴露给用户空间，因为base_pgdir中已经有分配好的映射关系，因此需要把UTOP到UVPT所对应的页目录项赋值给每个进程的页目录。又由于用户自身的4MB页表放置在UVPT，因此页目录自映射项相对于页目录的偏移即为PDX(UVPT)，因此需要把e-&gt;env_pgdir[PDX(UVPT)] &#x3D; PADDR(e-&gt;env_pgdir) |...</div></div></div></a><a class="pagination-related" href="/2025/07/01/OS-lab4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab4_实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover4.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">OS_lab4_实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题  内核在保存现场的时候，通过 SAVE_ALL 宏操作，来将通用寄存器中的值保存在内核栈指针所指向的位置，在异常处理结束时恢复现场，从而防止通用寄存器的值被破坏改变。 可以从当时的 $a0 - $a3 寄存器中得到用户调用 msyscall 时传入的参数。因为在系统调用的时候，这几个寄存器的值不会被改变，因此可以直接获取。 方式就是让sys开头的函数通过正常获取参数的方式，能够获取正确的参数。而这样做的保证是，在用户调用syscall相关函数后，会进行传参，此时会在$a0 - $a3寄存器中保存值，并在用户栈中开辟栈帧，存入相关参数。之后调用msyscall函数，这个函数是个页函数，因此没有栈帧，不会改变栈指针的位置，这个函数直接调用了syscall，陷入了内核态，因此此时 $a0 - $a3...</div></div></div></a><a class="pagination-related" href="/2025/07/01/OS-lab5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab5_实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">OS_lab5_实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题 使用kseg0去读写设备，会导致读取的数据可能不正确。因为kseg0段使用cache来访存，当CPU访问一个物理地址时，会先检查该地址所在块是否在cache中，如果在那么直接从cache中进行读或写，如果不在那么申请一块并从内存中读取该块的内容到cache中，并重新访问。这样做之所以可行是因为对cache中的块的数据进行操作等效于对内存直接操作。但是如果外设对内存的操作不会引起cache的变化，如果外设对内存中的数据进行了修改，那么cache中对应块没有随之修改，这就会导致cache中的块的数据和内存中块数据不一致，导致CPU访问的时候读取到了错误的数据。同理CPU的写入也会先写进cache，之后再回写到内存中，这样会导致外设有可能读不到CPU写入的数据。  一个磁盘块的大小是4KB，也就是4096字节；而一个文件控制块FCB的大小固定为256字节，因此一个磁盘块中最多能存储16个文件控制块。一个目录最多拥有1024个磁盘块，因此最多能有16384个文件。我们文件系统支持单个文件最多拥有1024个磁盘块，也就是4MB。 缓冲区的范围是 [DISKMAP,...</div></div></div></a><a class="pagination-related" href="/2025/07/01/OS-lab6-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab6_实验报告"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">OS_lab6_实验报告</div></div><div class="info-2"><div class="info-item-1">1. 思考题想让父进程作为读者，只需要反过来操作就可以了。先关闭写，再进行读操作，最后关闭读并退出即可。代码如下： 123456default:	close(fildes[1]);	read(fildes[0], buf, 100);	printf(&quot;father-process read:%s&quot;, buf);	close(fildes[0]);	exit(EXIT_SUCCESS); dup...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Jiyuan Zhao</div><div class="author-info-description">这里是keshi的博客网站，联系作者：zhaojiyuan0721</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lucky-sheltered-boy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lucky-sheltered-boy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:23371524@buaa.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">1. 思考题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%9A%BE%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">2. 难点分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%9E%E9%AA%8C%E4%BD%93%E4%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">3. 实验体会</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%8E%9F%E5%88%9B%E5%A3%B0%E6%98%8E"><span class="toc-number">4.</span> <span class="toc-text">4. 原创声明</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/OS-lab6-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab6_实验报告"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS_lab6_实验报告"/></a><div class="content"><a class="title" href="/2025/07/01/OS-lab6-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab6_实验报告">OS_lab6_实验报告</a><time datetime="2025-07-01T06:35:01.000Z" title="Created 2025-07-01 14:35:01">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/OS-lab5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab5_实验报告"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS_lab5_实验报告"/></a><div class="content"><a class="title" href="/2025/07/01/OS-lab5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab5_实验报告">OS_lab5_实验报告</a><time datetime="2025-07-01T06:34:53.000Z" title="Created 2025-07-01 14:34:53">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/OS-lab4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab4_实验报告"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS_lab4_实验报告"/></a><div class="content"><a class="title" href="/2025/07/01/OS-lab4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab4_实验报告">OS_lab4_实验报告</a><time datetime="2025-07-01T06:34:46.000Z" title="Created 2025-07-01 14:34:46">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/OS-lab3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab3_实验报告"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover5.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS_lab3_实验报告"/></a><div class="content"><a class="title" href="/2025/07/01/OS-lab3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab3_实验报告">OS_lab3_实验报告</a><time datetime="2025-07-01T06:34:40.000Z" title="Created 2025-07-01 14:34:40">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab2_实验报告"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover6.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS_lab2_实验报告"/></a><div class="content"><a class="title" href="/2025/07/01/OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OS_lab2_实验报告">OS_lab2_实验报告</a><time datetime="2025-07-01T06:34:33.000Z" title="Created 2025-07-01 14:34:33">2025-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Jiyuan Zhao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>