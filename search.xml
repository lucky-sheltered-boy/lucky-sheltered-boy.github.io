<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2025 北航编译原理期中期末题目回顾</title>
    <url>/2026/01/19/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E4%B8%AD%E6%9C%9F%E6%9C%AB%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<blockquote>
<p>本文章主要记录了2025秋季学期北航编译原理课程实验上机期中期末的回忆题目~</p>
<p>题目均由本人回忆记录，可能与原题稍有偏差，但大体思路一致</p>
</blockquote>
<h2 id="期中题目"><a href="#期中题目" class="headerlink" title="期中题目"></a>期中题目</h2><h4 id="1-新增-elif-文法："><a href="#1-新增-elif-文法：" class="headerlink" title="1. 新增 elif 文法："></a>1. <strong>新增 elif 文法</strong>：</h4><p><strong>具体新增文法如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stmt -&gt; &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27;Stmt </span><br><span class="line">		&#123; &#x27;elif&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt &#125; 1.有elif 2.无elif 3.有多个elif</span><br><span class="line">		[ &#x27;else&#x27; Stmt ] // 1.有else 2.无else</span><br></pre></td></tr></table></figure>

<p><strong>解题思路：</strong></p>
<ol>
<li>词法分析阶段识别 elif 为一个保留关键字，建立 ELIFTK。</li>
<li>语法分析阶段，对于 IfStmt 语法结构，新增一个 list 用来装 elif，里面每一个单元涵盖 Cond 和 Stmt。在 toString 的时候，先对 if 语句进行 toString，然后看有没有 elif，如果有的话就仿照 if 的 toString 操作去写就可以。最后对 else 进行处理。</li>
</ol>
<h4 id="2-新增-functionDef-文法："><a href="#2-新增-functionDef-文法：" class="headerlink" title="2. 新增 functionDef 文法："></a>2. <strong>新增 functionDef 文法</strong>：</h4><p><strong>具体新增文法如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FuncDef → FuncType Ident &#x27;(&#x27; [FuncFParams] &#x27;)&#x27; Block </span><br><span class="line">		| FuncType Ident &#x27;(&#x27; [FuncFParams] &#x27;)&#x27; ; // 新增</span><br></pre></td></tr></table></figure>

<p><strong>解题思路：</strong></p>
<ol>
<li><p>词法分析不用改</p>
</li>
<li><p>语法分析阶段，首先新增一个新的语法节点，然后将 FuncDef 设置为接口，原来的 FuncDef 和新增的都实现这个接口。两个 FuncDef 的不同之处就是一个是 Block 一个是 ；</p>
<p>在识别有没有 FuncFParams 的时候，在看后面 Token 是不是 <code>&#123;</code> 的时候，还要看是不是 <code>;</code>，如果是的话说明没有 FuncFParams 并且缺少右小括号。然后在检查完右小括号后，根据下一个 Token 是 <code>&#123;</code> 还是 <code>;</code> 决定返回的语法节点类型。</p>
</li>
</ol>
<h2 id="期末题目"><a href="#期末题目" class="headerlink" title="期末题目"></a>期末题目</h2><h4 id="1-新增-cin-文法："><a href="#1-新增-cin-文法：" class="headerlink" title="1. 新增 cin 文法："></a>1. <strong>新增 cin 文法</strong>：</h4><p><strong>具体新增文法规则如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语句 Stmt → &#x27;cin&#x27; &#x27;&gt;&gt;&#x27; LVal; // 新增 cin 文法，错误类型为i，h</span><br></pre></td></tr></table></figure>

<p>其功能等价于：<code>LVal = getint()</code> ，即读入一个 int 类型的数，然后存储在 LVal 中。</p>
<p>错误类型为 i：缺少分号，h：LVal 为 const 不可赋值。</p>
<p><strong>解题思路</strong>：</p>
<ol>
<li>在词法分析阶段解析 cin 为 CINTK，解析 &gt;&gt; 为 SHR。</li>
<li>在语法分析阶段，为 cin 文法新增 AST 节点类型 CinStmt，其内部只需存储一个 LVal 即可。在 parseStmt 的时候，如果当前 token 是 CINTK，则调用 parseCinStmt 方法。parseCinStmt 方法：先跳过 cin 和 &gt;&gt; ，然后调用 parseLVal 返回 LVal 用于构建 CinStmt。最后检查有没有分号，没有报 i 错误。</li>
<li>在语义分析阶段，在 checkStmt 中，如果是 CinStmt 则调用 checkCinStmt。该方法内部先 getLVal 拿到左值，然后去符号表里拿到 varSymbol，如果 varSymbol.isConst 是真，则报 h 错误。然后再调用 checkLVal 方法去检查 LVal（若 LVal 未定义则在 checkLVal 中报错，不在 checkCinStmt 里报错）。</li>
<li>在中间代码生成阶段，如果是 CinStmt，则调用 buildCinStmt 方法。该方法首先 new CallInst 去调用 getint 库函数，然后得到其 Value，然后 getLVal 得到 LVal，用 getLValPtr 得到 LVal 的指针，最后 new StoreInst 将 getint Value 存储到 LVal 指针处即可。</li>
<li>后端代码生成不用改。</li>
</ol>
<h4 id="2-新增-文法："><a href="#2-新增-文法：" class="headerlink" title="2. 新增 -&gt; 文法："></a>2. <strong>新增 -&gt; 文法</strong>：</h4><p><strong>具体新增文法规则如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">乘除模表达式 MulExp → UnaryExp | MulExp (&#x27;*&#x27; | &#x27;/&#x27; | &#x27;%&#x27; | &#x27;-&gt;&#x27;) UnaryExp // 新增 &#x27;-&gt;&#x27; 运算</span><br><span class="line">&#x27;-&gt;&#x27; 运算解释：</span><br><span class="line">a -&gt; b = a + (a + 1) + (a + 2) + ....... + b</span><br><span class="line">保证 a &lt;= b</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<ol>
<li>在词法分析阶段解析 -&gt; 为 LEFTTORIGHTTK。</li>
<li>在语法分析阶段，在解析 MulExp 的时候，如果遇到 (‘*’ | ‘&#x2F;‘ | ‘%’ | ‘-&gt;’) 运算符，就添加语法成分，最后正常返回 MulExp 语法节点。这里只要添加一个 else if 特判是不是 LEFTTOTIGHTTK 就可以。</li>
<li>在语义分析阶段，不用改。</li>
<li>在中间代码生成阶段，如果是 LEFTTORIGHTTK，则调用 buildLRTK 方法。该方法有两种实现方式：<ul>
<li>第一种比较简单，利用等差数列求和公式，只需要计算出 ((a + b) * (b - a + 1)) &#x2F; 2 即可。计算方法就根据计算顺序生成对应的计算语句，然后返回最后的计算结果 Token 即可。</li>
<li>第二种方法是利用循环来计算。可以写一个 for 循环，循环开始为 a，终止为 b，循环体内的语句就是累加当前值，最后返回累加值即可。方法为创建三个 BasicBlock，第一个为条件块，第二个为语句块，第三个为结束块。首先创建临时变量 i，并赋初值为 a，然后跳转到条件块，生成条件为 i &lt;&#x3D; b，若满足条件则跳转到语句块，不满足则跳转到结束块。然后跳转到语句块，累加 i 的值，然后无条件跳转到条件块。最后将当前块移至结束块即可。</li>
</ul>
</li>
<li>后端代码生成不用改。</li>
</ol>
<h4 id="3-代码优化"><a href="#3-代码优化" class="headerlink" title="3. 代码优化"></a>3. 代码优化</h4><p>直接提交课下代码优化的版本进行评测，有两个测试点。按照测试点的 cycle 数进行排名给分。</p>
<p>一般来说课下的代码优化能过，那么课上这两个点就能过。</p>
<p>然后还需要提交代码优化前后中间代码和目标代码的 txt 版本，别忘了交</p>
<h4 id="4-问答题"><a href="#4-问答题" class="headerlink" title="4. 问答题"></a>4. 问答题</h4><p>针对给出的示例代码提出很多问题，要结合代码进行文字解释。重点都是 mips 代码生成的问题。</p>
<p>有印象的问题是：</p>
<ul>
<li>在 mips 函数传参的时候，前四个参数要通过 $a0 - $a3 传递，第五个参数是如何传递的？</li>
<li>还考了一个跟函数有关的，具体忘了</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同学们好好复习，期中比较简单，期末要上点小强度。</p>
<p>一般来说，期末只需要改 llvm 中端就行了，如果 llvm 不新增指令，那么 mips 完全不用改。为了预防 llvm 有新增指令，需要提前准备一些方案，我能想到的 llvm 新增指令就是新增一些运算指令类型，比如新增异或、与运算、或运算之类的。这些就仿照加减法正常做就可以。</p>
<p>可以打印纸质资料带进去，建议先把预测到的问题问一下 AI ，让 AI 生成详细的更改指导，最后打印出来带进考场看。</p>
<p>有问题可加微信：zhaojiyuan0721</p>
]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-北航编译技术设计文档</title>
    <url>/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>2025年9月10日完稿</p>
</blockquote>
<p>在上编译课之前，我就早有耳闻编译的大名。有很多学长对编译课赞不绝口，称赞其为绝世好课；也有很多学长是苦不堪言，认为其是噩梦。这种两极分化的评价让我对编译这门课充满了敬畏，也多了一丝好奇，到底是怎样的课设才能收获如此丰富的评价呢？希望经过本学期的学习后，我能形成自己的评价，收获自我的感悟。</p>
<p>最后写下我对于编译课的希望吧，在之前学习CO的时候，经常听助教说要多思考少debug，希望在写编译器的时候也可以这样，先思考架构，之后再动手实现，尽量不debug，愉快又轻松。</p>
<h2 id="参考编译器介绍"><a href="#参考编译器介绍" class="headerlink" title="参考编译器介绍"></a>参考编译器介绍</h2><blockquote>
<p>2025年9月27日完稿</p>
</blockquote>
<p>在搜集参考资料时，我找了很多。主要还是广泛阅读了编译课提供的模版代码以及学长博客中流传的经典代码。具体来源如下：</p>
<ol>
<li>LLVM官方文档：<a href="https://llvm.org/docs/">https://llvm.org/docs/</a></li>
<li>LLVM框架参考：<a href="https://github.com/Hyggge/Petrichor">https://github.com/Hyggge/Petrichor</a></li>
<li>编译课示例代码：<a href="https://github.com/zhhangBian/Compiler-Techniques">https://github.com/zhhangBian/Compiler-Techniques</a></li>
<li>学长代码：<ul>
<li><a href="https://github.com/Galaxy-JewXW/buaa-compiler-2024">https://github.com/Galaxy-JewXW/buaa-compiler-2024</a></li>
<li><a href="https://github.com/zhangyitonggg/BUAA-2024-compiler">https://github.com/zhangyitonggg/BUAA-2024-compiler</a></li>
</ul>
</li>
<li>SysY 的语言说明和2025文法说明</li>
</ol>
<p>在我阅读的大部分编译器中，总体结构的设计都是相似的，大体可以分为前端、中端、后端、utils等。前端主要负责词法分析、语法分析、语义分析。中端做中间代码生成和代码优化。后端再把 IR 映射到 MIPS。utils是一些工具类，比如输出到文件，或者添加错误类型等等。</p>
<p>接口设计上，重点是每个编译阶段之间的衔接。好的接口设计都是流水线一样工作的，上一个阶段的结果作为下一个阶段的输入，这样的好处是功能隔离、高内聚低耦合。比如词法分析最后的结果会返回 Token 流，该 Token 流就是语法分析的输入。因此只需要预先设计每个阶段的输入输出是什么，就可以设计出对应的接口。</p>
<p>文件组织上，大部分编译器都是按阶段分包，原因很简单，调试时打开目录就知道这段代码属于哪一段，不会在一个包里乱成一团。一个典型的文件组织结构如下所示：</p>
<ul>
<li><strong>frontend</strong>：词法、语法、语义、符号表</li>
<li><strong>middle</strong>：IR 构建与 IR 数据结构</li>
<li><strong>optimize</strong>：中端优化 Pass</li>
<li><strong>backend</strong>：MIPS 生成与后端小优化</li>
<li><strong>utils</strong>：错误收集与输出</li>
</ul>
<h2 id="编译器总体设计"><a href="#编译器总体设计" class="headerlink" title="编译器总体设计"></a>编译器总体设计</h2><blockquote>
<p>2025年9月28日初稿，2026年1月2日完稿</p>
</blockquote>
<p>在看了许多优秀的编译器架构设计后，我打算参考学长们成熟的架构来设计我自己的编译器。</p>
<h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>在整体的构建中，我将编译器分为了前中后三段，并设计了错误处理端。在编译器的运行中，在每一端各司其职，仅能通过顶层的端级进行交互，达到了高内聚低耦合的效果。</p>
<p>同时，在编译器的书写中，我还尽量运用了多种面向对象设计思想，融入了多种复杂设计模式，使得编译器的整体书写较为优雅，具有良好的阅读效果。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>在我的编译器中，把前中后三端设计为了静态类，提供了静态交互方法，不暴露内部的接口。每个阶段都分别用单例模式进行管理，这样方便其他阶段调用该类，同时也只保留一个功能实例，方便功能拆分和统一。</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">操作</th>
<th align="left">输入</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">读入文件</td>
<td align="left">testfile.txt</td>
<td align="left">字符流</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Lexer.lex()</td>
<td align="left">字符流</td>
<td align="left">TokenStream</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Parser.parse()</td>
<td align="left">TokenStream</td>
<td align="left">AST</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Visitor.check()</td>
<td align="left">AST</td>
<td align="left">SymbolTable</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">ErrorLog检查</td>
<td align="left">ErrorLog</td>
<td align="left">error.txt</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">IRBuilder.build()</td>
<td align="left">AST + SymbolTable</td>
<td align="left">Module</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">Optimizer.optimize()</td>
<td align="left">Module</td>
<td align="left">Module</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">MipsBuilder.build()</td>
<td align="left">Module</td>
<td align="left">MipsFile</td>
</tr>
</tbody></table>
<h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>编译器的整体代码结构为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">├─Compiler.java</span><br><span class="line">├─backend</span><br><span class="line">│ └─...</span><br><span class="line">├─frontend</span><br><span class="line">│ ├─lexer</span><br><span class="line">│ │ └─...</span><br><span class="line">│ ├─parser</span><br><span class="line">│ │ └─...</span><br><span class="line">│ └─Visitor</span><br><span class="line">│   └─...</span><br><span class="line">├─middle</span><br><span class="line">│ ├─IRBuilder.java</span><br><span class="line">│ ├─IRData.java</span><br><span class="line">│ └─component</span><br><span class="line">│   └─...</span><br><span class="line">├─optimize</span><br><span class="line">│ └─...</span><br><span class="line">└─utils</span><br><span class="line">  ├─Config.java</span><br><span class="line">  ├─Error.java</span><br><span class="line">  ├─ErrorLog.java</span><br><span class="line">  └─Printer.java</span><br></pre></td></tr></table></figure>

<p>三端式结构分明，方便代码管理和debug。每个阶段内部采取单例模式，围绕一个主类添加其他功能类，完成词法分析、语法分析、语义分析等阶段的操作。还设置 utils 类方便错误管理和输入输出等。</p>
<h2 id="词法分析设计"><a href="#词法分析设计" class="headerlink" title="词法分析设计"></a>词法分析设计</h2><blockquote>
<p>2025年9月28日完稿</p>
</blockquote>
<h3 id="编码前设计"><a href="#编码前设计" class="headerlink" title="编码前设计"></a>编码前设计</h3><h4 id="文件组织-1"><a href="#文件组织-1" class="headerlink" title="文件组织"></a>文件组织</h4><p>词法分析这块基本是经典四件套：</p>
<ul>
<li><strong>Lexer</strong>：扫描字符流并产出 token</li>
<li><strong>Token</strong>：类型 + 字面值 + 行号</li>
<li><strong>TokenStream</strong>：token 列表 + 指针，支持 next&#x2F;peek&#x2F;last&#x2F;setCurPos</li>
<li><strong>TokenType</strong>：所有终结符&#x2F;关键字枚举</li>
</ul>
<p>文件结构如图所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lexer</span><br><span class="line"> Ⓒ Lexer</span><br><span class="line"> Ⓒ Token</span><br><span class="line"> Ⓒ TokenStream</span><br><span class="line"> Ⓔ TokenType</span><br></pre></td></tr></table></figure>

<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>首先 compiler 是编译器的入口，先读入 testfile.txt 文件，然后传入 Lexer 进行词法分析。Lexer 是单例模式，因此调用 <code>Lexer.getInstance()</code> 可以获取到唯一的 Lexer 单例，再调用 <code>lex()</code> 方法进行词法分析，最后返回一个 TokenStream，里面每个单元是一个 Token。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PushbackReader pushbackReader;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    pushbackReader = <span class="keyword">new</span> <span class="title class_">PushbackReader</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span></span><br><span class="line">    <span class="title class_">FileReader</span>(filePath, StandardCharsets.UTF_8)), <span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;初始化 Lexer 失败: 文件未找到 &quot;</span> + filePath, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 词法分析</span></span><br><span class="line"><span class="type">TokenStream</span> <span class="variable">tokenStream</span> <span class="operator">=</span> Lexer.getInstance(pushbackReader).lex();</span><br><span class="line">Printer.printToLexer(tokenStream.toString());</span><br></pre></td></tr></table></figure>

<h3 id="编码完成之后的修改"><a href="#编码完成之后的修改" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p>为了简化文件读取流程，我封装了 <code>read()</code> 方法和 <code>currentChar</code>，方便词法分析操作。<code>currentChar</code> 相当于一个指针，用来指向当前正在处理的字符。如果想访问当前字符，只需要直接访问 <code>currentChar</code> 即可。如果要处理下一个字符并且不需要当前字符了，只需要调用 <code>read()</code> 方法就可以。如果想保留当前字符同时提前看下一个字符，只需要调用 <code>peek()</code> 方法。</p>
<p>实际的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> reader.read();</span><br><span class="line">    currentChar = (<span class="type">char</span>) t;</span><br><span class="line">    <span class="keyword">return</span> currentChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader.unread(currentChar);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">peek</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> reader.read();</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) t;</span><br><span class="line">    reader.unread(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEOF</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentChar == EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在词法分析主流程中，我采用循环写法，每次循环中先跳过空白符，再读取下一个token。</p>
<p>我把“跳空白 + 跳注释”单独抽成了 <code>skipWhitespaceAndComments()</code>，其核心功能是跳过换行和注释。在 Lexer 类里面维护一个 <code>line</code>，如果遇到换行，包括多行注释里面的换行，则 <code>line++</code>，同时跳过该字符。如果是 <code>/</code>，则看后面是否是 <code>//</code> 或 <code>/*</code>，如果是 <code>//</code> 则一直读字符直到读取至换行，如果是 <code>/*</code> 则一直读取至 <code>*/</code> 或者文件结尾。 因为这块一开始没抽出来的时候特别容易漏掉“多行注释里行号递增”，导致后面语法&#x2F;语义报错行号一塌糊涂。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">skipWhitespaceAndComments</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">while</span> (Character.isWhitespace(currentChar) || currentChar == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentChar == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            line++;</span><br><span class="line">            read();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isWhitespace(currentChar)) &#123;</span><br><span class="line">            read();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentChar == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">nextChar</span> <span class="operator">=</span> peek();</span><br><span class="line">                <span class="keyword">if</span> (nextChar == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// Single-line comment</span></span><br><span class="line">                    <span class="keyword">while</span> (currentChar != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; !isEOF()) &#123;</span><br><span class="line">                        read();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (currentChar == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                        line++;</span><br><span class="line">                        read();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextChar == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// Multi-line comment</span></span><br><span class="line">                    read(); <span class="comment">// consume &#x27;*&#x27;</span></span><br><span class="line">                    read(); <span class="comment">// consume first char inside comment</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isEOF()) &#123;</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// Unterminated comment</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (currentChar == <span class="string">&#x27;*&#x27;</span> &amp;&amp; peek() == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                            read(); <span class="comment">// consume &#x27;*&#x27;</span></span><br><span class="line">                            read(); <span class="comment">// consume &#x27;/&#x27;</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (currentChar == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                            line++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        read();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Not a comment, just a &#x27;/&#x27;</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先跳过空白符，然后判断是否遇到了文件结尾，如果是结尾则直接结束。否则读取下一个 Token，并添加至 TokenStream 中。</p>
<p>token 识别上主要分几类：</p>
<ul>
<li><strong>单字符直接定类</strong>：括号、分号、+ - * &#x2F; % , 等</li>
<li><strong>需要向前看一位的</strong>：&#x3D; ! &lt; &gt; &amp; |，用 peek() 分辨 &#x3D;&#x3D;&#x2F;&#x3D;、!&#x3D;&#x2F;!、&amp;&amp;&#x2F;非法 &amp; 等</li>
<li><strong>数字</strong>：连续读数字得到 INTCON</li>
<li><strong>标识符&#x2F;关键字</strong>：连续读字母&#x2F;数字&#x2F;下划线，然后用 switch 匹配关键字（const&#x2F;int&#x2F;static&#x2F;…）</li>
<li><strong>字符串</strong>：遇到 “ 一直读到下一个 “</li>
</ul>
<p>这样做的好处是按照类别分类，保证了正确性，方便后续扩展与迭代开发。核心分拣代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Token <span class="title function_">getNextToken</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSingleToken()) &#123;</span><br><span class="line">        <span class="comment">// 单字符就可以判定为 Token</span></span><br><span class="line">        <span class="keyword">return</span> tackleSingleToken();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOneOrTwoToken()) &#123;</span><br><span class="line">        <span class="comment">// 需要再向后读一个字符来判定的 Token</span></span><br><span class="line">        <span class="keyword">return</span> tackleOneOrTwoToken();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentChar == <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 字符串字面量</span></span><br><span class="line">        <span class="keyword">return</span> tackleStringLiteral();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(currentChar)) &#123;</span><br><span class="line">        <span class="comment">// 数字字面量</span></span><br><span class="line">        <span class="keyword">return</span> tackleDigit();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 标识符或关键字</span></span><br><span class="line">        <span class="keyword">return</span> tackleIdent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>词法阶段我只处理了一类比较“硬”的错误：单个 &amp; 或 |。按要求应该是 &amp;&amp;&#x2F;||，所以这里直接记一个错误码 a，但仍然返回一个逻辑与&#x2F;或 token，让后续阶段能继续跑下去，否则错误恢复会更麻烦。</p>
<h2 id="语法分析设计"><a href="#语法分析设计" class="headerlink" title="语法分析设计"></a>语法分析设计</h2><blockquote>
<p>2025年10月1日完稿</p>
</blockquote>
<h3 id="编码前设计-1"><a href="#编码前设计-1" class="headerlink" title="编码前设计"></a>编码前设计</h3><p>语法分析做的事就是把 TokenStream 还原成结构化的 AST。</p>
<p>我的 AST 节点类是按文法一比一建造的，优点是写起来直接，缺点就是类很多、文件夹会很大。</p>
<p>对于 Parser 采用单例模式设计，用 Node 接口来统一串联所有节点。为了更好的管理每种语法类型，我还对所有语法成分进行了目录分类，比如所有语句类 Stmt 可以单独存放，所有表达式 Exp 也可以存放，所有初始值 IV, CIV 也可以单独存放。</p>
<h4 id="文件组织-2"><a href="#文件组织-2" class="headerlink" title="文件组织"></a>文件组织</h4><ul>
<li><code>frontend/parser/Parser.java</code>：递归下降解析</li>
<li><code>frontend/parser/AST/*</code>：各语法节点类</li>
</ul>
<p>具体文件结构如图所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">parser</span><br><span class="line"> └─ AST</span><br><span class="line">    ├─ CIV</span><br><span class="line">    ├─ Exp</span><br><span class="line">    ├─ Func</span><br><span class="line">    ├─ IV</span><br><span class="line">    ├─ Stmt</span><br><span class="line">    │  Ⓒ Block</span><br><span class="line">    │  Ⓘ BlockItem</span><br><span class="line">    Ⓒ CompUnit</span><br><span class="line">    Ⓒ ConstDecl</span><br><span class="line">    Ⓒ ConstDef</span><br><span class="line">    Ⓘ Decl</span><br><span class="line">    Ⓒ VarDecl</span><br><span class="line">    Ⓒ VarDef</span><br><span class="line"> Ⓘ Node</span><br><span class="line"> Ⓒ Parser</span><br></pre></td></tr></table></figure>

<h3 id="编码完成之后的修改-1"><a href="#编码完成之后的修改-1" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><h4 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h4><p>为了更方便的处理 TokenStream，我依旧仿照词法分析的方式设置了很多方法，例如 next，getCurToken，peek等。</p>
<p>其用途是，<code>getCurToken</code> 相当于一个 Token 指针，指向当前处理的 Token，想要获取当前 Token 只需要调用 <code>getCurToken</code> 方法。如果处理完当前 Token 想要处理下一个 Token，只需要调用 <code>next</code> 方法即可。这里还支持 <code>peek</code>，可以动态向前查看多个 Token 字符。为了查看上一个字符，还可以调用 <code>last</code> 方法。同时为了支持回溯，我还支持用 <code>getCurPos</code> 获取当前的 pos，在需要回溯的时候再 <code>setCurPos</code> 重新设置 pos 位置，达到回溯的效果。</p>
<p>核心代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Token <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= tokens.size()) &#123;</span><br><span class="line">        curToken = <span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.EOF, <span class="string">&quot;end&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> curToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// System.out.println(p + &quot; &quot; + tokens.get(p).getLine() + &quot; &quot; + tokens.get(p));</span></span><br><span class="line">    curToken = tokens.get(pos++);</span><br><span class="line">    <span class="keyword">return</span> curToken;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">getCurToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curToken;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">peek</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos + delta - <span class="number">1</span> &gt;= tokens.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.EOF, <span class="string">&quot;end&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens.get(pos + delta - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">last</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.EOF, <span class="string">&quot;end&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens.get(pos - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurPos</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurPos</span><span class="params">(<span class="type">int</span> pos)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pos = pos;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">0</span> &amp;&amp; pos &lt;= tokens.size()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.curToken = tokens.get(pos - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.curToken = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h4><p>整体就是递归下降：<code>parseCompUnit()</code> 往下调 <code>parseDecl</code>&#x2F;<code>parseFuncDef</code>&#x2F;<code>parseStmt</code>&#x2F;<code>parseExp</code>…。对于每一个语法成分，我都建立了一个类，在语法分析时只需要调用该语法成分的 parse 方法，然后依次调用子成分的 parse 方法，最后返回该语法成分的实例即可。</p>
<p>我们首先改写文法，消除其中的左递归，然后在各个节点类中按照改写后的文法定义各个节点的属性和相应的Get和Set方法。之后，我们在Parser类中递归向下分析每个节点类即可。具体细节如下：</p>
<ol>
<li><strong>递归下降解析</strong><br>每种语法规则对应一个解析函数。例如：<ul>
<li><code>parseAddExp()</code> 用于解析 AddExp，它递归调用 <code>parseMulExp()</code>。</li>
</ul>
</li>
<li><strong>回溯支持</strong><ul>
<li>在可能的多分支选择中，通过预读下一个 Token 判断选择路径。</li>
<li>如果无法通过预读解决选择路径的话，则需要进行回溯，此时仅需要记录下回溯返回的位置，并在结束时返回合适的位置即可。</li>
</ul>
</li>
</ol>
<p>有个我觉得比较关键的点是语句分支的判定，比如 Stmt 里要区分：</p>
<ul>
<li><code>LVal &#39;=&#39; Exp &#39;;&#39;</code></li>
<li><code>[Exp] &#39;;&#39;</code></li>
</ul>
<p>这块我用了“试探 + 回退”：先记下 curPos，临时解析一次 LVal 看下一 token 是不是 ASSIGN，然后再 setCurPos(curPos) 回去走真正的分支。</p>
<p>一个典型的代码示例为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stmt -&gt; &#x27;printf&#x27; &#x27;(&#x27; StringConst &#123; &#x27;,&#x27; Exp &#125; &#x27;)&#x27; &#x27;;&#x27; // i j</span></span><br><span class="line"><span class="keyword">public</span> PrintfStmt <span class="title function_">parsePrintfStmt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Token</span> <span class="variable">printfToken</span> <span class="operator">=</span> tokenStream.getCurToken(); <span class="comment">// printf</span></span><br><span class="line">    tokenStream.next(); <span class="comment">// printf</span></span><br><span class="line">    tokenStream.next(); <span class="comment">// (</span></span><br><span class="line">    <span class="type">Token</span> <span class="variable">stringConst</span> <span class="operator">=</span> tokenStream.getCurToken(); <span class="comment">// stringConst</span></span><br><span class="line">    tokenStream.next(); <span class="comment">// stringConst</span></span><br><span class="line">    ArrayList&lt;Exp&gt; exps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (tokenStream.getCurToken().is(COMMA)) &#123;</span><br><span class="line">        tokenStream.next(); <span class="comment">// ,</span></span><br><span class="line">        exps.add(parseExp());</span><br><span class="line">    &#125;</span><br><span class="line">    checkParserError(RPARENT);</span><br><span class="line">    checkParserError(SEMICN);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PrintfStmt</span>(stringConst, exps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p>语法阶段主要按课程要求处理 i&#x2F;j&#x2F;k 三类缺符号：</p>
<ul>
<li><strong>i</strong>：缺 ;</li>
<li><strong>j</strong>：缺 )</li>
<li><strong>k</strong>：缺 ]</li>
</ul>
<p>实现上统一走 <code>checkParserError</code>：如果当前 token 不是期望符号，就用 <code>tokenStream.last().getLine()</code> 去报错，也就是“报在上一个正常 token 的行号上”，否则就消费掉这个符号。</p>
<p>另外我加了一个 <code>errorLayer</code>：在“试探解析”期间把它加一，避免试探过程触发一堆无意义的 i&#x2F;j&#x2F;k，这类误报非常影响调试心情。</p>
<ul>
<li>增加 <code>errorLayer</code>，把“试探解析”从错误收集里隔离出去。</li>
<li>i&#x2F;j&#x2F;k 统一封装到 <code>checkParserError</code>，不在各个 <code>parseXxx</code> 里散落重复逻辑。</li>
</ul>
<h2 id="语义分析设计"><a href="#语义分析设计" class="headerlink" title="语义分析设计"></a>语义分析设计</h2><blockquote>
<p>2025年10月7日完稿</p>
</blockquote>
<h3 id="编码前设计-2"><a href="#编码前设计-2" class="headerlink" title="编码前设计"></a>编码前设计</h3><p>语义分析主要需要做两件事：</p>
<ul>
<li>对于正确的源程序，需要从源程序中识别出定义的常量、变量等，输出它们的作用域序号，单词的字符&#x2F;字符串形式，类型名称。</li>
<li>对于错误的源程序，需要识别出错误，并输出错误所在的行号和错误的类别码。</li>
</ul>
<p>可以看到课程组有意识地将错误处理分散在编译器的全流程中，事实上这确实是合理的，因为真正的编译器不可能是只在考察编译器错误处理能力时提供错误的代码。</p>
<h4 id="文件组织-3"><a href="#文件组织-3" class="headerlink" title="文件组织"></a>文件组织</h4><p>语义分析主要在 <code>Visitor</code> 中完成，核心是遍历 AST 并维护符号表。</p>
<ul>
<li><code>frontend/Visitor/Visitor.java</code>：语义检查主体，实现 AST 节点的 visit 方法。</li>
<li><code>frontend/Visitor/SymbolTable.java</code>：树形符号表，支持父子作用域嵌套。</li>
<li><code>frontend/Visitor/Symbol/*</code>：<ul>
<li><code>VarSymbol</code>：变量&#x2F;常量符号，记录类型、维度、是否全局等。</li>
<li><code>FuncSymbol</code>：函数符号，记录返回值类型、形参列表。</li>
<li><code>SymbolType</code>：符号类型枚举。</li>
</ul>
</li>
</ul>
<p>具体文件结构如下图所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Visitor</span><br><span class="line"> └─ Symbol</span><br><span class="line">    Ⓒ FuncSymbol</span><br><span class="line">    Ⓒ Symbol</span><br><span class="line">    Ⓔ SymbolType</span><br><span class="line">    Ⓒ VarSymbol</span><br><span class="line"> Ⓒ SymbolTable</span><br><span class="line"> Ⓒ Visitor</span><br></pre></td></tr></table></figure>

<h3 id="工作流程-3"><a href="#工作流程-3" class="headerlink" title="工作流程"></a>工作流程</h3><p>入口从 CompUnit 开始，顺序检查：全局声明 → 函数定义 → main 函数。</p>
<p>对于每个语法成分，先用 get 方法获得其子成分，然后再依次调用 check 方法检查其子语法成分是否有语义错误。</p>
<p>代码示例为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stmt -&gt; &#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; Stmt // h</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkForCycleStmt</span><span class="params">(ForCycleStmt stmt)</span> &#123;</span><br><span class="line">    <span class="type">ForStmt</span> <span class="variable">initStmt</span> <span class="operator">=</span> stmt.getInitStmt();</span><br><span class="line">    <span class="type">Cond</span> <span class="variable">cond</span> <span class="operator">=</span> stmt.getCond();</span><br><span class="line">    <span class="type">ForStmt</span> <span class="variable">stepStmt</span> <span class="operator">=</span> stmt.getStepStmt();</span><br><span class="line">    <span class="type">Stmt</span> <span class="variable">bodyStmt</span> <span class="operator">=</span> stmt.getBodyStmt();</span><br><span class="line">    <span class="keyword">if</span> (initStmt != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkForStmt(initStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cond != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkCond(cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stepStmt != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkForStmt(stepStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    loopNum++;</span><br><span class="line">    checkStmt(bodyStmt);</span><br><span class="line">    loopNum--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在作用域管理上，采用树形 SymbolTable 结构。每当进入一个新的代码块，Block，就调用 <code>enterBlock()</code> 创建一个新的子符号表，并将当前符号表指针 curTable 指向它；离开代码块时，调用 <code>leaveBlock()</code> 回退到父符号表。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enterBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    idCount++;</span><br><span class="line">    <span class="type">SymbolTable</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolTable</span>(idCount, curTable);</span><br><span class="line">    curTable.addChild(child);</span><br><span class="line">    curTable = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leaveBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    curTable = curTable.getFather();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编码完成之后的修改-2"><a href="#编码完成之后的修改-2" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><h4 id="工作流程-4"><a href="#工作流程-4" class="headerlink" title="工作流程"></a>工作流程</h4><p>在编码过程中，为了方便后续中间代码生成时能正确映射符号，我严格保证了 Visitor 建立符号表的顺序与 IRBuilder 遍历 AST 的顺序一致。</p>
<p>此外，对于库函数，getint, putint, putch, putstr，我在 Visitor 的构造函数中直接将它们加入到了顶层全局符号表中。这样在处理函数调用时，无需对库函数做特殊判断，除了 getint 需要检查无参，统一了处理逻辑。最后在输出 symbol.txt 的时候去掉库函数的输出即可。</p>
<h4 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h4><p>语义错误主要依据课程要求的错误码进行检查，重点处理了以下几类：</p>
<table>
<thead>
<tr>
<th align="left">错误类别码</th>
<th align="left">错误类型</th>
<th align="left">解决思路</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="left">操作符有错误（ &amp; 和 | ）</td>
<td align="left">在语法分析阶段进行</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">名字重定义（函数名和变量名重定义）</td>
<td align="left">在当前作用域内查找</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">可执行语句使用未定义的名字</td>
<td align="left">利用符号表的父指针，不断向外查找</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">函数参数个数不匹配</td>
<td align="left">解析完函数调用后进行确认</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">函数参数类型不匹配</td>
<td align="left">解析完函数调用后进行确认</td>
</tr>
<tr>
<td align="left">h</td>
<td align="left">不能改变常量的值</td>
<td align="left">检查Symbol的类型是否为const</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">无返回值的函数存在不匹配的return语句</td>
<td align="left">在 FuncDef 内进行处理</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">有返回值的函数缺少return语句</td>
<td align="left">在 FuncDef 解析结束后对函数Block进行查找</td>
</tr>
</tbody></table>
<p>对于新增的错误类型，我采用在 check 方法中特判的做法。</p>
<p>如果有语义错误，则新建 Error 实例并调用 addError 添加至 ErrorLog 中，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addError</span><span class="params">(Token ident, <span class="type">char</span> errorKey)</span> &#123;</span><br><span class="line">    <span class="type">Error</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ident.getLine(), errorKey);</span><br><span class="line">    ErrorLog.getInstance().addError(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码生成设计"><a href="#代码生成设计" class="headerlink" title="代码生成设计"></a>代码生成设计</h2><blockquote>
<p>2025年11月15日初稿，2025年12月20日完稿</p>
</blockquote>
<h3 id="编码前设计-3"><a href="#编码前设计-3" class="headerlink" title="编码前设计"></a>编码前设计</h3><h4 id="中间代码选择"><a href="#中间代码选择" class="headerlink" title="中间代码选择"></a>中间代码选择</h4><p>代码生成分为中间代码生成 LLVM IR 和目标代码生成 MIPS 两个阶段。</p>
<p>我是选择的LLVM作为中间代码，原因主要有三：</p>
<ul>
<li>有很多往年学长的博客、代码可以参考，便于实现；</li>
<li>LLVM 本身是十分易于优化的。</li>
<li>即使最后完不成 mips 代码生成，也可以选择 LLVM 作为目标代码，可谓是进可攻、退可守。</li>
</ul>
<h4 id="LLVM-介绍"><a href="#LLVM-介绍" class="headerlink" title="LLVM 介绍"></a>LLVM 介绍</h4><p>LLVM 中有四个具有依次包含关系的基本概念：</p>
<ul>
<li><strong>Module</strong> 是一份 LLVM IR 的顶层容器，对应于编译前端的每个翻译单元。一个 Module 由若干 GlobalValue 组成，而一个GlobalValue 可以是全局变量 GlobalVariable，也可以是函数 Function。</li>
<li><strong>Function</strong> 就是编程语言中的函数，包括函数签名和若干个基本块。函数内的第一个基本块叫做入口基本块。</li>
<li><strong>BasicBlock</strong> 是一组顺序执行的指令集合，只有一个入口和一个出口，非头尾指令执行时不会违背顺序跳转到其他指令上去<ul>
<li>每个基本块最后一条指令一般是跳转指令</li>
<li>每个 BasicBlock 都有一个 label，label 使得该 BasicBlock 有一个符号表的入口点</li>
<li>函数内最后一个基本块的最后条指令是函数返回指令，以terminator instruction（ret、br等）结尾</li>
</ul>
</li>
<li><strong>Instruction</strong> 是 LLVM IR 的最小可执行单位，每一条指令都单占一行</li>
</ul>
<h4 id="Value-Use"><a href="#Value-Use" class="headerlink" title="Value-Use"></a>Value-Use</h4><p>LLVM 中所有类都直接或间接继承自 Value，在 LLVM 中，有“一切皆 Value”的说法。通过规整的继承关系，就得到了 LLVM 的类型系统。</p>
<p>为了表达 Value 之间的引用关系，LLVM 中还有一种特殊的 Value 叫做 User，其将其他 Value 作为参数。</p>
<p>Instruction 继承自 User，因此它可以将其他 Value 作为参数。对于指令 <code>%add1 = add nsw i32 %a, %b</code>，在 <code>%add1</code> 与 <code>%a</code>、<code>%b</code> 之间分别构成了 Use 关系。后续的相关指令也可以继续进行调用，形成 Use 链。</p>
<p>这种指令间的关系正是 LLVM 的核心之一，实现了 SSA 形式的中间代码。这样的形式可以方便 LLVM 进行分析和优化，如：</p>
<ul>
<li>可以快速分析两个值是否是同一个值，是否要删除冗余代码。</li>
<li>如果一个 Value 没有 Use 关系，很可能就是可以删除的冗余代码。</li>
</ul>
<p>在设计中间代码生成的过程中，我一开始并不理解其 value-use 关系的设计目的，直到后期做到了代码优化，才明白其重要性，可以便捷地找到在函数的值实体之间的依赖关系。</p>
<h4 id="文件组织-4"><a href="#文件组织-4" class="headerlink" title="文件组织"></a>文件组织</h4><ul>
<li><strong>中间代码</strong>：<ul>
<li><code>middle/IRBuilder.java</code>：IR 生成总入口。</li>
<li><code>middle/component/*</code>：IR 组件，包括 Module, Function, BasicBlock, Instruction 等。</li>
</ul>
</li>
<li><strong>目标代码</strong>：<ul>
<li><code>backend/MipsBuilder.java</code>：MIPS 生成总入口。</li>
<li><code>backend/MipsFile.java</code>：负责管理 .data 和 .text 段并输出。</li>
<li><code>backend/component/*</code>：MIPS 指令与操作数类。</li>
</ul>
</li>
</ul>
<p>具体文件组织如下图：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">middle</span><br><span class="line"> └─ component</span><br><span class="line">    ├─ instruction</span><br><span class="line">    ├─ model</span><br><span class="line">    └─ type</span><br><span class="line">    Ⓒ BasicBlock</span><br><span class="line">    Ⓒ ConstInt</span><br><span class="line">    Ⓒ ConstString</span><br><span class="line">    Ⓒ ForLoop</span><br><span class="line">    Ⓒ FuncParam</span><br><span class="line">    Ⓒ Function</span><br><span class="line">    Ⓒ GlobalVar</span><br><span class="line">    Ⓒ InitialValue</span><br><span class="line">    Ⓒ Module</span><br><span class="line">    Ⓒ Undefined</span><br><span class="line"> Ⓒ IRBuilder</span><br><span class="line"> Ⓒ IRData</span><br></pre></td></tr></table></figure>

<h4 id="工作流程-5"><a href="#工作流程-5" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li><strong>IR 生成</strong>：遍历 AST，将全局变量转换为 GlobalVar，将函数体转换为 BasicBlock 和 Instruction 序列。</li>
<li><strong>MIPS 生成</strong>：遍历生成的 IR Module，将每个 IR 指令映射为对应的 MIPS 指令序列。</li>
</ol>
<h3 id="编码完成之后的修改-3"><a href="#编码完成之后的修改-3" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><p>我使用了 LLVM-IR 来作为中间代码。使得程序真正有了可运行的结果。</p>
<p>中间代码生成无疑是工作量最大的一部分，我几乎投入了完整的五天才解决了中间代码生成过程中的全部问题。</p>
<h4 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h4><p>在 IRBuilder 中，我维护了一个 lookupTable，用于建立 AST 中的 Symbol 到 LLVM IR Value 的映射。</p>
<p><strong>作用域管理</strong></p>
<p>为了保证符号查找的正确性，我严格按照 AST 遍历顺序维护符号表栈。<br>这样可以跟语义分析保持同样的逻辑，方便我书写代码，同样也方便我梳理思路，防止出错。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enterScope</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> childIndexMap.getOrDefault(currentTable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; currentTable.getChildren().size()) &#123;</span><br><span class="line">        currentTable = currentTable.getChildren().get(index);</span><br><span class="line">        childIndexMap.put(currentTable.getFather(), index + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Scope mismatch...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lookupTable = <span class="keyword">new</span> <span class="title class_">SymbolTable</span>(currentTable.getId(), lookupTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制流生成</strong></p>
<p>对于 if-else 语句，我采用了标准的“基本块 + 跳转”模式。<br>特别注意了短路求值和空 else 块的处理。</p>
<p>相关代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildIfElseStmt</span><span class="params">(IfElseStmt stmt)</span> &#123;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">trueBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicBlock</span>(IRData.getBlockName());</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">falseBlock</span> <span class="operator">=</span> stmt.getElseStmt() != <span class="literal">null</span> ? <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">BasicBlock</span>(IRData.getBlockName()) : <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">nextBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicBlock</span>(IRData.getBlockName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置基本块所属函数</span></span><br><span class="line">    trueBlock.setFunction(currentFunction);</span><br><span class="line">    <span class="keyword">if</span> (falseBlock != <span class="literal">null</span>) falseBlock.setFunction(currentFunction);</span><br><span class="line">    nextBlock.setFunction(currentFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成条件跳转</span></span><br><span class="line">    buildCond(stmt.getCond(), trueBlock, falseBlock != <span class="literal">null</span> ? falseBlock : nextBlock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 True 分支</span></span><br><span class="line">    IRData.setCurrentBlock(trueBlock);</span><br><span class="line">    currentBlock = trueBlock;</span><br><span class="line">    buildStmt(stmt.getIfStmt());</span><br><span class="line">    <span class="keyword">if</span> (!isBlockTerminated(currentBlock)) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BrInst</span>(nextBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 False 分支（如果有）</span></span><br><span class="line">    <span class="keyword">if</span> (falseBlock != <span class="literal">null</span>) &#123;</span><br><span class="line">        IRData.setCurrentBlock(falseBlock);</span><br><span class="line">        currentBlock = falseBlock;</span><br><span class="line">        buildStmt(stmt.getElseStmt());</span><br><span class="line">        <span class="keyword">if</span> (!isBlockTerminated(currentBlock)) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BrInst</span>(nextBlock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇合点</span></span><br><span class="line">    IRData.setCurrentBlock(nextBlock);</span><br><span class="line">    currentBlock = nextBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组初始化</strong></p>
<p>为了处理局部数组的初始化，我实现了 <code>buildLocalArrayInit</code> 方法。<br>利用 GepInst 计算地址并逐个 Store。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildLocalArrayInit</span><span class="params">(Value baseAddr, InitVal initVal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initVal <span class="keyword">instanceof</span> IVExps) &#123;</span><br><span class="line">        <span class="type">IVExps</span> <span class="variable">ivExps</span> <span class="operator">=</span> (IVExps) initVal;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ivExps.getExps().size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrayLen</span> <span class="operator">=</span> ((ArrayType) ((PointerType)baseAddr.getValueType()).getTargetType()).getElementNum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式初始化的部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">Exp</span> <span class="variable">exp</span> <span class="operator">=</span> ivExps.getExps().get(i);</span><br><span class="line">            <span class="type">Value</span> <span class="variable">val</span> <span class="operator">=</span> buildExp(exp);</span><br><span class="line">            <span class="type">Instruction</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GepInst</span>(baseAddr, <span class="keyword">new</span> <span class="title class_">ConstInt</span>(IntegerType.i32, i));</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StoreInst</span>(gep, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未显式初始化的部分补 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &lt; arrayLen; i++) &#123;</span><br><span class="line">            <span class="type">Instruction</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GepInst</span>(baseAddr, <span class="keyword">new</span> <span class="title class_">ConstInt</span>(IntegerType.i32, i));</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StoreInst</span>(gep, <span class="keyword">new</span> <span class="title class_">ConstInt</span>(IntegerType.i32, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MIPS目标代码生成"><a href="#MIPS目标代码生成" class="headerlink" title="MIPS目标代码生成"></a>MIPS目标代码生成</h4><p>在 MipsBuilder 中，我使用了 <code>Map&lt;Class, Consumer&gt;</code> 的方式来分发指令生成逻辑。<br>这样做的好处是可以避免冗长的 if-else 或 switch 结构。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initInstructionHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">    instructionHandlers.put(AllocInst.class, inst -&gt; buildAllocInst((AllocInst) inst));</span><br><span class="line">    instructionHandlers.put(BinaryInst.class, inst -&gt; &#123;</span><br><span class="line">        <span class="type">BinaryInst</span> <span class="variable">binaryInst</span> <span class="operator">=</span> (BinaryInst) inst;</span><br><span class="line">        <span class="keyword">if</span> (OperatorType.isLogicalOperator(binaryInst.getOpType())) &#123;</span><br><span class="line">            buildIcmp(binaryInst);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buildBinaryInst(binaryInst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ... 其他指令映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈帧管理与寄存器分配</strong></p>
<p>在函数生成开始时，我会计算所有局部变量的栈偏移量。<br>如果开启优化，还会根据寄存器分配结果预留寄存器。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildFunction</span><span class="params">(Function function)</span> &#123;</span><br><span class="line">    currentFunction = function;</span><br><span class="line">    var2Offset = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    curStackOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取寄存器分配结果</span></span><br><span class="line">    var2reg = optimizeOn ? <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(function.getVar2reg()) : <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;func_&quot;</span> + function.getName().substring(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数：前4个参数在寄存器，后续参数在栈上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; function.getFuncParams().size(); i++) &#123;</span><br><span class="line">        curStackOffset -= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            var2reg.put(function.getFuncParams().get(i),</span><br><span class="line">            Register.getByOffset(Register.A0, i));</span><br><span class="line">        &#125;</span><br><span class="line">        var2Offset.put(function.getFuncParams().get(i), curStackOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为其他指令分配栈空间（如果未分配寄存器）</span></span><br><span class="line">    <span class="keyword">for</span> (BasicBlock block : function.getBasicBlocks()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Instruction instruction : block.getInstructions()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!instruction.getName().isEmpty() &amp;&amp; !var2reg.containsKey(instruction)) &#123;</span><br><span class="line">                curStackOffset -= <span class="number">4</span>;</span><br><span class="line">                var2Offset.put(instruction, curStackOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 生成基本块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>比较指令生成</strong></p>
<p>对于比较指令，如 <code>icmp eq</code>，我将其转换为 MIPS 的 <code>seq</code> 等指令。<br>如果操作数在寄存器中则直接使用，否则从栈中加载。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildIcmp</span><span class="params">(BinaryInst binaryInst)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 确定操作码 asmOp (SEQ, SNE, SLT 等)</span></span><br><span class="line">    <span class="type">Value</span> <span class="variable">operand1</span> <span class="operator">=</span> binaryInst.getOperand1();</span><br><span class="line">    <span class="type">Value</span> <span class="variable">operand2</span> <span class="operator">=</span> binaryInst.getOperand2();</span><br><span class="line">    <span class="type">Register</span> <span class="variable">reg1</span> <span class="operator">=</span> Register.K0;</span><br><span class="line">    <span class="type">Register</span> <span class="variable">reg2</span> <span class="operator">=</span> Register.K1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载操作数到寄存器</span></span><br><span class="line">    <span class="keyword">if</span> (operand1 <span class="keyword">instanceof</span> ConstInt constInt) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LiAsm</span>(reg1, constInt.getIntValue());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2reg.containsKey(operand1)) &#123;</span><br><span class="line">        reg1 = var2reg.get(operand1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MemAsm</span>(AsmOp.LW, reg1, Register.SP, var2Offset.get(operand1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 加载 operand2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成比较指令</span></span><br><span class="line">    <span class="type">Register</span> <span class="variable">targetReg</span> <span class="operator">=</span> var2reg.getOrDefault(binaryInst, Register.K0);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CmpAsm</span>(asmOp, targetReg, reg1, reg2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果结果未分配寄存器，存回栈</span></span><br><span class="line">    <span class="keyword">if</span> (!var2reg.containsKey(binaryInst)) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MemAsm</span>(AsmOp.SW, targetReg, Register.SP, var2Offset.get(binaryInst));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码前后的改变主要如下：</p>
<ol>
<li>在每条指令翻译后都添加相应的注释输出中间代码，这样可以便于debug</li>
<li>对栈的操作核查了多次，小心再小心</li>
</ol>
<h2 id="代码优化设计"><a href="#代码优化设计" class="headerlink" title="代码优化设计"></a>代码优化设计</h2><blockquote>
<p>2026年1月2日完稿</p>
</blockquote>
<h3 id="编码前设计-4"><a href="#编码前设计-4" class="headerlink" title="编码前设计"></a>编码前设计</h3><h4 id="文件组织-5"><a href="#文件组织-5" class="headerlink" title="文件组织"></a>文件组织</h4><ul>
<li><code>optimize/Optimizer.java</code>：优化器入口，组织所有 Pass 的执行顺序。</li>
<li><code>optimize/*</code>：各种具体的优化 Pass 类，如 Mem2Reg, GVN, LoopUnroll 等。</li>
</ul>
<p>所做的优化大概如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">optimize</span><br><span class="line"> Ⓒ BlockSimplify</span><br><span class="line"> Ⓒ CodeRemoval</span><br><span class="line"> Ⓒ CondConstProp</span><br><span class="line"> Ⓒ DivideCall</span><br><span class="line"> Ⓒ FixMD</span><br><span class="line"> Ⓒ FunctionCopy</span><br><span class="line"> Ⓒ FunctionSideEffect</span><br><span class="line"> Ⓒ GCM</span><br><span class="line"> Ⓒ GlobalVarLocalize</span><br><span class="line"> Ⓒ GVN</span><br><span class="line"> Ⓒ IcmpOptimize</span><br><span class="line"> Ⓒ InlinedFunction</span><br><span class="line"> Ⓒ LocalConstArrayToValue</span><br><span class="line"> Ⓒ LoopAnalysis</span><br><span class="line"> Ⓒ LoopInvariantHoist</span><br><span class="line"> Ⓒ LoopRecord</span><br><span class="line"> Ⓒ LoopUnroll</span><br><span class="line"> Ⓒ Mem2Reg</span><br><span class="line"> Ⓒ MemoryOptimize</span><br><span class="line"> Ⓒ Optimizer</span><br><span class="line"> Ⓒ PhiOptimize</span><br><span class="line"> Ⓒ PickGep</span><br><span class="line"> Ⓒ PrintOptimize</span><br><span class="line"> Ⓒ PureFunctionEval</span><br><span class="line"> Ⓒ SpecificOptimize</span><br><span class="line"> Ⓒ SurplusBlock</span><br><span class="line"> Ⓒ UnusedFunction</span><br><span class="line"> Ⓒ UnusedLocalArray</span><br></pre></td></tr></table></figure>

<h4 id="工作流程-6"><a href="#工作流程-6" class="headerlink" title="工作流程"></a>工作流程</h4><p>优化器接收一个 Module，按顺序执行一系列优化 Pass，对 IR 进行转换和精简，最后输出优化后的 Module。</p>
<h3 id="编码完成之后的修改-4"><a href="#编码完成之后的修改-4" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><p>优化具体可见优化文档，这里挑几个有代表性的优化讲一下。</p>
<h4 id="工作流程-7"><a href="#工作流程-7" class="headerlink" title="工作流程"></a>工作流程</h4><p>我采用了“多轮迭代”的策略，将主要的优化 Pass 放入一个循环中执行多次，目前设定为 10 轮，以便不同优化之间能够相互促进。例如，Mem2Reg 可能会产生无用代码，随后的 CodeRemoval 可以将其删除，从而暴露更多的优化机会。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">optimize</span><span class="params">()</span> &#123;</span><br><span class="line">    UnusedLocalArray.run(<span class="keyword">module</span>);</span><br><span class="line">    PureFunctionEval.run(<span class="keyword">module</span>); <span class="comment">// 纯函数常量参数求值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        SurplusBlock.build(<span class="keyword">module</span>);</span><br><span class="line">        Mem2Reg.run(<span class="keyword">module</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        GVN.run(<span class="keyword">module</span>);</span><br><span class="line">        LoopUnroll.run(<span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SurplusBlock.build(<span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键优化-Pass-实现"><a href="#关键优化-Pass-实现" class="headerlink" title="关键优化 Pass 实现"></a>关键优化 Pass 实现</h3><h4 id="Mem2Reg"><a href="#Mem2Reg" class="headerlink" title="Mem2Reg"></a>Mem2Reg</h4><p>这是中端优化的核心，通过计算支配树和支配边界，插入 Phi 节点并重命名变量，将内存访问（ alloca&#x2F;load&#x2F;store ）提升为寄存器操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">optimize</span><span class="params">(Function function, <span class="type">boolean</span> simplify)</span> &#123;</span><br><span class="line">    currentFunction = function;</span><br><span class="line">    calcControlFlowGraph(); <span class="comment">// 计算 CFG</span></span><br><span class="line">    calcDominatorTree();    <span class="comment">// 计算支配树</span></span><br><span class="line">    calcDominanceFrontier();<span class="comment">// 计算支配边界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!simplify) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个整型 AllocInst 进行提升</span></span><br><span class="line">    <span class="keyword">for</span> (BasicBlock block : function.getBasicBlocks()) &#123;</span><br><span class="line">        ArrayList&lt;Instruction&gt; instructions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(block.getInstructions());</span><br><span class="line">        <span class="keyword">for</span> (Instruction instruction : instructions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instruction <span class="keyword">instanceof</span> AllocInst allocInst</span><br><span class="line">            &amp;&amp; (allocInst.getTargetType().equals(IntegerType.i32)))</span><br><span class="line">            &#123;</span><br><span class="line">                currentAlloc = allocInst;</span><br><span class="line">                initMem2Reg();</span><br><span class="line">                insertPhi(); <span class="comment">// 在支配边界插入 Phi</span></span><br><span class="line">                renameVariables(currentFunction.getEntryBlock()); <span class="comment">// 变量重命名</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LoopUnroll"><a href="#LoopUnroll" class="headerlink" title="LoopUnroll"></a>LoopUnroll</h4><p>针对小循环进行完全展开，消除循环控制开销。我主要识别单回边、单基本块的简单循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryUnroll</span><span class="params">(LoopRecord loop)</span> &#123;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">header</span> <span class="operator">=</span> loop.getEntry();</span><br><span class="line">    <span class="comment">// 仅处理单回边的循环</span></span><br><span class="line">    <span class="keyword">if</span> (loop.getEnds().size() != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查循环结构（必须是条件跳转结尾）</span></span><br><span class="line">    <span class="type">Instruction</span> <span class="variable">term</span> <span class="operator">=</span> header.getLastInstruction();</span><br><span class="line">    <span class="keyword">if</span> (!(term <span class="keyword">instanceof</span> BrInst br) || !br.isConditional()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 识别归纳变量和步长</span></span><br><span class="line">    <span class="comment">// ... (代码省略：查找 Phi 节点和更新指令)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟循环执行，如果迭代次数在阈值内（MAX_TRIP_COUNT = 32），则进行展开</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PureFunctionEval"><a href="#PureFunctionEval" class="headerlink" title="PureFunctionEval"></a>PureFunctionEval</h4><p>这是一个比较有特色的优化，针对无副作用且参数为常量的函数调用，在编译期直接计算结果。这对于递归计算非常有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryEvaluateCall</span><span class="params">(CallInst callInst, BasicBlock block, Module <span class="keyword">module</span>)</span> &#123;</span><br><span class="line">    <span class="type">Function</span> <span class="variable">calledFunc</span> <span class="operator">=</span> callInst.getCalledFunction();</span><br><span class="line">    <span class="comment">// 检查是否是可求值的纯函数（无全局变量读写、无 IO）</span></span><br><span class="line">    <span class="keyword">if</span> (!calledFunc.canReplace()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查所有参数是否为常量</span></span><br><span class="line">    ArrayList&lt;Value&gt; params = callInst.getParameters();</span><br><span class="line">    ArrayList&lt;Integer&gt; constArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Value param : params) &#123;</span><br><span class="line">        <span class="keyword">if</span> (param <span class="keyword">instanceof</span> ConstInt constInt) &#123;</span><br><span class="line">            constArgs.add(constInt.getIntValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数不是常量，无法求值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试模拟执行并缓存结果</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 替换 call 为常量结果</span></span><br><span class="line">    <span class="type">ConstInt</span> <span class="variable">constResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstInt</span>(IntegerType.i32, result);</span><br><span class="line">    callInst.replaceByNewValue(constResult);</span><br><span class="line">    block.getInstructions().remove(callInst);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PeepHole"><a href="#PeepHole" class="headerlink" title="PeepHole"></a>PeepHole</h4><p>在后端生成汇编后，通过模式匹配消除冗余指令。例如，将“比较生成 0&#x2F;1”和“根据 0&#x2F;1 跳转”融合为一条条件跳转指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将“cmp 生成 0/1 + 分支判断该结果是否为 0”融合为一条直接分支。</span></span><br><span class="line"><span class="comment">* seq $t, $a, $b</span></span><br><span class="line"><span class="comment">* beq $t, 0, L =&gt; bne $a, $b, L</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fuseCmpAndBranchOnZero</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 遍历指令序列</span></span><br><span class="line">    <span class="keyword">if</span> (cur <span class="keyword">instanceof</span> BrAsm candidate</span><br><span class="line">    &amp;&amp; (candidate.getOp() == AsmOp.BEQ || candidate.getOp() == AsmOp.BNE)</span><br><span class="line">    &amp;&amp; candidate.getRs() == cmpAsm.getRd()) &#123;</span><br><span class="line">        <span class="comment">// 检查 cmp 结果是否只被该分支使用</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 替换为新的分支指令，直接比较原操作数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>2026年1月2日完稿</p>
</blockquote>
<p>感想具体可见总结感想，这里简单说两句。</p>
<p>整体做下来，我觉得这个项目最大的收益是把可调试性先立住：每个阶段都有明确的输入输出结构，并且都有对应的落盘结果可以看。这样不管是前端的缺符号、语义的某个错误码，还是后端寄存器&#x2F;栈偏移的问题，定位路径都会短很多。</p>
<p>编译器很有意思，写编译的过程也既痛苦又快乐，不过总之还是能学到很多有用的编译知识的，我很满意了。</p>
<p>感谢为我铺路的学长们，感谢伟大的助教和老师，感谢这门课！</p>
]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-北航编译技术实验文法定义及相关说明</title>
    <url>/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<blockquote>
<p>知识产权声明：以下内容由北航编译技术课程组提供，并非本人创作，本人只负责搬运，有任何问题请以课程组为准！！！</p>
</blockquote>
<h1 id="2025编译技术实验文法定义及相关说明"><a href="#2025编译技术实验文法定义及相关说明" class="headerlink" title="2025编译技术实验文法定义及相关说明"></a>2025编译技术实验文法定义及相关说明</h1><h2 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h2><p>SysY 语言是编译技术实验所完成的编译器的源语言，是 C 语言的一个子集。一个 SysY 语言源程序文件中有且仅有一个名为 <code>main</code> 的主函数定义，除此之外包含若干全局变量声明、常量声明和其他函数定义。SysY 语言支持 32 位有符号数 <code>int</code> 类型及其的一维数组类型；<code>const</code> 修饰符用于声明常量。</p>
<p>SysY 语言本身没有提供输入&#x2F;输出(I&#x2F;O)的语言构造，I&#x2F;O 是以运行时库方式提供，库函数可以在 SysY 程序中的函数内调用。部分 SysY 运行时库函数的参数类型会超出 SysY 支持的数据类型，如可以为字符串。SysY 编译器需要能处理这种情况，将 SysY 程序中这样的参数正确地传递给 SysY 运行时库。</p>
<ul>
<li><strong>函数</strong>：函数可以带参数也可以不带参数，参数的类型可以是 <code>int</code> 或其一维数组类型；函数可以返回 <code>int</code> 类型的值，或者不返回值（即声明为 <code>void</code> 类型）。当参数为 <code>int</code> 时，按值传递；而参数为数组类型时，实际传递的是数组的起始地址。函数体由若干变量声明和语句组成。</li>
<li><strong>变量&#x2F;常量声明</strong>：可以在一个变量&#x2F;常量声明语句中声明多个变量或常量，声明时可以带初始化表达式。所有变量&#x2F;常量要求先定义再使用。在函数外声明的为全局变量&#x2F;常量，在函数内声明的为局部变量&#x2F;常量。</li>
<li><strong>语句</strong>：语句包括赋值语句、表达式语句(表达式可以为空)、语句块、<code>if</code> 语句、<code>for</code> 语句、<code>break</code> 语句、<code>continue</code> 语句、<code>return</code> 语句。语句块中可以包含若干变量声明和语句。</li>
<li><strong>表达式</strong>：支持基本的算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）、关系运算（<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>）和逻辑运算（<code>!</code>、<code>&amp;&amp;</code>、<code>||</code>），非 0 表示真、0 表示假，而关系运算或逻辑运算的结果用 1 表示真、0 表示假。<strong>算符的优先级和结合性以及计算规则(含逻辑运算的“短路计算”)与 C 语言一致。</strong></li>
</ul>
<h2 id="二、运行时库"><a href="#二、运行时库" class="headerlink" title="二、运行时库"></a>二、运行时库</h2><p>源程序可通过 <code>getint</code> 与 <code>printf</code> 函数完成 I&#x2F;O 交互。<br>如果希望在 C 语言中测试测试程序，只需要将 <code>getint</code> 加入函数声明即可，示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(getchar()!=<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>printf</code> 函数的使用方法为 <code>&#39;printf&#39; &#39;(&#39; &lt;StringConst&gt; &#123;, &lt;Exp&gt;&#125; &#39;)&#39;</code> ，其中 <code>StringConst</code> 为字符串常量终结符，其规范参考第三章文法及测试程序覆盖要求的第三小节第五部分字符串常量。<code>&lt;StringConst&gt;</code> 的解析超出 SysY 支持的数据类型，SysY 编译器需要能处理这种情况。</p>
<h2 id="三、文法及测试程序覆盖要求"><a href="#三、文法及测试程序覆盖要求" class="headerlink" title="三、文法及测试程序覆盖要求"></a>三、文法及测试程序覆盖要求</h2><h3 id="1-覆盖要求"><a href="#1-覆盖要求" class="headerlink" title="1. 覆盖要求"></a>1. 覆盖要求</h3><p>测试程序是为了测试编译器而编写的符合文法规则的 SysY 语言程序，在实验的“文法解读作业”中需要同学们编写测试程序。测试程序需<strong>覆盖文法中所有的语法规则</strong>（即每一条推导规则的每一个候选项都要被覆盖），并<strong>满足文法的语义约束</strong>（换而言之，测试程序应该是正确的）。在下一节中，文法正文中以<strong>注释形式</strong>给出需要覆盖的情况。</p>
<h2 id="2-文法"><a href="#2-文法" class="headerlink" title="2. 文法"></a>2. 文法</h2><p>SysY 语言的文法采用扩展的 Backus 范式（EBNF，Extended Backus-Naur Form）表示，其中：</p>
<ul>
<li>符号 <code>[...]</code> 表示方括号内包含的为可选项</li>
<li>符号 <code>&#123;...&#125;</code> 表示花括号内包含的为可重复 0 次或多次的项</li>
<li>终结符或者是由单引号括起的串，或者是 <code>Ident</code>、<code>IntConst</code>、<code>StringConst</code> 这样的记号</li>
<li><strong>所有类似 <code>&#39;main&#39;</code> 这样的用单引号括起的字符串都是保留的关键字</strong></li>
</ul>
<p>SysY 语言的文法表示如下，其中 <code>CompUnit</code> 为开始符号：<br><strong>重要：建议同时对照文法第三部分的语义约束。</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line">1  编译单元 CompUnit → &#123;Decl&#125; &#123;FuncDef&#125; MainFuncDef // 1.是否存在Decl 2.是否存在FuncDef</span><br><span class="line">2</span><br><span class="line">3  声明 Decl → ConstDecl | VarDecl // 覆盖两种声明</span><br><span class="line">4</span><br><span class="line">5  常量声明 ConstDecl → &#x27;const&#x27; BType ConstDef &#123; &#x27;,&#x27; ConstDef &#125; &#x27;;&#x27; // 1.花括号内重复0次 2.花括号内重复多次</span><br><span class="line">6</span><br><span class="line">7  基本类型 BType → &#x27;int&#x27;</span><br><span class="line">8</span><br><span class="line">9  常量定义 ConstDef → Ident [ &#x27;[&#x27; ConstExp &#x27;]&#x27; ] &#x27;=<span class="string">&#x27; ConstInitVal // 包含普通变量、一维数组两种情况</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">11 常量初值 ConstInitVal → ConstExp | &#x27;</span>&#123;<span class="string">&#x27; [ ConstExp &#123; &#x27;</span>,<span class="string">&#x27; ConstExp &#125; ] &#x27;</span>&#125;<span class="string">&#x27; // 1.常表达式初值 2.一维数组初值</span></span><br><span class="line"><span class="string">12</span></span><br><span class="line"><span class="string">13 变量声明 VarDecl → [ &#x27;</span>static<span class="string">&#x27; ] BType VarDef &#123; &#x27;</span>,<span class="string">&#x27; VarDef &#125; &#x27;</span>;&#x27; // 1.花括号内重复0次 2.花括号内重复多次</span><br><span class="line">14</span><br><span class="line">15 变量定义 VarDef → Ident [ &#x27;[&#x27; ConstExp &#x27;]&#x27; ] | Ident [ &#x27;[&#x27; ConstExp &#x27;]&#x27; ] &#x27;=<span class="string">&#x27; InitVal // 包含普通变量、一维数组定义</span></span><br><span class="line"><span class="string">16</span></span><br><span class="line"><span class="string">17 变量初值 InitVal → Exp | &#x27;</span>&#123;<span class="string">&#x27; [ Exp &#123; &#x27;</span>,<span class="string">&#x27; Exp &#125; ] &#x27;</span>&#125;<span class="string">&#x27; // 1.表达式初值 2.一维数组初值</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">19 函数定义 FuncDef → FuncType Ident &#x27;</span>(<span class="string">&#x27; [FuncFParams] &#x27;</span>)<span class="string">&#x27; Block // 1.无形参 2.有形参</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">21 主函数定义 MainFuncDef → &#x27;</span>int<span class="string">&#x27; &#x27;</span>main<span class="string">&#x27; &#x27;</span>(<span class="string">&#x27; &#x27;</span>)<span class="string">&#x27; Block // 存在main函数</span></span><br><span class="line"><span class="string">22</span></span><br><span class="line"><span class="string">23 函数类型 FuncType → &#x27;</span>void<span class="string">&#x27; | &#x27;</span>int<span class="string">&#x27; // 覆盖两种类型的函数</span></span><br><span class="line"><span class="string">24</span></span><br><span class="line"><span class="string">25 函数形参表 FuncFParams → FuncFParam &#123; &#x27;</span>,<span class="string">&#x27; FuncFParam &#125; // 1.花括号内重复0次 2.花括号内重复多次</span></span><br><span class="line"><span class="string">26</span></span><br><span class="line"><span class="string">27 函数形参 FuncFParam → BType Ident [&#x27;</span>[<span class="string">&#x27; &#x27;</span>]<span class="string">&#x27;] // 1.普通变量 2.一维数组变量</span></span><br><span class="line"><span class="string">28</span></span><br><span class="line"><span class="string">29 语句块 Block → &#x27;</span>&#123;<span class="string">&#x27; &#123; BlockItem &#125; &#x27;</span>&#125;<span class="string">&#x27; // 1.花括号内重复0次 2.花括号内重复多次</span></span><br><span class="line"><span class="string">30</span></span><br><span class="line"><span class="string">31 语句块项 BlockItem → Decl | Stmt // 覆盖两种语句块项</span></span><br><span class="line"><span class="string">32</span></span><br><span class="line"><span class="string">33 语句 Stmt → LVal &#x27;</span>=<span class="string">&#x27; Exp &#x27;</span>;&#x27; // 每种类型的语句都要覆盖</span><br><span class="line">34 | [Exp] &#x27;;&#x27; // 有无Exp两种情况；printf函数调用</span><br><span class="line">35 | Block</span><br><span class="line">36 | &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt [ &#x27;else&#x27; Stmt ] // 1.有else 2.无else</span><br><span class="line">37 | &#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; Stmt // 1. 无缺省，1种情况 2. ForStmt与Cond中缺省一个，3种情况 3. ForStmt与Cond中缺省两个，3种情况 4. ForStmt与Cond全部缺省，1种情况</span><br><span class="line">38 | &#x27;break&#x27; &#x27;;&#x27;</span><br><span class="line">39 | &#x27;continue&#x27; &#x27;;&#x27;</span><br><span class="line">40 | &#x27;return&#x27; [Exp] &#x27;;&#x27; // 1.有Exp 2.无Exp</span><br><span class="line">41 | &#x27;printf&#x27;&#x27;(&#x27;StringConst &#123;&#x27;,&#x27;Exp&#125;&#x27;)&#x27;&#x27;;&#x27; // 1.有Exp 2.无Exp</span><br><span class="line">42</span><br><span class="line">43 语句 ForStmt → LVal &#x27;=<span class="string">&#x27; Exp &#123; &#x27;</span>,<span class="string">&#x27; LVal &#x27;</span>=<span class="string">&#x27; Exp &#125; // 1.花括号内重复0次 2.花括号内重复多次</span></span><br><span class="line"><span class="string">44</span></span><br><span class="line"><span class="string">45 表达式 Exp → AddExp // 存在即可</span></span><br><span class="line"><span class="string">46</span></span><br><span class="line"><span class="string">47 条件表达式 Cond → LOrExp // 存在即可</span></span><br><span class="line"><span class="string">48</span></span><br><span class="line"><span class="string">49 左值表达式 LVal → Ident [&#x27;</span>[<span class="string">&#x27; Exp &#x27;</span>]<span class="string">&#x27;] // 1.普通变量、常量 2.一维数组</span></span><br><span class="line"><span class="string">50</span></span><br><span class="line"><span class="string">51 基本表达式 PrimaryExp → &#x27;</span>(<span class="string">&#x27; Exp &#x27;</span>)<span class="string">&#x27; | LVal | Number</span></span><br><span class="line"><span class="string">52</span></span><br><span class="line"><span class="string">53 数值 Number → IntConst // 存在即可</span></span><br><span class="line"><span class="string">54</span></span><br><span class="line"><span class="string">55 一元表达式 UnaryExp → PrimaryExp | Ident &#x27;</span>(<span class="string">&#x27; [FuncRParams] &#x27;</span>)<span class="string">&#x27; | UnaryOp UnaryExp // 3种情况均需覆盖,函数调用也需要覆盖FuncRParams的不同情况</span></span><br><span class="line"><span class="string">56</span></span><br><span class="line"><span class="string">57 单目运算符 UnaryOp → &#x27;</span>+<span class="string">&#x27; | &#x27;</span>−<span class="string">&#x27; | &#x27;</span>!<span class="string">&#x27; 注：&#x27;</span>!<span class="string">&#x27;仅出现在条件表达式中 // 三种均需覆盖</span></span><br><span class="line"><span class="string">58</span></span><br><span class="line"><span class="string">59 函数实参表达式 FuncRParams → Exp &#123; &#x27;</span>,<span class="string">&#x27; Exp &#125; // 1.花括号内重复0次 2.花括号内重复多次 3.Exp需要覆盖数组传参和部分数组传参</span></span><br><span class="line"><span class="string">60</span></span><br><span class="line"><span class="string">61 乘除模表达式 MulExp → UnaryExp | MulExp (&#x27;</span>*<span class="string">&#x27; | &#x27;</span>/<span class="string">&#x27; | &#x27;</span>%<span class="string">&#x27;) UnaryExp // 1.UnaryExp 2.* 3./ 4.% 均需覆盖</span></span><br><span class="line"><span class="string">62</span></span><br><span class="line"><span class="string">63 加减表达式 AddExp → MulExp | AddExp (&#x27;</span>+<span class="string">&#x27; | &#x27;</span>−<span class="string">&#x27;) MulExp // 1.MulExp 2.+ 需覆盖 3.- 需覆盖</span></span><br><span class="line"><span class="string">64</span></span><br><span class="line"><span class="string">65 关系表达式 RelExp → AddExp | RelExp (&#x27;</span>&lt;<span class="string">&#x27; | &#x27;</span>&gt;<span class="string">&#x27; | &#x27;</span>&lt;=<span class="string">&#x27; | &#x27;</span>&gt;=<span class="string">&#x27;) AddExp // 1.AddExp 2.&lt; 3.&gt; 4.&lt;= 5.&gt;= 均需覆盖</span></span><br><span class="line"><span class="string">66</span></span><br><span class="line"><span class="string">67 相等性表达式 EqExp → RelExp | EqExp (&#x27;</span>==<span class="string">&#x27; | &#x27;</span>!=<span class="string">&#x27;) RelExp // 1.RelExp 2.== 3.!= 均需覆盖</span></span><br><span class="line"><span class="string">68</span></span><br><span class="line"><span class="string">69 逻辑与表达式 LAndExp → EqExp | LAndExp &#x27;</span>&amp;&amp;<span class="string">&#x27; EqExp // 1.EqExp 2.&amp;&amp; 均需覆盖</span></span><br><span class="line"><span class="string">70</span></span><br><span class="line"><span class="string">71 逻辑或表达式 LOrExp → LAndExp | LOrExp &#x27;</span>||<span class="string">&#x27; LAndExp // 1.LAndExp 2.|| 均需覆盖</span></span><br><span class="line"><span class="string">72</span></span><br><span class="line"><span class="string">73 常量表达式 ConstExp → AddExp 注：使用的 Ident 必须是常量 // 存在即可</span></span><br></pre></td></tr></table></figure>

<h2 id="3-补充说明"><a href="#3-补充说明" class="headerlink" title="3. 补充说明"></a>3. 补充说明</h2><h3 id="1-标识符-Ident"><a href="#1-标识符-Ident" class="headerlink" title="(1) 标识符 Ident"></a>(1) 标识符 Ident</h3><p>SysY 语言中标识符 <code>Ident</code> 的规范如下 ( identifier ) ：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">identifier</span> → identifier-nondigit</span><br><span class="line">           | identifier identifier-nondigit</span><br><span class="line">           | identifier digit</span><br></pre></td></tr></table></figure>

<p>其中，<code>identifier-nondigit</code> 为下划线或大小写字母，<code>digit</code> 为 0 到 9 的数字。</p>
<p><strong>注</strong>：请参考 ISO&#x2F;IEC 9899 <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf</a> 第 51 页关于标识符的定义<strong>同名标识符</strong>的约定：</p>
<ul>
<li>全局变量（常量）和局部变量（常量）的作用域可以重叠，重叠部分局部变量（常量）优先；</li>
<li>同名局部变量的作用域不能重叠，即同一个 <code>Block</code> 内不能有同名的标识符（常量&#x2F;变量）；</li>
<li>在不同的作用域下，SysY 语言中变量（常量）名可以与函数名相同；</li>
<li>保留关键字不能作为标识符。</li>
</ul>
<p><strong>合法样例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a); <span class="comment">// 输出 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非法样例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">2</span>; <span class="comment">// 非法！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-注释"><a href="#2-注释" class="headerlink" title="(2) 注释"></a>(2) 注释</h3><p>SysY 语言中注释的规范与 C 语言一致，如下：</p>
<ul>
<li><strong>单行注释</strong>：以序列 <code>//</code> 开始，直到换行符结束，不包括换行符。</li>
<li><strong>多行注释</strong>：以序列 <code>/*</code> 开始，直到第一次出现 <code>*/</code> 时结束，包括结束处 <code>*/</code>。</li>
</ul>
<p><strong>注</strong>：请参考 ISO&#x2F;IEC 9899 第 66 页关于注释的定义。</p>
<h3 id="3-数值常量"><a href="#3-数值常量" class="headerlink" title="(3) 数值常量"></a>(3) 数值常量</h3><p>SysY 语言中数值常量可以是整型数 <code>IntConst</code>，其规范如下（对应 <code>integer-const</code>）：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line">整型常量 integer-const → decimal-const | 0</span><br><span class="line"><span class="attribute">decimal-const</span> → nonzero-digit | decimal-const digit</span><br><span class="line"><span class="attribute">nonzero-digit</span> 为1至9的数字。</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：请参考 ISO&#x2F;IEC 9899 第 54 页关于整型常量的定义，在此基础上忽略所有后缀。</p>
<h3 id="4-字符串常量"><a href="#4-字符串常量" class="headerlink" title="(4) 字符串常量"></a>(4) 字符串常量</h3><p>SysY 语言中 <code>&lt;StringConst&gt;</code> 的定义如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line">&lt;FormatChar&gt; → %d</span><br><span class="line">&lt;NormalChar&gt; → 十进制编码为32,33,35-126的ASCII字符，&#x27;\&#x27;（编码92）出现当且仅当为&#x27;\n&#x27;</span><br><span class="line">&lt;Char&gt; → &lt;FormatChar&gt; | &lt;NormalChar&gt;</span><br><span class="line">&lt;StringConst&gt; → &#x27;&quot;&#x27;&#123;&lt;Char&gt;&#125;&#x27;&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>字符串中<strong>仅可能会出现一种转义字符 <code>\n</code></strong>，用以标注此处换行，其他转义情况无需考虑。</p>
<h2 id="4-难度分级"><a href="#4-难度分级" class="headerlink" title="4. 难度分级"></a>4. 难度分级</h2><p>为了更好的帮助同学们完成编译器的设计，课程组将题目难度做了区分。难度等级分为三级：A、B、C，难度依次递减：</p>
<ul>
<li><strong>C</strong>：最简单的等级，重点考察编译器的基础设计，不包括任何与数组有关的部分，<code>if</code> 与 <code>for</code> 中的条件表达式也只有一个表达式（即不出现 <code>&amp;&amp;</code> 和 <code>||</code> ）不考察短路求值的规则。</li>
<li><strong>B</strong>：在 C 级的基础上，<strong>新增数组</strong>，包括数组定义，数组元素的使用、数组传参等。</li>
<li><strong>A</strong>：在 B 级的基础上，<strong>新增复杂条件的运算和判断</strong>，要遵守短路求值的规则。<ul>
<li>短路求值样例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    global_var = global_var + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &amp;&amp; func())&#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,global_var); <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> || func()) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,global_var); <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四、语义约束"><a href="#四、语义约束" class="headerlink" title="四、语义约束"></a>四、语义约束</h2><p>符合上述文法的程序集合是合法的 SysY 语言程序集合的超集。下面进一步给出 SysY 语言的语义约束。</p>
<h3 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h3><ol>
<li><strong>为了降低开发难度，保证所有测试程序中 <code>getint</code> 与 <code>printf</code> 只会作为运行时库调用出现，不会作为自定义的变量&#x2F;函数标识符。</strong></li>
<li><code>printf</code> 函数默认不换行。</li>
<li>与 C 语言中的 <code>printf</code> 类似，输出语句中，格式字符将被替换为对应标识符，普通字符原样输出。</li>
</ol>
<h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><ol>
<li><code>static</code> 关键字用于修饰<strong>静态局部变量</strong>，不会在全局变量定义中出现。</li>
<li>用 <code>static</code> 修饰的变量声明，若带有初始值，则初始值可在编译期内求出。</li>
<li>用 <code>static</code> 修饰的变量声明，即使在声明时未赋初值，编译器也会把它初始化为 0。</li>
<li><code>static</code> 关键字指定的变量只初始化一次，并在之后<strong>调用该函数时保留其状态</strong>，离开函数时不会被销毁。但其修饰的变量作用域被限制在声明此变量的函数内部。</li>
</ol>
<h3 id="编译单元-CompUnit"><a href="#编译单元-CompUnit" class="headerlink" title="编译单元 CompUnit"></a>编译单元 CompUnit</h3><ol>
<li><code>CompUnit</code> 的<strong>顶层</strong>变量&#x2F;常量声明语句（对应 <code>Decl</code> ）、函数定义（对应 <code>FuncDef</code> ）都不可以重复定义同名标识符（ <code>Ident</code> ），即便标识符的类型不同也不允许。</li>
<li><code>CompUnit</code> 的变量&#x2F;常量&#x2F;函数声明的作用域从该声明处开始到文件结尾。</li>
</ol>
<h3 id="常量定义-ConstDef"><a href="#常量定义-ConstDef" class="headerlink" title="常量定义 ConstDef"></a>常量定义 ConstDef</h3><ol>
<li><code>ConstDef</code> 用于定义符号常量。<code>ConstDef</code> 中的 <code>Ident</code> 为常量的标识符，在 <code>Ident</code> 后、<code>=</code> 之前是可选的一维数组以及一维数组长度的定义部分，在 <code>=</code> 之后是初始值。<strong>常量必须有对应的初始值</strong>。</li>
<li><code>ConstDef</code> 的一维数组以及一维数组长度的定义部分不存在时，表示定义单个变量。</li>
<li><code>ConstDef</code> 的一维数组以及一维数组长度的定义部分存在时，表示定义数组。其语义和 C 语言一致，每维的下界从 0 编号。</li>
<li><code>ConstDef</code> 中表示各维长度的 <code>ConstExp</code> 都<strong>必须能在编译时求值到非负整数</strong>。</li>
</ol>
<h3 id="变量定义-VarDef"><a href="#变量定义-VarDef" class="headerlink" title="变量定义 VarDef"></a>变量定义 VarDef</h3><ol>
<li>变量的定义与常量基本一致，但是变量可以没有初始值部分，此时其运行时实际初值未定义。</li>
</ol>
<h3 id="初值-ConstInitVal-InitVal"><a href="#初值-ConstInitVal-InitVal" class="headerlink" title="初值 ConstInitVal &#x2F; InitVal"></a>初值 ConstInitVal &#x2F; InitVal</h3><ol>
<li>任何常量的初值表达式必须是常量表达式 <code>ConstExp</code>。</li>
<li><strong>常量必须有初始值</strong>，常量数组不需要每一个元素都有初始值，但是未赋值的部分编译器需要将其置 0。</li>
<li>全局变量的初值表达式也必须是常量表达式 <code>ConstExp</code>。但局部变量的初值表达式是 <code>Exp</code>，可以使用已经声明的变量。</li>
<li>对于单个的常量或变量，初始值也必须是单个的表达式。（表达式包括单个数字、单个变量、单个常量等情况）</li>
<li><strong>对于全局变量，如果没有给出初始值，那么应该全部置 0</strong>，局部变量不需要。</li>
</ol>
<h3 id="函数形参-FuncFParam-与实参-FuncRParams"><a href="#函数形参-FuncFParam-与实参-FuncRParams" class="headerlink" title="函数形参 FuncFParam 与实参 FuncRParams"></a>函数形参 FuncFParam 与实参 FuncRParams</h3><ol>
<li><p><code>FuncFParam</code> 定义一个函数的一个形式参数。当 <code>Ident</code> 后面的可选部分存在时， 表示数组定义。</p>
</li>
<li><p>函数实参的语法是 <code>Exp</code>。对于普通变量，遵循按值传递；对于数组类型的参数，则形参接收的是实参数组的地址，并通过地址间接访问实参数组中的元素。</p>
</li>
<li><p>普通常量可以作为函数参数，但是常量数组不可以，如 <code>const int arr[3] = &#123;1,2,3&#125;</code> ，常量数组 <code>arr</code> <strong>不能</strong>作为参数传入到函数中。</p>
</li>
<li><p>函数调用时要保证实参类型和形参类型一致，具体请看下面例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> x[])</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> t[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    f1(x); <span class="comment">// 合法</span></span><br><span class="line">    f1(t[<span class="number">0</span>]); <span class="comment">// 合法</span></span><br><span class="line">    f1(t); <span class="comment">// 不合法</span></span><br><span class="line">    f2(t); <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="函数定义-FuncDef"><a href="#函数定义-FuncDef" class="headerlink" title="函数定义 FuncDef"></a>函数定义 FuncDef</h3><ol>
<li><code>FuncDef</code> 表示函数定义。其中的 <code>FuncType</code> 指明返回类型。当返回类型为 <code>int</code> 时，函数内所有分支都应当含有带有 <code>Exp</code> 的 <code>return</code> 语句。不含有 <code>return</code> 语句的分支的返回值未定义。当返回值类型为 <code>void</code> 时，函数内只能出现不带返回值的 <code>return</code> 语句。</li>
<li><code>FuncFParams</code> 的语义如前文。</li>
</ol>
<h3 id="语句块-Block"><a href="#语句块-Block" class="headerlink" title="语句块 Block"></a>语句块 Block</h3><ol>
<li><code>Block</code> 表示语句块。语句块会创建作用域，语句块内声明的常量和变量的生存期在该语句块内。</li>
<li>语句块内可以再次定义与语句块外同名的变量或常量（通过 <code>Decl</code> 语句)，其作用域从定义处开始到该语句块尾结束，它隐藏语句块外的同名变量或常量。</li>
<li>为了降低开发难度，<strong>保证所有测试程序中有返回值的函数 <code>Block</code> 的最后一句一定会显式的给出 <code>return</code> 语句，否则就当作“无返回语句”的错误处理</strong>。同时，同学们编写上传的样例程序时，也需要保证这一点。</li>
<li><code>main</code> 函数的返回值只能为常数 0。</li>
</ol>
<h3 id="语句-Stmt"><a href="#语句-Stmt" class="headerlink" title="语句 Stmt"></a>语句 Stmt</h3><ol>
<li><code>Stmt</code> 中的 <code>if</code> 类型语句遵循就近匹配。</li>
<li>单个 <code>Exp</code> 可以作为 <code>Stmt</code>。这个 <code>Exp</code> 会被求值，但是所求的值会被丢弃。</li>
</ol>
<h3 id="左值-LVal"><a href="#左值-LVal" class="headerlink" title="左值 LVal"></a>左值 LVal</h3><ol>
<li><code>LVal</code> 表示具有左值的表达式，可以为变量或者某个数组元素。</li>
<li>当 <code>LVal</code> 表示数组时，方括号个数必须和数组变量的维数相同（即定位到元素）。</li>
<li>当 <code>LVal</code> 表示单个变量时，不能出现后面的方括号。</li>
</ol>
<h3 id="Exp-与-Cond"><a href="#Exp-与-Cond" class="headerlink" title="Exp 与 Cond"></a>Exp 与 Cond</h3><ol>
<li><strong><code>Exp</code> 在 SysY 中代表 <code>int</code> 型或 <code>void</code> 型的表达式；<code>Cond</code> 代表条件表达式，故它定义为 <code>LOrExp</code>。前者的单目运算符中不出现 <code>!</code>，后者可以出现。</strong></li>
<li><code>LVal</code> 必须是当前作用域内、该 <code>Exp</code> 语句之前有定义的变量或常量；对于赋值号左边的 <code>LVal</code> 必须是变量。</li>
<li>函数调用形式是 <code>Ident ‘(’ FuncRParams ‘)’</code>，其中的 <code>FuncRParams</code> 表示实际参数。实际参数的类型和个数必须与 <code>Ident</code> 对应的函数定义的形参完全匹配。</li>
<li>SysY 中算符的优先级与结合性与 C 语言一致，在上面的 SysY 文法中已体现出优先级与结合性的定义。</li>
</ol>
<h3 id="一元表达式-UnaryExp"><a href="#一元表达式-UnaryExp" class="headerlink" title="一元表达式 UnaryExp"></a>一元表达式 UnaryExp</h3><ol>
<li>相邻两个 <code>UnaryOp</code> 不能相同，如 <code>int a = ++-i;</code>，但是 <code>int a = +-+i;</code> 是可行的。</li>
<li><code>UnaryOp</code> 为 <code>&#39;!&#39;</code> 只能出现在条件表达式中。</li>
</ol>
<h3 id="常量表达式-ConstExp"><a href="#常量表达式-ConstExp" class="headerlink" title="常量表达式 ConstExp"></a>常量表达式 ConstExp</h3><ol>
<li><strong><code>ConstExp</code> 在 SysY 中代表 <code>int</code> 型表达式。</strong></li>
<li><code>ConstExp</code> 在编译期内是可被求值的，<code>ConstExp -&gt; AddExp</code> 中涉及到的的 <code>ident</code> 均必须是常量，即只能使用常数、可以取得具体值的常量以及由它们组成的、在编译器内可被求值的算术表达式。</li>
</ol>
<h2 id="六、错误处理"><a href="#六、错误处理" class="headerlink" title="六、错误处理"></a>六、错误处理</h2><p><strong>以下内容是为了词法分析及以后的实验作业准备的，在完成文法解读作业时请编写符合上面文法的正确的源程序！</strong></p>
<p>从词法分析作业开始，我们每次作业都要求同学们开发的编译能够处理正确的程序与错误的程序，对于正确的程序按照每次作业要求输出正确结果，对于错误的程序输出所有的错误的行号和错误类别码。</p>
<p>错误主要分为三类，词法分析部分错误，语法分析部分错误，语义分析部分错误。同学们在涉及编译器时，应该完成这三个部分的所有错误处理之后再进行错误的输出。</p>
<p><strong>后续实验中，对于错误的源程序完成语义分析后不进行中间代码生成。</strong></p>
<h3 id="错误类型列表"><a href="#错误类型列表" class="headerlink" title="错误类型列表"></a>错误类型列表</h3><p>错误类别 <code>a</code> 为词法分析中会出现的错误。<br>错误类别 <code>i, j, k</code> 为语法分析中会出现的错误。<br>剩余错误类别均为语义分析中会出现的错误。</p>
<table>
<thead>
<tr>
<th align="left">错误类型</th>
<th align="left">错误类别码</th>
<th align="left">解释</th>
<th align="left">对应文法及出错符号，…表示省略该条规则其他部分</th>
</tr>
</thead>
<tbody><tr>
<td align="left">非法符号</td>
<td align="left">a</td>
<td align="left">出现了 <code>&amp;</code> 和 <code>|</code> 这两个符号，应该将其当做 <code>&amp;&amp;</code> 与 <code>||</code> 进行处理，但是在记录单词名称的时候仍记录 <code>&amp;</code> 和 <code>|</code>， <strong>报错行号为 <code>&amp;</code> 或 <code>|</code> 所在的行号</strong>。</td>
<td align="left"><code>LAndExp → LAndExp &#39;&amp;&amp;&#39; EqExp</code><br><code>LOrExp → LOrExp &#39;||&#39; LAndExp</code></td>
</tr>
<tr>
<td align="left">名字重定义</td>
<td align="left">b</td>
<td align="left">函数名或者变量名在<strong>当前作用域</strong>下重复定义。<br>注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。<br>报错行号 <code>Ident</code> 所在行数。</td>
<td align="left"><code>ConstDef → Ident …</code><br><code>VarDef → … Ident … Ident …</code><br><code>FuncDef → FuncType Ident …</code><br><code>FuncFParam → BType Ident ...</code></td>
</tr>
<tr>
<td align="left">未定义的名字</td>
<td align="left">c</td>
<td align="left">使用了未定义的标识符报错行号为 <code>Ident</code> 所在行数。</td>
<td align="left"><code>LVal → Ident …</code><br><code>UnaryExp → Ident …</code></td>
</tr>
<tr>
<td align="left">函数参数个数不匹配</td>
<td align="left">d</td>
<td align="left">函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的<strong>函数名</strong>所在行数。</td>
<td align="left"><code>UnaryExp → Ident ‘(’ [ FuncRParams ] ‘)’</code></td>
</tr>
<tr>
<td align="left">函数参数类型不匹配</td>
<td align="left">e</td>
<td align="left">函数调用语句中，参数类型与函数定义中对应位置的参数类型不匹配。报错行号为函数调用语句的<strong>函数名</strong>所在行数。<strong>关于参数类型不匹配会在下方特别说明进行详细说明。</strong></td>
<td align="left"><code>UnaryExp → Ident ‘(’ [ FuncRParams ] ‘)’</code></td>
</tr>
<tr>
<td align="left">无返回值的函数存在不匹配的return语句</td>
<td align="left">f</td>
<td align="left">报错行号为<code>return</code>所在行号。</td>
<td align="left"><code>Stmt → ‘return’ &#123; ‘[’ Exp ’]’ &#125; ‘;’</code></td>
</tr>
<tr>
<td align="left">有返回值的函数缺少return语句</td>
<td align="left">g</td>
<td align="left">只需要考虑函数末尾是否存在return语句，<strong>无需考虑控制流</strong>。报错行号为函数结尾的<code>&#125;</code>所在行号。</td>
<td align="left"><code>FuncDef → FuncType Ident ‘(’ [FuncFParams] ‘)’ Block</code><br><code>MainFuncDef → &#39;int&#39; &#39;main&#39; &#39;(&#39; &#39;)&#39; Block</code></td>
</tr>
<tr>
<td align="left">不能改变常量的值</td>
<td align="left">h</td>
<td align="left"><code>LVal</code> 为常量时，不能对其修改。报错行号为 <code>LVal</code> 所在行号。</td>
<td align="left"><code>Stmt → LVal ‘=’ Exp ‘;’</code><br><code>ForStmt → LVal &#39;=&#39; Exp …</code></td>
</tr>
<tr>
<td align="left">缺少分号</td>
<td align="left">i</td>
<td align="left">报错行号为分号<strong>前一个非终结符</strong>所在行号。</td>
<td align="left"><code>Stmt, ConstDecl 及 VarDecl</code> 中的 <code>&#39;;’</code></td>
</tr>
<tr>
<td align="left">缺少右小括号’)’</td>
<td align="left">j</td>
<td align="left">报错行号为右小括号<strong>前一个非终结符</strong>所在行号。</td>
<td align="left">函数调用 (<code>UnaryExp</code>)、函数定义 (<code>FuncDef, MainFuncDef</code>)、 <code>Stmt</code> 及 <code>PrimaryExp</code> 中的 <code>&#39;)’</code></td>
</tr>
<tr>
<td align="left">缺少右中括号’]’</td>
<td align="left">k</td>
<td align="left">报错行号为右中括号<strong>前一个非终结符</strong>所在行号。</td>
<td align="left">数组定义 (<code>ConstDef, VarDef, FuncFParam</code>) 和使用 (<code>LVal</code>) 中的 <code>&#39;]’</code></td>
</tr>
<tr>
<td align="left">printf中格式字符与表达式个数不匹配</td>
<td align="left">l</td>
<td align="left">报错行号为<code>printf</code>所在行号。</td>
<td align="left"><code>&#39;printf&#39; &#39;(&#39; StringConst &#123;&#39;,&#39; Exp&#125; &#39;)&#39; &#39;;&#39;</code></td>
</tr>
<tr>
<td align="left">在非循环块中使用break和continue语句</td>
<td align="left">m</td>
<td align="left">报错行号为 <code>break</code> 与 <code>continue</code> 所在行号。</td>
<td align="left"><code>Stmt → ‘break’ ‘;’|‘continue’ ‘;’</code></td>
</tr>
</tbody></table>
<h3 id="错误输出示例"><a href="#错误输出示例" class="headerlink" title="错误输出示例"></a>错误输出示例</h3><p><strong>输出结构</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">错误的行号 错误的类别码（中间仅用一个空格间隔）</span><br></pre></td></tr></table></figure>

<p><strong>样例输入</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> const1 = <span class="number">1</span>, const2 = <span class="number">-100</span>;</span><br><span class="line"><span class="type">int</span> change1;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gets1</span><span class="params">(<span class="type">int</span> var1,<span class="type">int</span> var2)</span>&#123;</span><br><span class="line">    const1 = <span class="number">999</span>;</span><br><span class="line">    change1 = var1 + var2</span><br><span class="line">    <span class="keyword">return</span> (change1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    change1 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>样例输出</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 h</span><br><span class="line">5 i</span><br></pre></td></tr></table></figure>

<h3 id="文法符号与错误类型对应"><a href="#文法符号与错误类型对应" class="headerlink" title="文法符号与错误类型对应"></a>文法符号与错误类型对应</h3><p>为方便对照, 下文给出了文法符号与可能存在的错误的对应关系:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line">编译单元 CompUnit → &#123;Decl&#125; &#123;FuncDef&#125; MainFuncDef</span><br><span class="line"></span><br><span class="line">声明 Decl → ConstDecl | VarDecl</span><br><span class="line"></span><br><span class="line">常量声明 ConstDecl → &#x27;const&#x27; BType ConstDef &#123; &#x27;,&#x27; ConstDef &#125; &#x27;;&#x27; // i</span><br><span class="line"></span><br><span class="line">基本类型 BType → &#x27;int&#x27;</span><br><span class="line"></span><br><span class="line">常量定义 ConstDef → Ident [ &#x27;[&#x27; ConstExp &#x27;]&#x27; ] &#x27;=<span class="string">&#x27; ConstInitVal // b, k</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">常量初值 ConstInitVal → ConstExp | &#x27;</span>&#123;<span class="string">&#x27; [ ConstExp &#123; &#x27;</span>,<span class="string">&#x27; ConstExp &#125; ] &#x27;</span>&#125;<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">变量声明 VarDecl → [ &#x27;</span>static<span class="string">&#x27; ] BType VarDef &#123; &#x27;</span>,<span class="string">&#x27; VarDef &#125; &#x27;</span>;&#x27; // i</span><br><span class="line"></span><br><span class="line">变量定义 VarDef → Ident [ &#x27;[&#x27; ConstExp &#x27;]&#x27; ] | Ident [ &#x27;[&#x27; ConstExp &#x27;]&#x27; ] &#x27;=<span class="string">&#x27; InitVal // b, k</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">变量初值 InitVal → Exp | &#x27;</span>&#123;<span class="string">&#x27; [ Exp &#123; &#x27;</span>,<span class="string">&#x27; Exp &#125; ] &#x27;</span>&#125;<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">函数定义 FuncDef → FuncType Ident &#x27;</span>(<span class="string">&#x27; [FuncFParams] &#x27;</span>)<span class="string">&#x27; Block // b, g, j</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">主函数定义 MainFuncDef → &#x27;</span>int<span class="string">&#x27; &#x27;</span>main<span class="string">&#x27; &#x27;</span>(<span class="string">&#x27; &#x27;</span>)<span class="string">&#x27; Block // g j</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">函数类型 FuncType → &#x27;</span>void<span class="string">&#x27; | &#x27;</span>int<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">函数形参表 FuncFParams → FuncFParam &#123; &#x27;</span>,<span class="string">&#x27; FuncFParam &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">函数形参 FuncFParam → BType Ident [&#x27;</span>[<span class="string">&#x27; &#x27;</span>]<span class="string">&#x27;] // b, k</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">语句块 Block → &#x27;</span>&#123;<span class="string">&#x27; &#123; BlockItem &#125; &#x27;</span>&#125;<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">语句块项 BlockItem → Decl | Stmt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">语句 Stmt → LVal &#x27;</span>=<span class="string">&#x27; Exp &#x27;</span>;&#x27; // h, i</span><br><span class="line">| [Exp] &#x27;;&#x27; // i, l(printf 被调用时)</span><br><span class="line">| Block</span><br><span class="line">| &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt [ &#x27;else&#x27; Stmt ] // j</span><br><span class="line">| &#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; Stmt // h</span><br><span class="line">| &#x27;break&#x27; &#x27;;&#x27; | &#x27;continue&#x27; &#x27;;&#x27; // i m</span><br><span class="line">| &#x27;return&#x27; [Exp] &#x27;;&#x27; // f i</span><br><span class="line">| &#x27;printf&#x27;&#x27;(&#x27;StringConst &#123;&#x27;,&#x27;Exp&#125;&#x27;)&#x27;&#x27;;&#x27; // i j l</span><br><span class="line"></span><br><span class="line">语句 ForStmt → LVal &#x27;=<span class="string">&#x27; Exp &#123; &#x27;</span>,<span class="string">&#x27; LVal &#x27;</span>=<span class="string">&#x27; Exp &#125; // h</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">表达式 Exp → AddExp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">条件表达式 Cond → LOrExp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">左值表达式 LVal → Ident [&#x27;</span>[<span class="string">&#x27; Exp &#x27;</span>]<span class="string">&#x27;] // c k</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">基本表达式 PrimaryExp → &#x27;</span>(<span class="string">&#x27; Exp &#x27;</span>)<span class="string">&#x27; | LVal | Number // j</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数值 Number → IntConst</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">一元表达式 UnaryExp → PrimaryExp | Ident &#x27;</span>(<span class="string">&#x27; [FuncRParams] &#x27;</span>)<span class="string">&#x27; | UnaryOp UnaryExp // c d e j</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">单目运算符 UnaryOp → &#x27;</span>+<span class="string">&#x27; | &#x27;</span>−<span class="string">&#x27; | &#x27;</span>!<span class="string">&#x27; 注：&#x27;</span>!<span class="string">&#x27;仅出现在条件表达式中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">函数实参表 FuncRParams → Exp &#123; &#x27;</span>,<span class="string">&#x27; Exp &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">乘除模表达式 MulExp → UnaryExp | MulExp (&#x27;</span>*<span class="string">&#x27; | &#x27;</span>/<span class="string">&#x27; | &#x27;</span>%<span class="string">&#x27;) UnaryExp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">加减表达式 AddExp → MulExp | AddExp (&#x27;</span>+<span class="string">&#x27; | &#x27;</span>−<span class="string">&#x27;) MulExp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">关系表达式 RelExp → AddExp | RelExp (&#x27;</span>&lt;<span class="string">&#x27; | &#x27;</span>&gt;<span class="string">&#x27; | &#x27;</span>&lt;=<span class="string">&#x27; | &#x27;</span>&gt;=<span class="string">&#x27;) AddExp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">相等性表达式 EqExp → RelExp | EqExp (&#x27;</span>==<span class="string">&#x27; | &#x27;</span>!=<span class="string">&#x27;) RelExp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">逻辑与表达式 LAndExp → EqExp | LAndExp &#x27;</span>&amp;&amp;<span class="string">&#x27; EqExp // a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">逻辑或表达式 LOrExp → LAndExp | LOrExp &#x27;</span>||<span class="string">&#x27; LAndExp // a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">常量表达式 ConstExp → AddExp 注：使用的 Ident 必须是常量</span></span><br></pre></td></tr></table></figure>

<h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><ol>
<li>错误 <code>i, j, k</code> 类型中的“前一个非终结符”强调的是在文法规则里出现在 <code>;</code> <code>)</code> <code>]</code> 之前的非终结符号，在分析中处理的是该非终结符产生的终结符号串的最后一个符号，也就是 <code>;</code> <code>)</code> <code>]</code> 本应该正常出现的位置的上一个单词。</li>
<li>所有错误都不会出现恶意换行的情况，包括字符、字符串中的换行符、函数调用等等。所谓恶意换行是指<strong>会使得错误处理难以正确进行的换行</strong>。</li>
<li>其他类型的错误，错误的行号以能够断定发现出错的第一个符号的行号为准。例如有返回值的函数缺少返回语句的错误，只有当识别到函数末尾的 <code>&#125;</code> 时仍未出现返回语句，才可以断定出错，报错行号即为 <code>&#125;</code> 的行号。</li>
<li>为了避免因为测试程序中的错误导致出现语法二义性，使得语法树以错误的方式建立，我们保证：<strong><code>for</code> 语句不会出现除了 <code>h</code> 类型以外的任何错误</strong>。进一步的，我们保证，<strong>所有会导致语法树不能正确建立的错误都不会出现</strong>。</li>
<li>每一行中最多只有一个错误。</li>
<li><strong>同一作用域下函数和变量之间不能有相同的名字</strong>。</li>
<li>对于一个名字重定义的函数，也应该完整分析函数内部是否具有其它错误。</li>
<li>对于调用函数时，参数类型不匹配一共有以下几种情况的不匹配：<ul>
<li>传递数组给变量。</li>
<li>传递变量给数组。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-北航编译技术优化文章</title>
    <url>/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>对于优化，主要分为两个阶段的优化：中端和后端。中端对中间代码先进行优化，随后由后端生成目标代码，再由后端优化代码进行进一步的优化。</p>
<p>核心的优化工作主要集中在以下三个方面：</p>
<ol>
<li><strong>mem2reg</strong>：将内存变量提升为 SSA 寄存器形式，减少 load&#x2F;store 指令。</li>
<li><strong>removePhi</strong>：将 Phi 指令转化为 Move 指令，以便后端 MIPS 翻译。</li>
<li><strong>regAlloc</strong>：使用图着色算法进行寄存器分配。</li>
</ol>
<p>此外，为了支撑这些核心优化，还实现了一些基础的 Pass，如死代码删除、CFG 构建、支配关系分析等。</p>
<h2 id="中端优化"><a href="#中端优化" class="headerlink" title="中端优化"></a>中端优化</h2><p>中端优化即机器无关优化，主要针对 LLVM IR 进行处理。</p>
<h3 id="死代码删除"><a href="#死代码删除" class="headerlink" title="死代码删除"></a>死代码删除</h3><p>死代码删除分为两层：删除不可达基本块和删除无用指令。</p>
<h4 id="删不可达基本块"><a href="#删不可达基本块" class="headerlink" title="删不可达基本块"></a>删不可达基本块</h4><p><code>SurplusBlock</code> 的实现基于图的可达性分析：从入口块出发进行 DFS，标记所有可达的块，最后将未被标记的块从函数中移除。同时，还需要清理跳转指令之后的无用指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从入口块开始DFS</span></span><br><span class="line">visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">dfs(func.getEntryBlock());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除未访问到的块</span></span><br><span class="line">func.getBasicBlocks().removeIf(block -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited.contains(block)) &#123;</span><br><span class="line">        block.getInstructions().forEach(Instruction::removeOperands);</span><br><span class="line">        block.removeOperands();</span><br><span class="line">        block.setDeleted(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="删无用指令"><a href="#删无用指令" class="headerlink" title="删无用指令"></a>删无用指令</h4><p><code>CodeRemoval</code> 进行了两层过滤：</p>
<ol>
<li>直接删除无 User 且无副作用的指令。</li>
<li>从有 User 指令出发计算依赖闭包，删除依赖链之外的指令。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断无user且无副作用</span></span><br><span class="line"><span class="keyword">if</span> (instruction.getUserList().isEmpty() &amp;&amp; !instruction.getName().isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instruction <span class="keyword">instanceof</span> CallInst)) &#123;</span><br><span class="line">        instruction.removeOperands();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instruction <span class="keyword">instanceof</span> CallInst callInst) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callInst.getCalledFunction().hasSideEffects()) &#123;</span><br><span class="line">            instruction.removeOperands();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制流与支配分析"><a href="#控制流与支配分析" class="headerlink" title="控制流与支配分析"></a>控制流与支配分析</h3><p>这一部分主要为了支撑 <code>mem2reg</code> 的实现。不同于复用对象，我选择在处理每个函数时直接计算这些关系并挂载到 <code>BasicBlock</code> 上。</p>
<h4 id="CFG构建"><a href="#CFG构建" class="headerlink" title="CFG构建"></a>CFG构建</h4><p>CFG 的构建非常直接：检查每个基本块的最后一条 <code>BrInst</code>，根据跳转目标建立边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lastInstruction <span class="keyword">instanceof</span> BrInst brInst) &#123;</span><br><span class="line">    <span class="keyword">if</span> (brInst.isConditional()) &#123;</span><br><span class="line">        addEdge(block, brInst.getTrueBlock());</span><br><span class="line">        addEdge(block, brInst.getFalseBlock());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addEdge(block, brInst.getTrueBlock());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支配集合与支配树"><a href="#支配集合与支配树" class="headerlink" title="支配集合与支配树"></a>支配集合与支配树</h4><p>支配集合的计算采用了“暴力”但稳健的方法：对于每个候选支配者 <code>d</code>，从入口做 DFS，若遇到 <code>d</code> 则停止。最后 DFS 无法到达的块即被 <code>d</code> 支配。</p>
<p>直接支配者的选择则是从所有支配者中挑选最近的一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (BasicBlock dominator : currentFunction.getBasicBlocks()) &#123;</span><br><span class="line">    Set&lt;BasicBlock&gt; reachableBlocks = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    dfs(entry, dominator, reachableBlocks);</span><br><span class="line">    <span class="keyword">for</span> (BasicBlock block : currentFunction.getBasicBlocks()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!reachableBlocks.contains(block)) &#123;</span><br><span class="line">            dominates.get(dominator).add(block);</span><br><span class="line">            dominatedBy.get(block).add(dominator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支配边界"><a href="#支配边界" class="headerlink" title="支配边界"></a>支配边界</h4><p>支配边界的计算逻辑为：对于每个支配者，扫描其支配的块及其后继，若后继不被该支配者支配，则该后继为支配边界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (BasicBlock dominated : dominator.getDominateBlocks()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BasicBlock child : dominated.getNextBlocks()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dominator.getDominateBlocks().contains(child)) &#123;</span><br><span class="line">            frontier.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mem2reg"><a href="#mem2reg" class="headerlink" title="mem2reg"></a>mem2reg</h3><p><code>mem2reg</code> 的目标是将局部变量提升为 SSA 形式，消除 <code>alloca</code>，并尽量用 SSA 值替换 <code>load</code>，将 <code>store</code> 转化为定义的压栈操作。</p>
<h4 id="收集-def-use"><a href="#收集-def-use" class="headerlink" title="收集 def&#x2F;use"></a>收集 def&#x2F;use</h4><p>首先遍历 <code>alloca</code> 的 <code>userList</code>，将 <code>load</code> 记为 use，<code>store</code> 记为 def。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (instruction <span class="keyword">instanceof</span> LoadInst &amp;&amp; !instruction.getBasicBlock().isDeleted()) &#123;</span><br><span class="line">    useInstructions.add(instruction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instruction <span class="keyword">instanceof</span> StoreInst &amp;&amp; !instruction.getBasicBlock().isDeleted()) &#123;</span><br><span class="line">    defInstructions.add(instruction);</span><br><span class="line">    defBlocks.add(instruction.getBasicBlock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入-phi-指令"><a href="#插入-phi-指令" class="headerlink" title="插入 phi 指令"></a>插入 phi 指令</h4><p>使用经典算法：从 <code>defBlocks</code> 开始，沿支配边界扩散，在遇到新块时插入 <code>PhiInst</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;BasicBlock&gt; F = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;BasicBlock&gt; W = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(defBlocks);</span><br><span class="line"><span class="keyword">while</span> (!W.isEmpty()) &#123;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">X</span> <span class="operator">=</span> W.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (BasicBlock Y : X.getDominanceFrontier()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!F.contains(Y)) &#123;</span><br><span class="line">            <span class="type">PhiInst</span> <span class="variable">phiInst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhiInst</span>(currentAlloc.getTargetType(),</span><br><span class="line">                                          Y, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Y.getPrevBlocks()));</span><br><span class="line">            Y.getInstructions().add(<span class="number">0</span>, phiInst);</span><br><span class="line">            F.add(Y);</span><br><span class="line">            <span class="keyword">if</span> (!defBlocks.contains(Y)) &#123;</span><br><span class="line">                W.add(Y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变量重命名"><a href="#变量重命名" class="headerlink" title="变量重命名"></a>变量重命名</h4><p>重命名阶段维护一个 <code>defStack</code>，通过一次 DFS 完成：</p>
<ol>
<li><strong>Store</strong>：将值压栈，删除指令。</li>
<li><strong>Load</strong>：用栈顶值替换，删除指令。</li>
<li><strong>Phi</strong>：将 Phi 自身压栈，作为新定义。</li>
<li><strong>Alloca</strong>：删除。</li>
</ol>
<p>在从当前块走向后继时，为后继的 Phi 填充来自当前块的 incoming value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (instruction <span class="keyword">instanceof</span> PhiInst phiInst) &#123;</span><br><span class="line">    <span class="keyword">if</span> (useInstructions.contains(phiInst)) &#123;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">value</span> <span class="operator">=</span> defStack.empty() ? <span class="keyword">new</span> <span class="title class_">Undefined</span>() : defStack.peek();</span><br><span class="line">        phiInst.addValue(block, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><p>后端优化主要包括 <code>removePhi</code> 和寄存器分配。</p>
<h3 id="removePhi"><a href="#removePhi" class="headerlink" title="removePhi"></a>removePhi</h3><p>由于 MIPS 没有 Phi 指令，需要在生成代码前将 Phi 拆分为 <code>MoveInst</code>。</p>
<h4 id="拆分流程"><a href="#拆分流程" class="headerlink" title="拆分流程"></a>拆分流程</h4><ol>
<li><strong>清理与生成 Move</strong>：对每个前驱，生成 <code>MoveInst(to=phi, from=alt)</code>。</li>
<li><strong>解决并行赋值</strong>：若 <code>to</code> 在后续被用作 <code>from</code>，引入临时变量中转。</li>
<li><strong>解决寄存器覆盖</strong>：若 <code>to</code> 和 <code>from</code> 分配到了同一寄存器，同样使用临时变量。</li>
<li><strong>插入 Move</strong>：<ul>
<li>若前驱只有一个后继，直接插入。</li>
<li>若前驱有多个后继，新建中间块插入 move 和跳转。</li>
</ul>
</li>
</ol>
<p>关键点在于处理多后继前驱时建立中间块，以保证语义正确。</p>
<h3 id="寄存器分配"><a href="#寄存器分配" class="headerlink" title="寄存器分配"></a>寄存器分配</h3><p>寄存器分配采用了图着色算法，流程为：活跃变量分析 -&gt; 建干涉图 -&gt; 图着色。</p>
<h4 id="活跃变量分析"><a href="#活跃变量分析" class="headerlink" title="活跃变量分析"></a>活跃变量分析</h4><p>计算每个基本块的 <code>use</code> 和 <code>def</code>，并迭代计算 <code>IN</code> 和 <code>OUT</code> 集合。特别注意 Phi 指令的 operand 应视为在前驱边上被使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (changed) &#123;</span><br><span class="line">    changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> blocks.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// ... 计算OUT集合，包含Phi的修正 ...</span></span><br><span class="line">        HashSet&lt;Value&gt; inSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(outSet);</span><br><span class="line">        </span><br><span class="line">        inSet.removeAll(defMap.get(block));</span><br><span class="line">        inSet.addAll(useMap.get(block));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!inSet.equals(inMap.get(block))) &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            inMap.put(block, inSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建干涉图"><a href="#建干涉图" class="headerlink" title="建干涉图"></a>建干涉图</h4><p>从后往前扫描指令，维护 live set。每遇到一个定义，就使其与当前 live set 中的所有变量建立干涉边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Value&gt; live = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(outMap.get(block));</span><br><span class="line">ListIterator&lt;Instruction&gt; iterator = instructions.listIterator(instructions.size());</span><br><span class="line"><span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><br><span class="line">    <span class="type">Instruction</span> <span class="variable">instruction</span> <span class="operator">=</span> iterator.previous();</span><br><span class="line">    <span class="keyword">if</span> (!instruction.getName().isEmpty() &amp;&amp; !(instruction <span class="keyword">instanceof</span> ZextInst)) &#123;</span><br><span class="line">        live.remove(instruction);</span><br><span class="line">        <span class="type">InterferenceGraphNode</span> <span class="variable">nodeU</span> <span class="operator">=</span> getOrCreateNode(instruction);</span><br><span class="line">        <span class="keyword">for</span> (Value v : live) &#123;</span><br><span class="line">            addEdge(nodeU, getOrCreateNode(v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 添加操作数到live set ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="图着色"><a href="#图着色" class="headerlink" title="图着色"></a>图着色</h4><p>采用 simplify&#x2F;spill&#x2F;select 步骤：</p>
<ol>
<li><strong>Simplify</strong>：反复移除度数 &lt; K 的节点压栈。</li>
<li><strong>Spill</strong>：若无度数 &lt; K 的节点，选择度数最大的节点作为溢出候选压栈。</li>
<li><strong>Select</strong>：出栈分配颜色，若无色可选则标记溢出。</li>
</ol>
<p>最终将分配结果记录在 <code>function.setVar2reg</code> 中，供后端代码生成使用。</p>
<h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><p>整体的优化流水线如下：</p>
<ol>
<li><strong>中端</strong>：先进行死代码删除和 CFG 清理，再执行 <code>mem2reg</code>，最后进行局部优化。</li>
<li><strong>后端</strong>：在生成 MIPS 前，依次执行 <code>ZextRemoval</code> -&gt; <code>RegAlloc</code> -&gt; <code>RemovePhi</code>。</li>
<li><strong>窥孔</strong>：生成 MIPS 代码后，再进行一轮窥孔优化。</li>
</ol>
<p>这一顺序确保了 IR 在结构稳定后进行重优化，最后在目标代码层面进行局部调整。</p>
<p>学习编译的过程中，经常会听到一句话，“相信编译器的力量”。</p>
<p>相比于目前的成熟编译器，我的编译器还处于非常简陋的阶段，不过我已经很满意了。</p>
]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>北航 OO 面向对象 第三单元</title>
    <url>/2025/06/29/%E5%8C%97%E8%88%AA-OO-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<blockquote>
<p>本单元重点学习了JML规格代码的书写、阅读，以及体验规格化设计实现。本单元学习的内容可谓是金刚钻，也许将来在工作的时候不一定会用到，但是掌握一项高专业化的能力不是一件坏事，况且一旦用到了那我们便能得心应手的应对，因此也是要好好对待JML的！</p>
</blockquote>
<h1 id="1-测试过程"><a href="#1-测试过程" class="headerlink" title="1. 测试过程"></a>1. 测试过程</h1><h4 id="1-1-单元测试"><a href="#1-1-单元测试" class="headerlink" title="1.1 单元测试"></a>1.1 <strong>单元测试</strong></h4><p>单元测试指的是，<mark>对软件中的函数、方法或类进行正确性验证</mark>。通过验证程序的函数是否正确，能够尽早发现代码逻辑错误，隔离缺陷，方便代码重构。单元测试过程自动化程度高，执行速度快，定位问题准确，成本最低。<mark>在我的程序中，我使用JUnit来进行单元测试，测试函数行为</mark>。</p>
<h4 id="1-2-功能测试"><a href="#1-2-功能测试" class="headerlink" title="1.2 **功能测试"></a>1.2 **功能测试</h4><p>功能测试是指，基于软件需求规格说明书对软件功能进行验证。<mark>关注“软件做什么”，而不是“怎么做”</mark>。主要以黑盒测试为主，根据需求文档设计测试用例。在自动化测试的同时也包含大量手动测试，需要手搓一些极端样例来保证代码在极端情况下的健壮性。<mark>在我的程序中，我手搓了很多极端数据来保证函数功能的正确实现</mark>。</p>
<h4 id="1-3-集成测试"><a href="#1-3-集成测试" class="headerlink" title="1.3 集成测试"></a>1.3 <strong>集成测试</strong></h4><p> 集成测试指的是，<mark>将通过单元测试的各个模块组合起来进行测试</mark>，重点关注模块之间的接口、交互和数据流，旨在发现模块之间由于接口不匹配、参数类型不一致、参数传递错误等引起的缺陷。验证组合后的模块协同工作是否正常。<mark>在我的程序中，我构建了一个验证场景，并调用了多个类的方法来测试</mark>。</p>
<h4 id="1-4-压力测试"><a href="#1-4-压力测试" class="headerlink" title="1.4 压力测试"></a>1.4 <strong>压力测试</strong></h4><p>压力测试是指，<mark>在超出系统正常运行负荷的极限条件下对软件进行测试</mark>，例如极高的并发用户数、大数据量等。其目的是为了检验程序在极端情况下的健壮性，模拟真实场景中的极端情况，保证程序的稳定，评估程序的抗压性能。主要测试方式就是短时间内大量输入。在我的程序中，<mark>我采用了大量输入测试的方式来评估程序抗压能力，同时手搓了卡TLE的极端数据</mark>。</p>
<h4 id="1-5-回归测试"><a href="#1-5-回归测试" class="headerlink" title="1.5 回归测试"></a>1.5 <strong>回归测试</strong></h4><p>回归测试指的是，在软件发生变更后，如修复了 Bug、新增了功能，<mark>需要重新运行原有测试用例</mark>，以确认这些变更没有引入新的bug或改变了原有已经正常工作的功能。<mark>在我的程序中，我沿用了之前的JUnit测试代码来进行回归测试</mark>。</p>
<h3 id="1-6-数据构造策略"><a href="#1-6-数据构造策略" class="headerlink" title="1.6 数据构造策略"></a>1.6 数据构造策略</h3><p>我认为数据构造应该包含以下几个层级：1. 对代码正确性进行全面测试。 2. 对极端情况进行手搓构造。 3. 对代码进行压力测试。  </p>
<ol>
<li><p><strong>对代码正确性进行全面测试</strong>。这一部分需要生成广泛的数据，来尽可能从测试最多的方法，触发每一种情况。每一种情况不要求深度测试，但是要求每一种情况都尽量测试到，求广度和不求深度。为了满足这种需求，这一部分数据生成可以采用随机数据生成，利用随机数据生成器来生成大量的数据，并进行大量的生成测试，通过增加数据量来提高方法测试覆盖率。  </p>
</li>
<li><p><strong>对极端情况进行手搓构造</strong>。这部分需要根据一些方法的易错点来手搓一些极端情况，来验证代码的正确性。我在这一部分首先观察所有方法在实现中较难、较复杂的地方，然后手动构造一些触发这些复杂情况的数据来验证代码的行为。</p>
</li>
<li><p><strong>对代码进行压力测试</strong>。这部分我会对那些实现复杂度较高的方法进行压力测试，构造一个能够是其复杂度最高的场景，然后大量调用该方法，来测试其在极端情况下的健壮性。</p>
</li>
</ol>
<h1 id="2-大模型使用经验"><a href="#2-大模型使用经验" class="headerlink" title="2. 大模型使用经验"></a>2. 大模型使用经验</h1><p>在本单元，我尝试过使用大模型来书写JML规格、根据JML规格来生成代码、验证我实现的代码是否符合JML规格要求。在这过程中，我总结了一些经验。</p>
<ol>
<li><p><strong>使用大模型来书写JML规格</strong>。在这部分，我们首先需要将已有方法的JML规格投喂给大模型，这样大模型能够熟悉我们想要的JML的模板和样例，同时明确方法与方法之间的关系，这样生成的JML才能更加准确。其次，大模型很难一次性生成完美的JML，因此我们需要再把大模型之前的输出重复投喂给大模型，并且每次家伙是那个一些改动的prompt，让大模型不断微调。</p>
</li>
<li><p><strong>使用大模型来根据JML书写代码</strong>。在这部分，同样需要先把已有的所有JML和Java代码投喂给大模型，让其先学习、适应我们的JML规格、JML与Java代码之间的关系，然后再告知大模型我们想要他生成的方法代码和对应的JML样例，让其仿照其余方法来生成。</p>
</li>
<li><p><strong>使用大模型来验证Java代码是否符合JML规格</strong>。这部分也需要先把其他方法的JML和Java代码投喂给AI，这样AI才知道我们需要让他生成的方法中所设计的成员、方法都是什么含义，能够更精准的检验我们代码的准确度。</p>
</li>
</ol>
<h1 id="3-架构设计及图模型构建和维护策略"><a href="#3-架构设计及图模型构建和维护策略" class="headerlink" title="3. 架构设计及图模型构建和维护策略"></a>3. 架构设计及图模型构建和维护策略</h1><p>在本单元，我的代码架构如下图所示：  </p>
<p><img src="/pictures/image.png" alt="alt text"></p>
<p>重点在于根据JML规格来完成接口方法的实现，并采取高内聚-低耦合的原则来明确划分代码职责，每个类完成各自的任务，并相互配合关联。  </p>
<p>在存储图的时候，<mark>我采用的是类似链表邻接表的形式</mark>。其中图的节点就是Person，而边则代表Person之间的Relation，边的权重就是Value。在每个Person中，我采用了HashMap来存储与该Person有关系的Acquaintance，其中因为network中出现的任何person的id都是唯一的，因此可以用person的id作为键值，而person的引用作为映射，从而可以根据id来O(1)查找对应的acquaintance。<br>在维护图的时候，主要是根据一些能够改变person之间关系的方法来去维护。比如在addRelation的时候，需要在acquaintance中增加新person的映射关系，或者在modifyRelation的时候来修改value值或者取消映射关系。  </p>
<p>几乎所有的维护工作都是在增加、减少、修改这三种操作的时候进行的，因此在考虑维护图的时候，也是先找出所有会增加、减少、修改关系的方法，然后在这些方法执行过程中去维护图的关系。  </p>
<h1 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4. 性能分析"></a>4. 性能分析</h1><p>在本次作业中，有多个方法可能会出现因实现复杂度过高而导致的性能问题，必须加以优化，否则可能会超时。这里我将列举一些有必要的优化，来帮助大家体会思考优化的过程。  </p>
<h4 id="4-1-query-triple-sum-优化"><a href="#4-1-query-triple-sum-优化" class="headerlink" title="4.1 query_triple_sum 优化"></a>4.1 query_triple_sum 优化</h4><p>在第一次作业中，出现了一个看起来很简单，但实际上需要认真优化的方法：</p>
<p><img src="/pictures/image-1.png" alt="alt text"></p>
<p>该方法的JML规格写的非常简单，但是暗藏玄机。如果我们真的按照JML的引导，通过三层for循环来实现该方法，那么复杂度将会是O(n^3)，在强测一万条指令的狂轰滥炸下，这肯定会超时的。因此我们需要巧妙地进行维护，来使得查询复杂度是O(1)，维护复杂度是O(n)，这样做可以把复杂度均摊到每一步方法中，而不是集中堆叠在某一个方法中。</p>
<p>具体来说，我们可以维护一个tripleSum，这样每次查询只需要返回该值即可。维护的过程也很简单：注意到，三元环的形成需要先有两条边相交，然后补齐第三条边，因此我们在每次补齐边的时候，可以遍历两个节点，看看这两个person有没有相同的acquaintance，如果有，那么就会多一个三元环。在删除关系的时候也同理，看看删除关系的两个person是否有相同的acquaintance，如果有那么就少一个三元环。</p>
<h4 id="4-2-query-couple-sum-优化"><a href="#4-2-query-couple-sum-优化" class="headerlink" title="4.2 query_couple_sum 优化"></a>4.2 query_couple_sum 优化</h4><p>在第二次作业中，出现了qcs这个方法。该方法的JML规格如下：</p>
<p><img src="/pictures/image-2.png" alt="alt text"></p>
<p>如果无脑按照JML规格去实现，用两层for循环遍历，那么复杂度将会是O(n^2)，由于该方法还要调用queryBestAcquaintance，因此在极端情况下也会变成O(n^3)，因此需要对该方法进行优化。</p>
<p>注意到该方法主要是寻找两个人，这两个人的qba是彼此，因此我们不用遍历所有的两人组合，只需要对每个人遍历，看看这个人的qba的qba是否是他自己即可。这样就把复杂度优化到了O(n)，然后对qba采取维护的方式，这样就可以用O(1)复杂度来查询qba，有效降低了时间复杂度。</p>
<h4 id="4-3-query-value-sum-优化"><a href="#4-3-query-value-sum-优化" class="headerlink" title="4.3 query_value_sum 优化"></a>4.3 query_value_sum 优化</h4><p>在第二次作业中，还有一个大头优化，那就是qvs。该方法的JML规格如下图所示：</p>
<p><img src="/pictures/image-3.png" alt="alt text"></p>
<p>该方法最直观的方式就是两层for循环遍历，如果两个person之间isLinked是true，那么就加上value。也可以理解为，将所有彼此isLinked的person的value加两遍。不过目前该方法的复杂度是O(n^2)，如果不优化那么很大概率会TLE。</p>
<p>一种简单的优化方案是遍历边复杂度，也就是第一层for训练遍历tag中的所有person，第二层for循环遍历每个person的acquaintance并检查其是否也在tag中。这种方式巧妙地把复杂度降低成了边复杂度，在person之间关系不多的时候可以很大幅度优化时间。不过这种方式在评测机压力过大的时候仍然会TLE。</p>
<p>所以最稳妥的方式还是采取维护的策略。首先，当tag中加入person或者删除person时，需要遍历tag中与该person有isLinked关系的person，并加上或减去两倍的value。其次，当有两个person之间的关系发生变动时，包括addRelation和modifyRelation，都需要找到同时含有这两个person的tag并进行value变动的维护。</p>
<h4 id="4-4-delete-article-优化"><a href="#4-4-delete-article-优化" class="headerlink" title="4.4 delete_article 优化"></a>4.4 delete_article 优化</h4><p>在第二次作业中，每个person增加了一个属性，是receivedArticle，用来存储该person收到的article。这个容器需要支持以下操作：头部插入，删除某一个元素，获取头部前5个元素，获取全部元素。一般来讲，用LinkedList或ArrayList都能很好的完成以上内容，但是这两个容器的删除操作都是O(n)复杂度。</p>
<p><mark>而且我们还要考虑硬件设备的因素，由于LinkedList是离散存储的，因此在遍历的时候，cache的块缺失率非常高，每次都需要重新填入块，因此实际运行时间要远远多于ArrayList</mark>。而ArrayList在内存中是连续存储的，因此cache命中率更高。</p>
<p>除此以外，我们还可以自己构造一个双向链表，并利用HashMap来实现O(1)查找结点，这样是理论的最优方法。</p>
<h4 id="4-5-规格与实现分离的理解"><a href="#4-5-规格与实现分离的理解" class="headerlink" title="4.5 规格与实现分离的理解"></a>4.5 规格与实现分离的理解</h4><p>在最开始，我对JML有着一些误解，我误认为JML的语言是会在程序运行时也实际运行的，因此还曾困惑JML如何进行编译、执行？后来经过思考和询问，我才逐渐明白，JML只是一种规格描述语言，是写给编程人员看的，用来精准传递需求的媒介，而并非一种实际的程序。</p>
<p><mark>JML提供的是规格，也就是让我们通过阅读JML来理解这个方法到底想要干什么，在什么情况下应该怎么执行等等。明确了这些规格后，我们就要开始实现这个方法，而实现方法的方式有很多，根据个人的选择可以有所不同。而这就是规格与实现想分离的意思</mark>。</p>
<h1 id="5-JUnit-测试"><a href="#5-JUnit-测试" class="headerlink" title="5. JUnit 测试"></a>5. JUnit 测试</h1><p>本单元大规模进行了JUnit的测试，用来检验自己代码实现是否符合JML规格，以及是否能够检查出课程组提供代码的错误。</p>
<p>在编写JUnit代码的时候，我也总结出了很多经验心得。我认为最重要的是：</p>
<p><strong>要严格根据JML规格来编写JUnit代码，并且测试一定要全面细致</strong>。如果该方法有exceptional_behavior，那么首先要根据JML的requires来构造相应的场景样例，然后调用相关方法，用assert检验或者expected来验证该方法是否抛出期待的异常。然后对normal_behavior进行检验，要对每个requires情况都进行构造，并根据JML的相关ensures来逐一验证方法是否满足后置要求。最后，如果该方法强调了assignable \nothing 或者 &#x2F;* @ pure @ * &#x2F; ，那么也要验证该方法调用前后是否发生了变化。</p>
<h1 id="6-本单元学习体会"><a href="#6-本单元学习体会" class="headerlink" title="6. 本单元学习体会"></a>6. 本单元学习体会</h1><p>本单元的学习让我对JML规格有了更深入的体会，同时也让我学了一些算法的知识。尽管JML不一定会在将来工作中用到，但是一旦使用到，那么我们就具有绝对的优势。同时在撰写需求规格说明书的时候，也可以用到JML的思想和结构来书写，以保证需求的全面严谨细致。最后，经过本单元的学习，我们都是手握金刚钻的人才，希望我们能够好好发挥强大的本领，在以后的工作生活中有所贡献！</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JML</tag>
      </tags>
  </entry>
  <entry>
    <title>北航 OO 面向对象 第四单元</title>
    <url>/2025/06/29/%E5%8C%97%E8%88%AA-OO-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<blockquote>
<p>转眼间，这趟面向对象程序设计的奇幻漂流也迎来了尾声。从第一单元初入茅庐的“表达式解析”，到第二单元扑朔迷离的“多线程电梯风云录”，再到第三单元严谨到令人发指的“JML”，直至本单元的图书馆怪谈“UML”，我历经了风雨的洗礼，变得更强、更稳、更有经验了。这篇博客是对第四单元和整个OO旅程的一次<strong>深度复盘</strong>与<strong>未来展望</strong>。</p>
</blockquote>
<hr>
<p>✨ <strong>我的OO航海日志·珍藏版索引</strong> ✨</p>
<ul>
<li><a href="https://bbs.csdn.net/topics/619722645"> <strong>第一站：表达式求导的OO启蒙——递归下降与多项式的爱恨情仇</strong></a></li>
<li><a href="https://bbs.csdn.net/topics/619687202"> <strong>第二站：多线程电梯与并发设计的狂想曲——锁与调度的极致拉扯</strong></a></li>
<li><a href="https://bbs.csdn.net/topics/619644726"> <strong>第三站：JML规格与社交网络图的精妙构建——在规格的镣铐中起舞</strong></a></li>
</ul>
<hr>
<h2 id="一、本单元所实践的正向建模与开发"><a href="#一、本单元所实践的正向建模与开发" class="headerlink" title="一、本单元所实践的正向建模与开发"></a>一、本单元所实践的正向建模与开发</h2><p>第四单元主要是设计UML图，并利用画好的UML图来实现一个图书馆管理系统。其中，我们应当采取正向建模的方式来完成作业。</p>
<p>**正向建模的核心奥义：<mark>“先有蓝图，再盖大楼”</mark>，在本单元的图书馆建设中体现得淋漓尽致：</p>
<ol>
<li><p><strong>解读指导书内容</strong>:</p>
<ul>
<li>首先，要得把图书馆的规则理解透彻：书籍如何分类、学生如何借阅、预约、还书，信用分又是如何计算的，以及图书馆每日开闭馆时那套庄严的仪式（<code>open()</code> 和 <code>close()</code>）。</li>
<li>比如要先吃透指导书的内容，明确我们的需求是什么，之后才能准确的设计类和方法。<strong>这部分对应了在实际工程中理解用户需求的部分。</strong></li>
</ul>
</li>
<li><p><strong>绘制UML</strong>:</p>
<ul>
<li><code>MainClass</code>: 我的总指挥部，负责接收用户输入的指令，并精准分发给下级单位。</li>
<li><code>Library</code>: <strong>系统的中枢神经</strong>！它像一位运筹帷幄的馆长，封装了图书馆几乎所有的核心业务逻辑，协调着手下各个“部门”高效运转。</li>
<li><code>Book</code>: 每一本书都封装了它的ISBN、独一无二的副本ID、当前位置、迁移记录、预约对象，还有各种日期戳以及是否“逾期”的标志位。</li>
<li><code>BookShelf</code>: 我的书库，不仅要按ID索引每一本实体书，还要按ISBN管理好各类书的可用副本集合，以及还要处理预约请求列表和馆内的人气王。</li>
<li><code>AppointmentOffice</code>: 预约管理中心，核心就是 <code>appointedBooks</code> 集合，专门预约好的书籍，还得处理好预约书的“保质期”问题。</li>
<li><code>BorrowReturnOffice</code>: 图书借还的“中转站”，一个简单的 <code>books</code> 集合，用于临时存放那些已经归还的书籍。       </li>
<li><code>UserTable</code>: 学生档案管理处，通过好几个 <code>HashMap</code> (<code>userListB</code>, <code>userListC</code>, <code>userOrder</code>, <code>userCredit</code>) 精细入微地管理着每位学生的借书情况（B类、C类书的限制可不一样）、预约状态和信用分。</li>
<li><code>ReadingRoom</code>: 阅览室，通过 <code>readingBooks</code> (学生ID -&gt; 书籍) 管理着室内的图书。</li>
<li><code>Appointment</code>: 一个二元组，记录着学生ID和他们预约的图书ISBN。</li>
</ul>
</li>
<li><p><strong>依据UML进行代码实现</strong>:</p>
<ul>
<li>所有具体的指令处理逻辑，比如学生要借书 (<code>userBorrowBook</code>)、还书 (<code>userReturnBook</code>)，或是图书馆每日的开门 (<code>open</code>)、闭门 (<code>close</code>) 等，都是在我们的<code>Library</code>类中，通过操作我们预先定义好的这些模型对象（<code>BookShelf</code>的实例、<code>UserTable</code>的实例等）来完成的。</li>
<li>举个栗子，当一个借书请求输入，<code>Library</code>会先问问<code>BookShelf</code>书库：“这本书还有存货吗？”，再查查<code>UserTable</code>档案：“这位同学借书资格如何？信用分够不够哇？”，一切妥当后，才会更新<code>Book</code>的状态，并在<code>UserTable</code>中为这位同学记录。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="二、本单元作业的架构设计，对比分析最终的代码设计和UML模型设计之间的追踪关系"><a href="#二、本单元作业的架构设计，对比分析最终的代码设计和UML模型设计之间的追踪关系" class="headerlink" title="二、本单元作业的架构设计，对比分析最终的代码设计和UML模型设计之间的追踪关系"></a>二、本单元作业的架构设计，对比分析最终的代码设计和UML模型设计之间的追踪关系</h2><h3 id="1-我的图书馆系统架构蓝图"><a href="#1-我的图书馆系统架构蓝图" class="headerlink" title="1. 我的图书馆系统架构蓝图"></a>1. 我的图书馆系统架构蓝图</h3><p>我的图书馆系统，核心当属 <code>Library</code> 类，它统一调度和管理着图书馆内部的各个功能组件。下面是我的架构分层解析：</p>
<ul>
<li><p>**<code>MainClass</code> ：</p>
<ul>
<li>职责：从官方指定的<code>SCANNER</code>那里接收各种输入。</li>
<li>行动：根据类型 (<code>LibraryOpenCmd</code>, <code>LibraryCloseCmd</code>, <code>LibraryReqCmd</code>等)，精准地调用对应执行方法。</li>
<li>定位：典型的<strong>控制器</strong>角色，负责将外部的原始输入，转化为对核心业务逻辑的优雅调用。</li>
</ul>
</li>
<li><p>**<code>Library</code> ：</p>
<ul>
<li>几乎所有核心的业务操作方法，如 <code>userBorrowBook</code>, <code>userReturnBook</code>, <code>userOrderBook</code>, <code>open</code>, <code>close</code>, <code>queryCreditScore</code> 等，都由它调用。</li>
<li><strong>聚合众“部门”</strong>:<ul>
<li><code>bookshelf: BookShelf</code>: 掌管馆藏图书，提供图书的获取和归还接口。</li>
<li><code>appointmentOffice: AppointmentOffice</code> : 处理预约图书的暂存和“待领取”状态。</li>
<li><code>borrowReturnOffice: BorrowReturnOffice</code> : 作为图书归还后的“临时隔离区”。</li>
<li><code>userTable: UserTable</code> ： 管理所有学生用户的信息、借阅历史、信用分等“机密档案”。</li>
<li><code>readingRoom: ReadingRoom</code> : 维护阅览室内的图书秩序。</li>
</ul>
</li>
<li><strong>开关门</strong>: <code>open()</code> 和 <code>close()</code> 方法不仅仅是开门关门那么简单，它们是图书馆运作状态转换的关键节点，负责执行每日的“清算”与“初始化”操作。</li>
<li><strong>输出”</strong>: 通过课程组提供的<code>PRINTER</code>工具，向外界播报处理结果。</li>
</ul>
</li>
<li><p>**功能组件层:</p>
<ul>
<li><code>BookShelf</code>: 内部通过 <code>books</code> (<code>HashMap&lt;String, Book&gt;</code>) 按书籍的唯一ID（type-uid-copyId字符串）索引所有物理副本，方便O(1)查找；同时通过 <code>bookList</code> (<code>HashMap&lt;String, HashSet&lt;Book&gt;&gt;</code>) 按ISBN字符串索引该ISBN下的所有可用副本集合，便于快速判断某种书是否有库存。还维护着一个 <code>appointments</code> (<code>ArrayList&lt;Appointment&gt;</code>) 列表，用于初步收集预约请求，以及一个 <code>hotBooks</code> (<code>HashSet&lt;Book&gt;</code>) 集合用于追踪热门书籍的原始ISBN。</li>
<li><code>AppointmentOffice</code>: 核心数据结构是 <code>appointedBooks</code> (<code>HashSet&lt;Book&gt;</code>)，专门管理那些已经成功预约并分配到具体学生的书籍，还要负责检查和处理这些预约书是否过期失效。</li>
<li><code>BorrowReturnOffice</code>: 结构相对简单，就是一个 <code>books</code> (<code>HashSet&lt;Book&gt;</code>)，作为归还书籍的临时存储空间。</li>
<li><code>UserTable</code>: 通过多个精心设计的<code>HashMap</code> (<code>userListB</code>, <code>userListC</code>, <code>userOrder</code>, <code>userCredit</code>)，对每个学生的B类书（只能借一本）、C类书（同ISBN只能借一本）、是否有未处理的预约、以及信用分，都管理得井井有条。</li>
<li><code>ReadingRoom</code>: 维护一个 <code>readingBooks</code> (<code>HashMap&lt;String, Book&gt;</code>)，键是学生ID，值是该学生正在阅览室阅读的书籍，确保一人一次只能在阅览室阅读一本书。</li>
</ul>
</li>
<li><p>**数据实体层 :</p>
<ul>
<li><code>Book</code>: <mark>绝对的核心数据对象</mark>。内部存储书籍需要记录的核心数据。</li>
<li><code>Appointment</code>:记录着学生ID和他们想要预约的图书ISBN。</li>
</ul>
</li>
</ul>
<p>最后的UML类图如下：</p>
<p><img src="/pictures/image-4.png"></p>
<h3 id="2-代码设计与我提供的UML模型之间的追踪关系"><a href="#2-代码设计与我提供的UML模型之间的追踪关系" class="headerlink" title="2. 代码设计与我提供的UML模型之间的追踪关系"></a>2. 代码设计与我提供的UML模型之间的追踪关系</h3><ul>
<li><strong>Java类 &amp; UML类</strong>：我的每一个Java源文件，比如 <code>Library.java</code>, <code>Book.java</code>, <code>BookShelf.java</code> 等，在UML里都意义对应一个<code>&lt;UMLClassView&gt;</code>和一个<code>&lt;UMLClass&gt;</code>。</li>
<li><strong>成员变量</strong>：每个类里的成员变量都与UML中的类的属性一一对应。包括可见性对应以及类型对应。比如 <code>private final BookShelf bookshelf</code>，在UML模型中就表现为 <code>Library</code> 类的一个属性。</li>
<li><strong>类关系</strong>：每两个有关联关系的类在UML图中都有对应的compositon关联。</li>
</ul>
<p>通过UML建模实践，我总结了编码经验：<strong>优秀的面向对象设计代码</strong>要尽可能结构清晰、职责分明，这样它天然就易于被UML这样的标准化建模语言所精确地描述和表达。</p>
<p>这充分说明了一个道理：UML模型，不仅仅可以在设计阶段充当指引我们编码的“蓝图”，也可以在代码完成后，作为一份精确、直观的“代码说明书”和“系统理解工具”。在我的第四单元图书馆系统中，代码和UML模型之间形成了一种非常理想的、相互印证、相互解释的良性循环。</p>
<hr>
<h2 id="三、大模型辅助架构设计"><a href="#三、大模型辅助架构设计" class="headerlink" title="三、大模型辅助架构设计"></a>三、大模型辅助架构设计</h2><p>**如何引导AI在复杂场景中正确理解题目需求:</p>
<ol>
<li><strong>“庖丁解牛”大法</strong>: <mark>千万别指望AI一次性设计整个复杂系统</mark>。那样它只会给你一些泛泛而谈的空话。要把大问题拆解成一个个可管理的小模块、小功能点。然后针对每个小点，向AI精准地“发问”或要求它给出具体方案。<ul>
<li><mark>反面教材</mark>：“请帮我直接根据以上需求生成代码！” </li>
<li><mark>正面引导</mark>：“假设你是图书管理员，我现在要设计图书馆的<code>UserTable</code>类，它的核心职责是管理学生用户的信息。具体来说，我需要它记录每个学生当前借了哪些书，还要记录他们当前是否有未处理的预约请求，以及他们的信用分。请你构思一下，这个<code>UserTable</code>类应该包含哪些核心的成员变量和关键的公开方法呢？”</li>
</ul>
</li>
<li><strong>提供充足的“上下文信息”</strong> :<br>AI的智慧来源于它所“学习”到的数据。我们要想让它给出详细的架构设计，就得给它提供足够清晰、准确的背景资料和约束条件。<ul>
<li><strong>提出新的需求</strong>：将现有的或者新的需求告诉AI，让AI充分学习新的规则。</li>
<li><strong>反思回顾原有的背景</strong>: 我们需要让AI反思之前告诉他的信息，以及回顾AI之前生成的代码。</li>
</ul>
</li>
<li><strong>“循循善诱”，实现迭代式进化”</strong>:<br><mark>不要期望一次提问就能得到完美答案</mark>。架构设计本身就是一个反复打磨、逐步求精的过程。<ul>
<li>可以先从高层抽象入手，比如问AI：“一个图书馆系统，大致可以划分为哪些核心的功能模块或‘部门’呢？它们各自的主要职责是什么？” AI可能会给出类似<code>BookManagement</code>, <code>UserManagement</code>, <code>BorrowReturnProcess</code>这样的初步划分。</li>
<li>然后，针对AI给出的每个模块（或者你自己构思的模块，比如<code>BookShelf</code>, <code>UserTable</code>等），再深入进去，和AI一起“头脑风暴”其内部应该采用什么样的数据结构，需要暴求疵”，发现其中可能存在的逻辑漏洞、性能瓶颈或与业务需求不符之处，然后提出具体的追问，要求AI澄清、改进或提供替代方案。比如，对于AI初步设计的<code>UserTable</code>，你可以追问：“如果一个学生同时借阅了多本C类书（但它们的ISBN各不相同），我该如何设计数据结构才能高效地管理和查询他所借的所有C类书呢？”</li>
</ul>
</li>
</ol>
<hr>
<h2 id="四、我的架构设计思维进化史"><a href="#四、我的架构设计思维进化史" class="headerlink" title="四、我的架构设计思维进化史"></a>四、我的架构设计思维进化史</h2><p>回顾这四个单元的OO奇幻漂流，我的架构设计思维可以说是从“青铜”一路打怪升级到“王者”的进化史。在写代码和debug中不断积累经验，之后再写代码就具备一些架构头脑了，能够判断出哪些架构适合该需求。</p>
<ul>
<li><strong>第一单元</strong>:<ul>
<li><strong>我的架构</strong>：解析表达式主要依靠<strong>递归下降</strong>，将复杂的表达式递归地拆解为 <code>Expr</code> (表达式) -&gt; <code>Term</code> (项) -&gt; <code>Factor</code> (因子) 的清晰层次结构。这里的<code>Factor</code>，我设计成了一个接口，用它来统一管理不同种类的因此，包含了像<code>Num</code>, <code>Var</code>, <code>Sin</code>, <code>Cos</code>, <code>Function</code>, <code>Dx</code> 等不同类型的因子，让它们都能在<code>Factor</code>的容器中存储。而在计算上，我更是贯彻了“化繁为简，统一指挥”的战略思想：所有不同形态的因子，最终都要“殊途同归”，被转换为结构统一的<code>Poly</code> (多项式) 对象，然后在<code>Poly</code>的层面进行标准化的运算（加法、乘法、乘方）。这种“解析过程”与“计算过程”彻底分离**两段式架构设计，<strong>自底向上调用<code>toPoly()</code>方法</strong>的优雅转换思路，为我后续的系统扩展和功能迭代，打下了坚如磐石的基础。</li>
</ul>
</li>
<li><strong>第二单元</strong>:<ul>
<li><strong>核心挑战</strong>：如何在多线程并发访问共享资源时管理好线程安全问题；以及如何设计出一套既高效又聪明的电梯调度策略，让乘客们最快速度到达目标楼层。</li>
<li><strong>我的架构</strong>：我引入了<strong>生产者-消费者模式</strong>。输入线程扮演着“生产者”，源源不断地将乘客请求放入<code>RequestList</code>这个“共享容器”。而我的<code>Dispatcher</code>则从容器中取出请求，并根据分派策略将其分配给各个电梯。电梯线程本身也是消费者，专注于处理分配到自己头上的那些请求。在调度策略上，我更是经历了从第一次作业的“简单粗暴”（直接指定电梯），到第二、三次作业的“精打细算”的调参算法（综合考虑电梯与请求者之间的距离、电梯当前“度量”、电梯的运行速度、乘客的“VIP等级”即优先级等多种因素，为每个电梯打出一个综合得分，优胜劣汰），可谓是不断追求卓越。电梯内部的运行逻辑，则遵循了高效的<code>LOOK</code>算法，并通过一个专门的<code>ElevatorStrategy</code>类进行了优雅的封装。</li>
</ul>
</li>
<li><strong>第三单元</strong>:<ul>
<li><strong>核心挑战</strong>：如何理解JML，并精确无误地实现一个复杂的社交网络系统，并且还要时刻避免一不小心就TLE的悲剧。</li>
<li><strong>我的架构</strong>：架构设计主要是JML决定的。其中将社交网络抽象成一个图模型：<code>Person</code>对象是图中的“节点”，而人与人之间的<code>Relation</code>则是图中的“边”。整个单元的核心，就是<strong>一丝不苟地遵循JML规格文档，去精确实现每一个接口方法</strong>。同时还要估计搞复杂度方法的优化，比如对于那个看似简单的<code>query_triple_sum</code>，我通过在添加&#x2F;删除关系时<strong>动态维护一个<code>tripleSum</code>计数器变量</strong>，硬生生地将查询复杂度从O(N^3)优化到了惊人的O(1)！类似的，<code>query_couple_sum</code>也被我优化到了O(N)的遍历复杂度；而<code>query_value_sum</code>则采用了更复杂的动态维护策略，以均摊复杂度。甚至在处理<code>delete_article</code>时，我还深入比较了<code>LinkedList</code>与<code>ArrayList</code>在删除操作上的性能差异，并思考了使用自定义双向链表配合HashMap来实现理论最优O(1)删除的“终极方案”。</li>
</ul>
</li>
<li><strong>第四单元</strong>:<ul>
<li><strong>核心挑战</strong>：挑战新的项目设计逻辑：先画出UML图，再根据架构图实现代码。</li>
<li><strong>我的架构</strong>：上文已经介绍的非常详尽了，这里就不过多赘述了。</li>
</ul>
</li>
</ul>
<p><strong>我在OO宇宙中的进化轨迹总结</strong>：</p>
<p>在这一路上，我对面向对象的基石——抽象、封装、继承（虽然在本课程中，我更多地是通过接口来实现类似继承的多态效果，但其精髓是相通的！）、多态的理解，以及对诸如生产者-消费者、外观模式、策略模式、状态模式等常用设计模式的认知和应用能力，都在一次又一次的“被虐”与“反杀”的实战挑战中，不断深化、不断成熟，最终化为我代码功力的一部分。</p>
<hr>
<h2 id="五、我的测试思维进化论"><a href="#五、我的测试思维进化论" class="headerlink" title="五、我的测试思维进化论"></a>五、我的测试思维进化论</h2><ul>
<li>我在四次作业中的测试都是通过<strong>评测机测试 + 手搓极端样例</strong>的方式实现的。</li>
<li><strong>从第一次作业开始，我就使用评测机来进行代码测试</strong>。从手搓数据生成器，到书写多线程测试主程序，自己搓评测机的过程锻炼了我的代码能力，也让我多了解了程序评测机的基本逻辑和功能实现。</li>
<li><strong>手搓极端样例的方式可以弥补评测机随机生成数据的不足和缺陷</strong>。一般来说评测机生成的数据都不会非常极端，比如连续10000条输入都是相同的。这也就说明评测机侧重的是测试的广度，而非深度。但是强测的数据点往往会侧重于考察某一个具体的漏洞，比如时间复杂度过高而引起的TLE等，这些极端数据评测机几乎不可能生成，因此必须手搓。手搓的方式就是识别程序中薄弱的地方和潜在的漏洞，然后自己构造一些卡时间的样例或者很复杂的情景，来测试自己程序的健康性。</li>
</ul>
<hr>
<h2 id="六、我的OO课程通关感悟"><a href="#六、我的OO课程通关感悟" class="headerlink" title="六、我的OO课程通关感悟"></a>六、我的OO课程通关感悟</h2><p>当我敲下这篇总结博客的最后一个字符，也意味着我这趟面向对象程序设计之旅即将画上一个虽不舍但却圆满的句号。回首这四个单元的点点滴滴，OO带给我的，早已远远超出了Java语言本身和那几个具体的题目。这更像是一场思维模式的深度洗礼，一场解决复杂问题能力的系统重塑，一场让我窥见“代码之外星辰大海”的奇妙探险。</p>
<p>最后，也是最重要的，我要由衷地感谢课程组的每一位老师和助教们！是你们的精心策划、巧妙设计和辛勤付出，才为我们呈现了这门如此富有挑战性与启发性的面向对象程序设计课程。虽然在这几个月里，我的生活常常因为赶OO的ddl，但是这门课所带给我的收获必将化为我未来在计算机科学的星辰大海中继续探索和遨游的坚实基础与不竭动力！</p>
<p>OO的探险奇旅，至此已悄然驶向终点站。但，面向对象的思考方式与探索精神，永不落幕！</p>
<p>Cheers to OO! 🍻 And may the Source (Code) be with you! 😉</p>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>北航操作系统-OS-lab0-实验报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab0-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1. 思考题"></a>1. 思考题</h2><ol>
<li><p>&#x3D;&#x3D;不一样&#x3D;&#x3D;。在第一次 git add 之前文件 README.txt 属于未跟踪的文件，此时 git 是无法管理这个文件的，因此 git status 显示未跟踪的文件；而在 git add 并 git commit 之后，git 开始管理这个文件，此时再修改后其状态就会变成已修改未暂存的文件。&#x3D;&#x3D;其根本原因就是 git 是否管理了这个文件&#x3D;&#x3D;。如果 git 不管理这个文件，那么这个文件的状态一直都是 untracked ，一旦 git 管理了这个文件，那么经过修改后就会变成 changes not staged for commit ，git add 之后就都是 changes to be committed。</p>
</li>
<li><p>图中，add the file 对应指令 git add，stage the file 对应指令 git add，commit 对应 git commit。</p>
</li>
<li><p>当删除了 print.c 后，可以用 git restore print.c &#x2F; git checkout – print.c 进行恢复至上一次commit的状态。当删除了 print.c 并执行了 git rm print.c 后，可以用 git reset HEAD print.c &#x2F; git restore – staged print.c 先取消暂存，再用 git restore print.c &#x2F; git checkout – print.c 恢复工作区的更改。可以用 git reset HEAD hello.txt &#x2F; git restore –staged hello.txt 将其在不删除的前提下移出暂存区。</p>
</li>
<li><p>在执行 git reset –hard HEAD^ 后，HEAD 指向了上一次 commit 的分支，并且刚刚的分支在 git log 中消失了。在执行 git reset –hard hash 后，HEAD 指向了该 hash 所对应的分支。再执行 git reset –hard hash3 后，HEAD 又指向了最新的分支，并且之前再 git log 中消失的分支又出现了。</p>
</li>
<li><p>输入完 echo first 之后，shell中会输出first。 输入echo second &gt;output.txt 后，会创建output.txt 文件，并在其中写入second。输入完echo third &gt; output.txt 之后，会覆盖原有的output.txt 文件内容，并写入third。输入完echo forth &gt;&gt; output.txt 之后，会在原有的文件后追加forth。</p>
</li>
<li><p>command文件内容如下： <img src="/pictures/c037d492c5603585893ee8a57174b74.png">result文件内容如下：<br><img src="/pictures/69645486b4dbefc82c6123fa6fae4d6.png"><br>说明如下：<br>利用赋值语句 a&#x3D;1，b&#x3D;2进行赋值操作。再通过 $a 和 $b 取出ab中的值，进行重新赋值给c，此时c&#x3D;1+2&#x3D;3。通过save to 语句分别把c，b，a写入file1，2，3中。再利用&gt;&gt;重定向把file1，2，3的内容追加到file4中，最后把file4的内容重定向追加到result中。<br>思考：<br>echo echo Shell Start 和 echo  ` echo Shell Start ` 有区别。前者会将echo后的内容输出到终端。后者会优先执行引号内的内容，即先输出Shell Start，再将输出结果作为内容执行echo语句，最终输出Shell Start。<br>echo echo $c&gt;file1 和 echo `echo $c&gt;file1 ` 有区别。前者会将echo $c 重定向写入file1中。后者会先执行引号内的内容，即先将 $c 重定向写入file1中，由于输出被重定向所以返回空串，外层echo再输出空串到终端。</p>
</li>
</ol>
<h2 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2. 难点分析"></a>2. 难点分析</h2><ol>
<li><p>sed的使用。sed是一个强大的文本编辑工具，想要熟练使用sed需要大量练习。当需要输出时，要加上-n选项，例如：sed -n ‘1p’ file。当需要真正对文本进行改变的时候，需要加上-i选项，例如：sed -i ’1d’ file。同时如果要进行传参替换操作，则需要用双引号，例如：sed ”s&#x2F;$1&#x2F;$2&#x2F;g” file。</p>
</li>
<li><p>bash脚本的编写。在脚本第一行需要加上#!&#x2F;bin&#x2F;bash语句。进行赋值语句时，等号两边不能加空格，例如：a&#x3D;1。if语句格式为：<br>if condition<br>then<br>command<br>fi<br>while语句格式为：<br>while condition：<br>do<br>command<br>done<br>其中condition为一条返回真值的语句，用中括号[]包裹。通过 -eq -ne -gt -lt -ge -le 等判断大小关系返回真值，例如：[$(a) -ge 100]</p>
</li>
<li><p>find命令可以在目录中查找文件名。grep命令可以查找文件中特定pattern的行数，例如 grep -n int file。配合awk命令可以分割语句并根据条件打印相应值。</p>
</li>
<li><p>Makefile是很强大的工具。如果不写make则默认执行第一个target。Makefile格式如下：<br>target：dependencies<br>command<br>执行make target即可根据dependencies和command生成所需文件。dependencies可以有多个，如何dependencies不存在，则会优先生成dependencies，再生成target。如果在当前目录中想要调用子目录中的make指令，可以在makefile中输入make -C dir，这样等同于cd dir，并输入make。</p>
</li>
</ol>
<h2 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3. 实验体会"></a>3. 实验体会</h2><ul>
<li>OS的概念很多，需要记忆的东西也很多，因此需要花很多时间在基础操作的熟悉和练习上，只有熟练掌握基本操作，学习之后的知识才能得心应手。同时需要在做题的过程中认真体会，细心留意，注意一些小的细节，例如gcc -I可以更改头文件地址等等。</li>
<li>必要时需要查阅资料，问问大模型，例如如何在子目录中调用make指令，需要make -C dir命令，这些太过细节的知识不宜查找，所以需要善用大模型帮助我们学习。</li>
<li>有时候需要自行探索，例如执行一条命令后没有反应，可能是多种原因导致的，需要自己不断试错找到原因。比如传参需要用双引号“”包裹起来，想要打印$字符需要前面加转义\。</li>
</ul>
<h2 id="4-原创说明"><a href="#4-原创说明" class="headerlink" title="4. 原创说明"></a>4. 原创说明</h2><p>本实验报告所有内容均为原创。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MOS</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM MoE RL 学习报告</title>
    <url>/2025/08/23/LLM-MoE-RL-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="LLM-MoE-RL-学习报告"><a href="#LLM-MoE-RL-学习报告" class="headerlink" title="LLM MoE RL 学习报告"></a>LLM MoE RL 学习报告</h1><h2 id="第一部分-深入理解-LLM-MoE-的路由器机制"><a href="#第一部分-深入理解-LLM-MoE-的路由器机制" class="headerlink" title="第一部分 深入理解 LLM MoE 的路由器机制"></a>第一部分 深入理解 LLM MoE 的路由器机制</h2><h3 id="1-路由器的训练机制"><a href="#1-路由器的训练机制" class="headerlink" title="1. 路由器的训练机制"></a>1. 路由器的训练机制</h3><ul>
<li><h4 id="路由器通常是一个怎样的网络结构？"><a href="#路由器通常是一个怎样的网络结构？" class="headerlink" title="路由器通常是一个怎样的网络结构？"></a><strong>路由器通常是一个怎样的网络结构？</strong></h4>在 MoE 架构中，一部分 Decoder Layer 把原来的 FFN Layer 被替换为了 MoE Layer。MoE Layer 通常由一个路由器和多个专家组成。</li>
</ul>
<img src="/2025/08/23/LLM-MoE-RL-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/ca6afdc7d793e00371356203ca3e6f1f.png" alt="image-20250819175525569" style="zoom:50%;">

<img src="/2025/08/23/LLM-MoE-RL-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/e0227d73db388cbdf7a40ec388079ad3.png" alt style="zoom:50%">


<h5 id="路由器是一个前馈神经网络，通常有两种网络结构："><a href="#路由器是一个前馈神经网络，通常有两种网络结构：" class="headerlink" title="路由器是一个前馈神经网络，通常有两种网络结构："></a>路由器是一个前馈神经网络，通常有两种网络结构：</h5><ol>
<li><p><mark>一层线性层 + softmax </mark>：词向量经过 attention 层和残差归一化后，进入路由器，假设每个输入 Token 的维度是 d_model，路由器下游有 N 个专家，那么路由器就做了一个 d_model -&gt; N 的线性映射。之后再对维度为 N 的结果进行 softmax，每个维度分别对应该 Token 与每个专家的匹配度或权重。</p>
<p>用公式表示为，路由器内部有一个 d_model * N 大小的权重矩阵 W。输入 x 先与 W 进行矩阵乘法，得到 logits。<br>$$<br>logits &#x3D; x * W<br>$$<br>之后再进行 softmax 得到最后的概率。<br>$$<br>probabilities &#x3D; softmax(logits)<br>$$</p>
</li>
<li><p><mark>两层线性层 + 一层激活函数 + softmax </mark>：该方式与第一种方式的区别就是用了两层线性层。输入先通过第一个线性层映射到 hidden_size 维度，之后经过激活函数（通常为ReLU），然后再经过第二个线性层映射到 N 维度，最后再进行 softmax 操作。</p>
</li>
<li><p><mark>添加高斯噪声</mark> ：<a id="Goth_noise"></a>因参数初始化等原因，可能会导致某些专家被频繁选择和更新参数，而其他专家很少被选择和训练，最后出现“赢家通吃”的情况。为防止这种情况发生，可以在 logits 上加上高斯噪声。高斯噪声是一个形状跟 logits 相同的向量，其中每一个 value 都是对均值为 0，标准差为 σ 的高斯分布的随机采样。然后对加和的结果再进行 softmax 。这样做的好处是在训练时有概率提升概率低的专家，削弱概率高的专家，避免频繁训练某些专家。</p>
</li>
</ol>
<h5 id="我的思考：为什么要这样选择？"><a href="#我的思考：为什么要这样选择？" class="headerlink" title="我的思考：为什么要这样选择？"></a>我的思考：为什么要这样选择？</h5><ol>
<li><mark>计算速度快</mark>：简单的 “线性层 + softmax” 结构计算速度极快，可以为后面专家计算节约时间。</li>
<li><mark>信息足够丰富</mark>：输入到路由器的 Token 向量 x 已经经过了自注意力层处理，因此其已经包含了一定的信息量。路由器阶段只需要负责计算 x 与各个专家的匹配度即可，所以不需要复杂的网络结构。</li>
<li><mark>防止过拟合</mark>：路由器网络结构如果很复杂，意味着函数更复杂，这有可能会导致过拟合。简单的网络可以减少过拟合风险。</li>
</ol>
<hr>
<ul>
<li><h4 id="在-MoE-模型的整体训练过程中，路由器是如何与专家模型协同训练的？请描述其损失函数，特别是用于促进负载均衡的辅助损失的作用和原理。"><a href="#在-MoE-模型的整体训练过程中，路由器是如何与专家模型协同训练的？请描述其损失函数，特别是用于促进负载均衡的辅助损失的作用和原理。" class="headerlink" title="在 MoE 模型的整体训练过程中，路由器是如何与专家模型协同训练的？请描述其损失函数，特别是用于促进负载均衡的辅助损失的作用和原理。"></a>在 MoE 模型的整体训练过程中，路由器是如何与专家模型协同训练的？请描述其损失函数，特别是用于促进负载均衡的辅助损失的作用和原理。</h4><p>路由器和专家模型通过反向转播在端到端的框架下进行协同训练。</p>
<h5 id="在前向传播过程中："><a href="#在前向传播过程中：" class="headerlink" title="在前向传播过程中："></a><strong>在前向传播过程中</strong>：</h5><ol>
<li><p>路由器拿到自注意力模块的输出作为输入 x，通过矩阵乘法来线性映射，并进行softmax 得到输出。</p>
</li>
<li><p>根据路由器的输出，采用 Top-k 机制，选择概率最大的 k 个专家，将 x 输入给这些专家并得到每个专家的输出 expert_i 。然后对这 k 个专家的概率进行归一化，并与其输出进行加权求和作为 MoE 层的输出。<a id="top-k"></a><br>$$<br>y &#x3D; \sum w_i * expert_i<br>$$</p>
</li>
<li><p>最后 MoE 的输出加上残差作为这个 Decoder Layer 的输出，继续向下传播，直到模型最后得到预测结果。</p>
</li>
</ol>
<p><img src="/pictures/145e9139a5d8c87576ce3492f6fca402.png" alt="image-20250821024626367"></p>
<h5 id="MoE-模型损失函数："><a href="#MoE-模型损失函数：" class="headerlink" title="MoE 模型损失函数："></a><strong>MoE 模型损失函数：</strong></h5><p>MoE 模型的损失函数由一个主要损失和辅助损失组成，用公式表达为：<br>$$<br>total_loss &#x3D; main_loss + \alpha * auxiliary_loss<br>$$<br>其中 α 是超参数，用来平衡主损失和辅助损失。</p>
<h5 id="main-loss-："><a href="#main-loss-：" class="headerlink" title="**main_loss **："></a>**main_loss **：</h5><p>主要是交叉熵损失，用来衡量模型输出的概率分布与真实标签分布的差异程度。对于单个样本，交叉熵损失公式如下：<br>$$<br>H(p, q) &#x3D;&#x3D; -\sum_x{p(x)log(q(x))}<br>$$<br>其中 p(x) 是真实分布中类别 x 的概率，q(x) 是预测概率中类别 x 的概率。通过对所有类别进行计算并求和得到最后的交叉熵损失。交叉熵损失对于接近正确的预测会给出很小的损失，对于很不正确的预测会给出非常大的损失，这有助于模型参数的快速更新。</p>
<h5 id="我的思考：为什么主损失函数选择交叉熵损失？"><a href="#我的思考：为什么主损失函数选择交叉熵损失？" class="headerlink" title="我的思考：为什么主损失函数选择交叉熵损失？"></a><strong>我的思考：为什么主损失函数选择交叉熵损失？</strong></h5><ol>
<li>因为交叉熵损失能体现模型预测概率和真实标签概率之间的差异程度，很适合多标签分类任务，可以把大模型视为一个以语料库为类别的大型多标签分类器，因此很适合衡量大模型的预测性能。</li>
<li>在大模型的最终解码阶段，会把输入先进行 Layer Normalization，然后通过一个线性层映射到一个 vocab_size 大小的向量，之后进行 softmax 操作。因此我们得到的 logits 就是一个针对每个 token 的概率分布，可以很好的适用于交叉熵损失。</li>
</ol>
<h5 id="auxiliary-loss"><a href="#auxiliary-loss" class="headerlink" title="auxiliary_loss:"></a><strong>auxiliary_loss:</strong></h5><p><a id="auxiliary_loss"></a>辅助损失的计算公式是：<br>$$<br>auxiliary_loss &#x3D; \sum_i^{expert}{P_i * N_i}<br>$$<br>其中 Pi 是一个 Batch 中的所有 Token 由路由器分配给第 i 个专家的权重和。用来反映一个专家 i 的重要性。</p>
<p>Ni 是一个 Batch 中所有 Token 里，将专家 i 选入 Top-K 列表的 Token 比例。用来反映专家 i 的被选中比例或受欢迎程度。</p>
<p>辅助损失的计算，就是对于所有专家计算其 Pi 和 Ni 的内积并求和。</p>
<p>由于我们的目标是最小化损失函数，因此辅助损失也会向着变小的趋势更新。这就使得 P 向量和 N 向量在各个维度上的方向要尽可能不一致。也就是对于某一个专家 i，不会出现 Pi 和 Ni 都很大的情况。最终希望调整的结果为所有专家的 P 值都很高，N 值都近似相等。这样的话，所有专家都能够被给予足够多的权重，并且也都能以均衡的概率被选中，充分发挥了多专家的功能性。</p>
<p>其主要作用就是平衡专家们的权重和被选中率，让每个专家都能有足够的机会得到训练和使用，减少赢家通吃的现象，发挥多专家的多功能性。</p>
<h5 id="我的思考：为什么这样辅助损失这样设计可以达到均衡的效果？"><a href="#我的思考：为什么这样辅助损失这样设计可以达到均衡的效果？" class="headerlink" title="我的思考：为什么这样辅助损失这样设计可以达到均衡的效果？"></a><strong>我的思考：为什么这样辅助损失这样设计可以达到均衡的效果？</strong></h5><p>总结：<mark>在向量 L1 范数相对固定和 P、N 的内在逻辑约束下，当辅助损失变小时会自然出现的趋势。</mark></p>
<p><mark>向量 L1 范数相对固定</mark>：通过 P 和 N 的定义可知，P 向量的 L1 范数是一个固定值，大致等于 总 Token 数 ，N 向量的 L1 范数是一个相对固定值，大致等于 总 Token 数 * k 。因此 P 向量和 N 向量不会出现每个位置的值都趋近于 0 的情况，总有一些位置的值是较大的，或者有所位置的值都均匀分配。</p>
<p><mark>P、N 的内在逻辑约束</mark>：根据 P 和 N 的定义可知，当 P 变大时，该专家所被分配的权重和变大，那么该专家就更有可能被更多 Token 所选入 Top-K 列表，也就是 N 也会随之变大。当 P 变小时同理，N 也会随之变小。因此不会出现 P 很小但是 N 很大的情况，因为 P 很小意味着该专家在每个 Token 中被路由器分配的权重很少，其他专家被分配的权重更多，那么该专家不可能被很多 Token 选中，否则易证明不满足不等式。同理也不会出现 P 很大但是 N 很小的情况。因为 P 很大意味着该专家在每个 Token 中都被路由器分配了较多的权重，那么该专家有很大概率被多个 Token 选中，否则也易证明不满足不等式。</p>
<p>根据上述两种约束，<mark>我发现 P、N 向量中相同位置的值总是在各自的 L1 范数中占据相似的比例</mark>。在各自 L1 范数相对固定的约束下，如果极少数位置的值占比很大，其他大部分位置的值占比很小，也就是少数专家出现了赢家通吃时，辅助损失会很大。因此想要降低损失，就必然要朝着大部分位置的值都适中，没有占比很小的，也没有占比很大的，这样的趋势移动，这样才能降低辅助损失，具体降低的过程就依靠优化器来实现。</p>
<p>因此该辅助损失的设计可以实现均衡专家的效果。</p>
</li>
</ul>
<hr>
<ul>
<li><h4 id="在训练开始阶段，如何避免“赢家通吃”的现象，即部分专家被过度使用，而另一些专家得不到充分训练？"><a href="#在训练开始阶段，如何避免“赢家通吃”的现象，即部分专家被过度使用，而另一些专家得不到充分训练？" class="headerlink" title="在训练开始阶段，如何避免“赢家通吃”的现象，即部分专家被过度使用，而另一些专家得不到充分训练？"></a>在训练开始阶段，如何避免“赢家通吃”的现象，即部分专家被过度使用，而另一些专家得不到充分训练？</h4><p>主要是通过计算辅助损失、添加路由噪声、限制专家容量三种方式来避免赢家通吃现象。</p>
<p>计算辅助损失 (<a href="#auxiliary_loss">auxiliary_loss</a>]) 和添加高斯噪声 (<a href="#Goth_noise">高斯噪声</a>) 的方式在上文已经叙述过了，这里重点来讨论限制专家容量如何避免赢家通吃现象。</p>
<h5 id="限制专家容量："><a href="#限制专家容量：" class="headerlink" title="限制专家容量："></a><strong>限制专家容量</strong>：</h5><p>其核心思想是规定了每个专家在一个 Batch 中最多只能处理一定数量的 Token ，若某个专家被选中次数超过了该数目，则多余的 Token 会被舍弃专家计算过程并直接进行残差连接。</p>
<p>其中，每个专家的容量计算公式如下：<br>$$<br>expert_capacity &#x3D; \frac{tokens_per_batch}{number_of_experts} * num_of_k * capacity_factor<br>$$<br>在《Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity》原文中，公式里并没有 num_of_k，是因为论文中提出了只选择一个专家，因此 k 的值为 1。</p>
<p>在每个 batch 中，所有 token 经过 router 后选出 top-k 个专家，此时统计每个专家的被选择数量，若超过专家容量，则多余数目的 token 直接跳过专家计算，或者专家计算结果为 0，其结果等于残差连接的结果。</p>
<h5 id="我的思考：为什么这样做可以防止赢家通吃？"><a href="#我的思考：为什么这样做可以防止赢家通吃？" class="headerlink" title="我的思考：为什么这样做可以防止赢家通吃？"></a><strong>我的思考：为什么这样做可以防止赢家通吃？</strong></h5><p>当赢家通吃现象发生时，受偏重的专家会被很多 token 选入 top-k，因此会有一部分 token 被跳过专家计算。这部分被跳过专家计算的 token 相当于没有经过 FFN 层的处理，只经过了自注意力处理，包含的信息更少，因此预测结果也更差，损失更高。优化器就会据此来调整 router 的参数，使之向着降低损失的方向更新，也就是减少给赢家分权重，多给其他训练次数少的专家分权重，从而简介的抑制赢家通吃现象的膨胀，协助专家均衡。</p>
</li>
</ul>
<hr>
<h3 id="2-路由器的决策过程"><a href="#2-路由器的决策过程" class="headerlink" title="2. 路由器的决策过程"></a>2. 路由器的决策过程</h3><ul>
<li><h4 id="在模型进行推理时，路由器如何为每个输入选择最合适的专家？"><a href="#在模型进行推理时，路由器如何为每个输入选择最合适的专家？" class="headerlink" title="在模型进行推理时，路由器如何为每个输入选择最合适的专家？"></a>在模型进行推理时，路由器如何为每个输入选择最合适的专家？</h4><p>路由器采取 Top-k 策略来为每个 Token 选取最合适的专家。</p>
<h5 id="Top-k-策略："><a href="#Top-k-策略：" class="headerlink" title="Top-k 策略："></a><strong>Top-k 策略：</strong></h5><p>在路由器得到每个输入 x，将其与权重矩阵进行矩阵乘法，并对结果进行 softmax，得到输出 logits 。之后会选择概率最高的 k 个专家。对于未被选中的专家，其概率会被置为 0 ，然后对选中的 k 个专家的概率重新进行归一化得到权重。然后将输入 x 送入这 k 个专家中计算并得到输出，最后的输出与权重相乘并累加得到最后的输出。（<a href="#top-k">top-k</a>）</p>
<p><mark>模型在推理阶段不会添加高斯噪声</mark>，这一点与在训练阶段有所不同。</p>
<hr>
</li>
<li><h4 id="路由器的决策是基于哪些信息做出的？"><a href="#路由器的决策是基于哪些信息做出的？" class="headerlink" title="路由器的决策是基于哪些信息做出的？"></a>路由器的决策是基于哪些信息做出的？</h4><p>目前大部分主流的 MoE 架构中，路由器的决策都仅仅是根据单个 Token 来决定的，即对输入 x 进行线性映射。</p>
<p>尽管这有点反常，毕竟我们采取 MoE 架构的初衷是让不同领域的专家来处理不同领域的输入，如果不结合上下文理解，只凭借单一的 Token ，那很难将这个 Token 来划分到某一类别。</p>
<p>比如：”What is computer?”  和 “What is piano?” ，前者是针对计算机方面的知识，后者是针对音乐方面的知识。两者都含有共同的 What 和 is。如果只根据这两个 Token 来路由，是很难知道它到底是哪个领域的知识的。</p>
<h5 id="我的思考：为什么只根据单一-Token-就可以决策？"><a href="#我的思考：为什么只根据单一-Token-就可以决策？" class="headerlink" title="我的思考：为什么只根据单一 Token 就可以决策？"></a><strong>我的思考：为什么只根据单一 Token 就可以决策？</strong></h5><ol>
<li>其实<mark>经过路由器的 Token 已经经过了自注意力机制</mark>，也就是其学习到了上下文的相关信息，在词向量空间中的方向已经靠近了其对应的领域。因此该 Token 可以反映出其不同的上下文，就可以仅仅根据 Token 来做领域划分。</li>
<li><mark>这符合高内聚，低耦合的设计原理</mark>。自注意力机制主要负责让每个 Token 学习其丰富的上下文信息，而路由器机制主要负责为 Token 选择合适的专家。二者功能相对分离，互不冲突。如果路由器在划分领域时也需要参考上下文的信息，那跟自注意力模块的功能就有些重合，这部分功能或许可以抽离到自注意力模块中。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-LLM-MoE-不足与挑战"><a href="#3-LLM-MoE-不足与挑战" class="headerlink" title="3. LLM MoE 不足与挑战"></a>3. LLM MoE 不足与挑战</h3><ul>
<li><h4 id="当前-LLM-MoE-路由器在训练和推理过程中存在哪些主要问题？"><a href="#当前-LLM-MoE-路由器在训练和推理过程中存在哪些主要问题？" class="headerlink" title="当前 LLM MoE 路由器在训练和推理过程中存在哪些主要问题？"></a>当前 LLM MoE 路由器在训练和推理过程中存在哪些主要问题？</h4><ol>
<li><p><strong>负载不均衡</strong>。当前 MoE 架构最核心的问题和挑战就是负载不均衡。由于训练过程的不可控和随机性，很容易发生赢家通吃的现象。如果有的专家被频繁训练，而其他专家训练机会很少，那么就会出现专家广而不精的现象，与我们设计的多专家多方向的初衷相违背。同时严重的负载不均衡也会导致梯度更新不均衡，进一步加剧训练不稳定。</p>
<h5 id="我的思考：如何才能缓解负载不均衡？"><a href="#我的思考：如何才能缓解负载不均衡？" class="headerlink" title="我的思考：如何才能缓解负载不均衡？"></a><strong>我的思考：如何才能缓解负载不均衡？</strong></h5><p>上文提到的添加高斯噪声、设计辅助损失函数、限制专家容量等方法都是在尽可能规避、改变赢家通吃的现象，并没有从根本上预防这种现象的发生。</p>
<p>对于专家，<mark>我认为可以采取预设参数的方式</mark>，从已经训练好的专业领域大模型的 FFN 层中随机选择一部分参数来作为专家的初始参数。这样可以加快训练过程，提前让专家有一部分前置知识。</p>
<p>对于路由器，<mark>我认为可以参考验证集调整超参数的思想</mark>，提前随机初始化多个路由器权重，然后根据验证集的效果来选择最好的权重，而不用等到反向转播时更新权重。</p>
</li>
<li><p><strong>通信成本高</strong>。由于 MoE 架构采取了多个专家，在显著提升了参数量的同时，也对训练提出了更高的要求。专家在训练的时候必须被分散存储在多个 GPU 上，当一个批次中的 Token 经过路由器后，这些输入需要发送到对应专家所在的 GPU 上，这个过程需要一次大规模的数据交换，也就是 All-to-All Communication 。这个步骤对网络带宽要求高，延迟大，导致有可能成为性能瓶颈。就像高速计算 CPU 和低速访存之间的关系一样。</p>
</li>
<li><p><strong>内存开销成本大</strong>。尽管 MoE 架构的计算是稀疏的，每次只会激活 k 个专家。但是在推理或训练时，所有 N 个专家的参数都必须加载到 GPU 的显存里，因为不知道哪 k 个专家会最终进行计算。这就需要我们拥有大量的大显存 GPU 。</p>
</li>
</ol>
<hr>
</li>
<li><h4 id="微调-MoE-模型时，路由器会带来哪些新的挑战？"><a href="#微调-MoE-模型时，路由器会带来哪些新的挑战？" class="headerlink" title="微调 MoE 模型时，路由器会带来哪些新的挑战？"></a>微调 MoE 模型时，路由器会带来哪些新的挑战？</h4><p><strong>很容易过拟合</strong>。由于微调阶段，通常会针对某一个特定领域来训练，这个领域对应的专家表现很好，其他专家由于领域不同表现较差。因此路由器往往会给这个领域的专家很高的权重，并取得较好的效果。这会让路由器学到一种“规律”，即可以把所有 Token 都给这个专家处理，失去了选择性，最后过拟合了。</p>
<h5 id="我的思考：这种方式的后果"><a href="#我的思考：这种方式的后果" class="headerlink" title="我的思考：这种方式的后果"></a><strong>我的思考：这种方式的后果</strong></h5><ol>
<li><p>路由器只会无脑选择训练领域的那个专家，根本不选其他专家。这种情况泛化能力很差，而且会浪费绝大部分专家的参数，失去了多专家的优势，牺牲了成本和性能。</p>
</li>
<li><p>导致只有少量专家真正被微调了，其余专家没有被微调，专家能力差距很大。如果在应用时遇到了其他领域的问题，路由器选择了其他专家，由于没有经过微调训练，这些专家的回答还是遵循预训练中下一个词预测的模式，没有真正解答问题的能力。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="第二部分-VLM-MoE-的新挑战与借鉴经验"><a href="#第二部分-VLM-MoE-的新挑战与借鉴经验" class="headerlink" title="第二部分 **VLM MoE **的新挑战与借鉴经验"></a>第二部分 **VLM MoE **的新挑战与借鉴经验</h2><h3 id="1-VLM-MoE-的挑战"><a href="#1-VLM-MoE-的挑战" class="headerlink" title="1. **VLM MoE **的挑战"></a>1. **VLM MoE **的挑战</h3><ul>
<li><h4 id="多模态输入的路由："><a href="#多模态输入的路由：" class="headerlink" title="多模态输入的路由："></a>多模态输入的路由：</h4><p>VLM 的输入包含图像和文本两种状态，其路由器在决策时需要处理和融合来自不同模态的信息。这相比于只处理文本的 LLM MoE ，带来了哪些新的复杂性？</p>
<p><strong>我的思考：</strong></p>
<ol>
<li><strong>特征空间的不同</strong>。LLM 的所有输入都是文本语言，其每个 Token 经过 embedding 后会被映射到词向量特征空间中的一个向量。而 VLM 是跨模态模型，包含文本和图像。其中图像在经过 ViT 等视觉编码器后，每个 patch 被映射为一个视觉隐藏层维度的向量，这个向量位于视觉特征空间中。为了实现图像和文本的维度一致，还需要一个视觉-语言连接器把每个 patch 对应的向量映射成维度与词向量一致的向量。但是在未经训练的情况下，二者包含的语义大概率不同，尽管维度一致，也不能很好的被 LLM 的 router 兼容。</li>
<li>**路由器选择不同。**在 LLM 中，路由器接收到的所有输入都是文本，因此只需要为文本进行领域归类即可。但是在 VLM 中，路由器接收到的输入可以是图片或者文本，因此路由器需要先判断该输入的模态，再判断该模态的内容，最后判断该模态内容的目标是什么。这对于路由器有了更大的要求，同时也对专家类型有更高的要求，例如可能有纯视觉专家，纯文本专家等。</li>
<li><strong>文本和图片的数量差异</strong>。在 VLM 中，文本所占 Token 通常要小于图片所占 Token ，因此路由器输入的更多 Token 是来源于图片而非文本。但是往往文本涵盖用户的关键信息，路由器如何在庞大的 Token 中找到真正重要的信息是很复杂的。</li>
</ol>
<hr>
</li>
<li><h4 id="专家专业化的多样性："><a href="#专家专业化的多样性：" class="headerlink" title="专家专业化的多样性："></a>专家专业化的多样性：</h4><p>VLM 中的专家可能需要专精于不同的任务，例如某些专家处理视觉特征提取，某些处理跨模态对齐，还有⼀些处理高级的推理。这对路由器的设计和训练提出了哪些新要求？</p>
<p>LLM 中路由器的结构比较简单，难以精准的把 token 分派给功能细化的专家，因此需要设计复杂的路由器来满足需求。</p>
<ol>
<li><p><strong>分层路由器</strong>。</p>
<p>第一层是模态路由器。模态路由器根据 Token 的特征，判断它主要偏向视觉处理，还是文本分析，还是跨模态处理，并据此做出决策。</p>
<p>第二层是任务路由器。根据模态路由器决策，将 Token 传递给一个专门的子任务路由器。比如视觉子路由器会进一步判断这个视觉 Token 是需要特征提取还是物体识别，语言子路由器可能会判断是需要语法分析还是语义推理。</p>
</li>
<li><p><strong>层级依赖路由</strong>：路由器的决策不仅依赖于当前的 Token 向量，还可能依赖*当前所在的 Transformer 层的深度。在模型的底层，路由策略可能更倾向于选择特征提取专家；而在高层，则更倾向于选择推理专家。</p>
</li>
<li><p><strong>历史感知路由</strong>：路由器的决策可能还需要考虑这个 Token 在前几步被哪些专家处理过的历史，并依次为参考来进行路由。</p>
</li>
</ol>
<p>复杂的路由器结构也对路由器的训练提出了更高的要求。</p>
<p>原来的 LLM 的辅助损失只能促进负载均衡，即均衡的让每个专家都能被选择训练。但是这种方式无法引导专家学习的内容，比如让某个专家主要学习图片视觉，某个专家主要学习文本理解等等。这时候可能需要设计新的损失来促进学习。</p>
<ol>
<li><p><strong>专家专业化损失</strong>。可以为训练数据打上元标签来标记该数据的类别。对于一个视觉问答任务，可以预先定义哪些 Token 主要与视觉感知相关，哪些与逻辑推理相关。然后，设计一个损失函数来奖励路由器将视觉 Token 发送给我们预设的视觉专家，并惩罚它将推理 Token 发送给视觉专家。</p>
</li>
<li><p><strong>专家多样性损失</strong>。我们可以设计一个损失函数，来鼓励不同专家处理的 Token 类型尽可能地不同。可以计算不同专家接收到的 Token 向量的平均余弦相似度，并将其作为惩罚项加入总损失中。如果所有专家处理的 Token 都很相似，说明它们没有形成分工，损失就大。</p>
</li>
</ol>
<p>除了设计新的损失，我们还可以改进训练模式。</p>
<ol>
<li><strong>模态分离训练</strong>。可能先使用模态纯净的数据进行训练。例如，只用图像数据训练视觉专家，只用文本数据训练语言专家。在这个阶段让路由器学会基本的模态区分。</li>
<li><strong>跨模态对齐训练</strong>。然后使用图文对数据，专门训练跨模态对齐专家，让路由器也学会了何时需要进行信息融合。</li>
<li><strong>指令与推理微调</strong>。最后在复杂的指令跟随和推理数据上进行端到端微调，激活并训练高级推理专家。</li>
</ol>
<hr>
</li>
<li><h4 id="维持跨模态理解"><a href="#维持跨模态理解" class="headerlink" title="维持跨模态理解"></a>维持跨模态理解</h4><p>在稀疏激活专家的同时，如何保证模型不会丢失图像和文本之间的整体关联性和深层语义理解？</p>
<ol>
<li><p><strong>稠密子层的交替使用</strong>。其核心思想是交替在 Transformer 中使用 MoE 架构和 FFN 架构。一般是 FFN Layer 多一些，MoE Layer 少一些。</p>
<h5 id="我的思考：为什么这样做可以加强图像和文本的整体关联？"><a href="#我的思考：为什么这样做可以加强图像和文本的整体关联？" class="headerlink" title="我的思考：为什么这样做可以加强图像和文本的整体关联？"></a><strong>我的思考：为什么这样做可以加强图像和文本的整体关联？</strong></h5><p>我认为这样做就是保证每个 Token 既可以在专业的专家那里学到特异的知识，同时也能在通用的 FFN 层进行通识理解。由于多个 Decoder Layer 相连接，在上一个 Layer 中学到的知识可以在下一个 Layer 的自注意力模块里交换知识，让图像和文本有相互的关联。再合理搭配上通用学习和特异学习，可以更全面均衡的理解深层语义信息。</p>
</li>
<li><p>**视觉语言连接器。**设计一个稠密的连接器模块，在 Token 进入 Transformer 之前，先进入连接器中进行深度全局的信息融合学习，让每个 Token 都学到其他 Token 的信息。</p>
</li>
</ol>
<hr>
</li>
<li><h4 id="推理开销激增"><a href="#推理开销激增" class="headerlink" title="推理开销激增"></a>推理开销激增</h4><p>由于图像 tokens 数量相比于文本 token 数量急剧增大，对推理速度会带来怎样的挑战？</p>
<ol>
<li><strong>自注意力机制计算量增大</strong>。在计算 Q，K，V 的时候，时间复杂度是 O(n^2) 的时间复杂度。因此当图片的 token 大小激增后，自注意力层的计算量也会以二次方速度增长，使得计算压力非常大，拖慢了推理速度。</li>
<li>**内存开销增大。**图像 Token 增多后，K，V 向量的缓存也会增多，这增加了 GPU 显存的压力，同时巨大缓存导致的读写带宽高延迟也会拖慢推理速度。</li>
</ol>
<hr>
</li>
</ul>
<h3 id="2-VLM-MoE-路由器的训练与借鉴："><a href="#2-VLM-MoE-路由器的训练与借鉴：" class="headerlink" title="2. **VLM MoE **路由器的训练与借鉴："></a>2. **VLM MoE **路由器的训练与借鉴：</h3><ul>
<li><h4 id="目前已有的-VLM-MoE（如Kimi-VL、GLM-4-5V）是如何训练其路由器的？它们采用了哪些创新的策略？"><a href="#目前已有的-VLM-MoE（如Kimi-VL、GLM-4-5V）是如何训练其路由器的？它们采用了哪些创新的策略？" class="headerlink" title="目前已有的 VLM MoE（如Kimi-VL、GLM-4.5V）是如何训练其路由器的？它们采用了哪些创新的策略？"></a>目前已有的 VLM MoE（如Kimi-VL、GLM-4.5V）是如何训练其路由器的？它们采用了哪些创新的策略？</h4><p><strong>Kimi-VL</strong>：Kimi-VL 的 MoE Language Model 部分是基于其纯语言模型 Moonlight 构建的。其包含了 MoE 架构中的经典结构。包括负载均衡辅助损失 ，Top-k Gating。专家容量限制等。Kimi-VL 的 MoE 解码器激活了 2.8B 参数，总参数量为 16B。</p>
<p><img src="/pictures/912718d4d0adddc50da34d38ca09d38c.png" alt="alt text"></p>
<h5 id="创新策略一：解耦与对齐的分阶段训练"><a href="#创新策略一：解耦与对齐的分阶段训练" class="headerlink" title="**创新策略一：解耦与对齐的分阶段训练 **"></a>**创新策略一：解耦与对齐的分阶段训练 **</h5><p>这是 Kimi-VL 训练路由器的核心创新策略。它没有一开始就让路由器面对复杂的图文混合数据，而是采用了一个由简到繁、逐步对齐的流程。</p>
<ol>
<li><p><strong>第一阶段：语言模型预训练</strong></p>
<p>首先，其 MoE 语言模型 Moonlight 在一个 5.2T Token 的纯文本数据集上进行了充分的预训练。在这个阶段，路由器已经学会了如何根据纯文本的语义来高效、均衡地分配专家。它已经为语言理解任务建立了一套成熟的、专业化的路由策略。</p>
</li>
<li><p><strong>第二阶段：视觉编码器独立训练与对齐</strong></p>
<p>视觉编码器 MoonViT 首先在图文对上进行独立训练（类似 CLIP），然后通过一个 MLP Projector 对齐到已经训练好的 MoE 语言模型上。在对齐阶段（0.1T Token），只有 MoonViT 和 MLP Projector 的参数被更新。</p>
<p>在这个关键的对齐阶段，路由器和整个 LLM 的参数是冻结的。这意味着，路由器不会被初始的、可能充满噪声的视觉特征所干扰。模型的目标是让 MLP Projector 学会如何将视觉特征“翻译”成 LLM 和路由器已经能够理解的、类似文本词向量的语言。</p>
</li>
<li><p>**第三阶段：联合预训练 **</p>
<p>在对齐完成后，才开始在一个 1.4T Token 的混合数据上，对整个模型（ViT, Projector, LLM+Router）进行端到端的联合训练。并且，多模态数据的比例是逐步增加 (Progressive)的。此时，路由器接收到的视觉 Token 已经经过了精心翻译，与文本 Token 在特征空间中更加接近。这极大地降低了路由器学习多模态路由策略的难度。渐进式的数据混合，也让路由器可以平滑地从处理纯文本，过渡到处理图文混合流。</p>
</li>
</ol>
<h5 id="创新策略二：原生分辨率视觉编码器-MoonViT"><a href="#创新策略二：原生分辨率视觉编码器-MoonViT" class="headerlink" title="创新策略二：原生分辨率视觉编码器 (MoonViT)"></a><strong>创新策略二：原生分辨率视觉编码器 (MoonViT)</strong></h5><p>Kimi-VL 设计了 MoonViT，一个可以<strong>原生处理不同分辨率和宽高比</strong>图像的视觉编码器，避免了传统 VLM 中将图像强制缩放或切分成多个子图的复杂操作。这意味着送入连接器和路由器的视觉 Token 序列，能更真实、更完整地反映原始图像的信息，而没有因为切割或缩放引入的人工痕迹和信息损失。</p>
</li>
</ul>
<hr>
<ul>
<li><h4 id="LLM-MoE在解决负载均衡、稀疏性控制和高效训练等方面的经验，有哪些可以直接或经过改造后应用于VLM-MoE？请举例说明"><a href="#LLM-MoE在解决负载均衡、稀疏性控制和高效训练等方面的经验，有哪些可以直接或经过改造后应用于VLM-MoE？请举例说明" class="headerlink" title="LLM MoE在解决负载均衡、稀疏性控制和高效训练等方面的经验，有哪些可以直接或经过改造后应用于VLM MoE？请举例说明"></a>LLM MoE在解决负载均衡、稀疏性控制和高效训练等方面的经验，有哪些可以直接或经过改造后应用于VLM MoE？请举例说明</h4><p><strong>我的思考：</strong></p>
<ol>
<li><mark>负载均衡辅助损失</mark>可以直接应用到 VLM MoE 中。由于最终图片和文本的 Token 都会在维度对齐后送入 Transformer 模块中，因此对于负载均衡损失而言依然可以继续使用。其目标还是平衡 N 个专家的机会和能力，这对于多模态而言也是同样重要的。</li>
<li><mark>路由高斯噪声</mark>也可以直接应用于 VLM MoE 中。路由高斯噪声是在路由器已经生成权重后对权重随机的更改，这于路由的过程无关，是直接在结果层面的改变，因此可以直接套用。同时其训练目标也是防止赢家通吃，在这 VLM MoE 中同样需要。</li>
<li><mark>限制专家容量</mark>可以改造后应用于 VLM MoE。首先在 VLM 中，每个专家的容量限制不应该相同。由于 VLM 中图片 token 更多，因此专门负责视觉处理的专家天然的会被更多 token 选择，因此其容量应该大于文本处理专家。可以结合专家专业化的引导来选定不同类别的专家，然后特定的设置专家容量，这样更合理一些。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="第三部分-学习-DPO、-PPO-与-GRPO-算法"><a href="#第三部分-学习-DPO、-PPO-与-GRPO-算法" class="headerlink" title="第三部分 学习 DPO、**PPO **与 GRPO 算法"></a>第三部分 学习 <strong>DPO</strong>、**PPO **与 <strong>GRPO</strong> 算法</h2><h3 id="1-PPO"><a href="#1-PPO" class="headerlink" title="1. PPO"></a>1. <strong>PPO</strong></h3><ul>
<li><h4 id="PPO-的基本原理是什么？它如何利用奖励模型和强化学习来优化语言模型？"><a href="#PPO-的基本原理是什么？它如何利用奖励模型和强化学习来优化语言模型？" class="headerlink" title="PPO 的基本原理是什么？它如何利用奖励模型和强化学习来优化语言模型？"></a>PPO 的基本原理是什么？它如何利用奖励模型和强化学习来优化语言模型？</h4><p>强化学习的本质是一种试错学习，模型的每一个行动都会有一个对应的奖励，模型通过奖励来判断行动的好坏，然后学习一个策略去最大化模型获得的累积奖励。</p>
<p>PPO，近端策略优化，在允许模型自我探索的基础上，严格限制新策略与旧策略的差异程度，防止模型忘记之前学到的知识。其每次模型更新都是小步更新，确保了训练的稳定性，不会出现策略崩溃。</p>
<p>首先需要训练一个奖励模型 Reward Model 。训练过程是通过对一个 Prompt 的回答进行人为排序标注，来规范回答的好坏程度。奖励模型的训练任务就是对一个 prompt 的回答进行打分，其打分的依据就是人类标注的训练数据。</p>
<p>在 PPO 训练时，有两个 SFT 模型，其中一个是在线模型，是训练优化的目标模型，会更新参数。另一个是参考模型，是参数冻结模型，这个模型不更新参数，用来计算 KL 散度。还有一个奖励模型，用来评价 prompt 和回复的好坏。和一个价值模型，输入一个状态，预测从这个状态出发，未来能获得的期望总奖励。</p>
<p><strong>PPO 的工作循环</strong>：</p>
<ol>
<li><p>采样：从一个大的 Prompt 数据集中，随机抽取一个批次的 Prompt。</p>
</li>
<li><p>生成：对于抽取的每一个 Prompt ，将其输入给在线模型和参考模型，让它自回归地生成一个完整的回答，得到一批由当前策略生成的完整对话。</p>
</li>
<li><p>评估：对于每一个prompt，将 (Prompt, 生成的回答) 这个组合，送入奖励模型 (RM)，得到一个奖励分数。这个分数告诉我们这个回答有多好，并且这个reward只在对话的最后一个 token 处被给予。</p>
</li>
<li><p>KL 散度惩罚：对于每一个 token ，计算在线模型的输出与冻结的 SFT 参考模型的输出的概率分布之间的 KL 散度 。<br>   $$<br>   β * log(\frac{π_θ(a_t|s_t)} { π_ref(a_t|s_t)})<br>   $$</p>
</li>
</ol>
<p>   这是一个惩罚项，它衡量了在线模型的回答与原始 SFT 模型的偏离程度。这个 KL 惩罚项会从每一步的源氏奖励从被减去。这个惩罚项是 PPO 稳定性的另一个关键，它防止模型为了追求高奖励而忘记之前学到的知识。</p>
<ol start="5">
<li><p>调整奖励： 将（奖励分数 - KL 惩罚）作为最终的每一步的调整后的奖励。<br>   $$<br>   Adjusted_Reward_t &#x3D; (Reward_t) - (KL_Penalty_t)<br>   $$<br>   其中，只有最后一个 token 的 reward 是 RM 最后给出的原始奖励，其他中间的 token  的 reward 都是 0 。</p>
</li>
<li><p>计算优势：对于轨迹中的每一个状态，都将其输入到价值模型中。价值模型会输出一个预测值，代表它认为从这个状态出发，未来能获得的期望总奖励是多少。对于每一个时间步 t，优势的计算公式是：<br>$$<br>A_t &#x3D; (实际获得的未来奖励) - (价值模型预测的未来总奖励)<br>$$<br>若 A_t &gt; 0，则说明从当前状态出发，采取现在的行动，比预期的要好。</p>
</li>
<li><p>更新策略：首先计算策略比率，对于轨迹中的每一个（状态，行动），计算新旧策略的比率。<br>$$<br>r_t &#x3D; \frac{π_θ_new(a_t|s_t)} {π_θ_old(a_t|s_t)}<br>$$<br>PPO 的目标是最大化目标函数：<br>$$<br>L_{CLIP} &#x3D; min( r_t * A_t , clip(r_t, 1-ε, 1+ε) * A_t )<br>$$<br>r_t * A_t 是标准的策略梯度目标。</p>
<p>clip(r_t, 1-ε, 1+ε) * A_t 是被超参数 ε 约束的目标。clip 函数会强制策略比率 r_t 不能超出 [1-ε, 1+ε] 这个区间。</p>
<p>通过min挑选二者中较小的值，可以防止 r_t 变得太大而大幅度更新，放置了梯度过大。</p>
<p>最后使用梯度更新策略模型的参数。</p>
</li>
<li><p>重复：不断重复 1-7 步，让在线模型在“奖励”的引导和“KL 惩罚 + PPO 裁剪”的约束下，逐步地、稳定地学会生成更符合人类偏好的回答。</p>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><h4 id="解释PPO中的“策略（Policy）”和“价值（Value）”函数的作用"><a href="#解释PPO中的“策略（Policy）”和“价值（Value）”函数的作用" class="headerlink" title="解释PPO中的“策略（Policy）”和“价值（Value）”函数的作用"></a>解释PPO中的“策略（Policy）”和“价值（Value）”函数的作用</h4><p>策略函数的作用是<strong>将当前的状态映射到一个行动上</strong>。</p>
<p>当前的状态是到目前为止所有的上下文，包含输入的 prompt 和模型的思考与回复。行动是模型接下来要生成的下一个 token。策略函数是负责做出决策的组件，就像是模型的大脑，负责根据所有的状态来决定下一步的行动是什么。这也是我们要优化的目标。</p>
<p>价值函数的作用是评价当前行动的优劣程度。主要用来减少梯度方差，稳定训练过程。PPO 使用价值函数来计算一个优势度。用实际获得的奖励减去模型预测的奖励。根据这个优势程度来更新策略。</p>
</li>
</ul>
<hr>
<ul>
<li><h4 id="相比于传统的强化学习算法，PPO的“近端”更新策略有什么优势"><a href="#相比于传统的强化学习算法，PPO的“近端”更新策略有什么优势" class="headerlink" title="相比于传统的强化学习算法，PPO的“近端”更新策略有什么优势"></a>相比于传统的强化学习算法，PPO的“近端”更新策略有什么优势</h4><p>优势在于可以限制更新的幅度。更新更稳定、高效、简单。</p>
<p>PPO 会计算一个比率，这个比率可以衡量新策略选择该动作的概率是旧策略的多少倍。如果比率大于一，说明这个动作发生概率在增大，反之亦然。</p>
<p>PPO 引入了一个超参数，相当于在比率的周围定义了一个安全边界。</p>
<p>当我们发现优势很大，想要更新策略以增加动作发生概率时，这个安全便捷会限制更新的幅度，使我们不会一次性更新很大。</p>
</li>
</ul>
<hr>
<h4 id="2-DPO"><a href="#2-DPO" class="headerlink" title="2. DPO"></a>2. DPO</h4><ul>
<li><h4 id="DPO为什么被称为“直接”偏好优化？它与PPO最大的不同在于哪里"><a href="#DPO为什么被称为“直接”偏好优化？它与PPO最大的不同在于哪里" class="headerlink" title="DPO为什么被称为“直接”偏好优化？它与PPO最大的不同在于哪里"></a>DPO为什么被称为“直接”偏好优化？它与PPO最大的不同在于哪里</h4><p>DPO 被称为直接，是因为它绕过了整个传统 RLHF 流程中最复杂、最间接的步骤，建立了一条从人类偏好到模型参数更新的直接通路。</p>
<p>传统的 RLHF 不直接使用人类偏好数据，而是用这些数据去训练一个奖励模型，用 RM 的打分来间接反映人类偏好。并且 PPO 的过程中，模型的目标变成了最大化分数。</p>
<p>而 DPO 没有以上的步骤，其通过数学推导证明了 RLHF 的优化目标可以转化为一个损失函数，这个损失函数可以直接作用于语言模型，利用人类偏好数据来进行优化。</p>
<img src="/2025/08/23/LLM-MoE-RL-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/792701f120958b85e2a58d82bbd1146a.png">

<p>在 DPO 的训练过程中，只有策略模型和参考模型。</p>
<p><strong>DPO 的工作循环</strong>：</p>
<ol>
<li><p>采样：从预先准备好的人类偏好数据集中，取出一个偏好对。这个偏好对中包含了 prompt（x)，较好的回答(y_w)，较差的回答(y_1)，三部分。</p>
</li>
<li><p>计算策略模型的概率：将（x, y_w）这个组合输入到策略模型中，模型会计算出在给定 x 的条件下，生成 y_w 这个完整序列的总对数概率，记为 log_prob_π_θ(y_w) 。同样的，将（x，y_1）输入到策略模型并计算出 log_prob_π_θ(y_1) 。</p>
<p>计算总对数概率的过程实际上是基于概率链式法则来计算的：<br>$$<br>P(y | x) &#x3D; P(t_1 | x) * P(t_2 | x, t_1) * P(t_3 | x, t_1, t_2) * … * P(t_L | x, t_1, …, t_{L-1})<br>$$<br>由于将大量的小概率值连乘，会导致结果非常小，容易出现数值下溢的问题，所以在实践中，因此使用对数概率。在对数空间中，连乘就变成了求和，这在计算上更稳定、更高效。<br>$$<br>log P(y | x) &#x3D; Σ log P(t_i | x, t_1, …, t_{i-1})<br>$$</p>
</li>
<li><p>计算参考模型的概率：跟 2 相似，将（x, y_w）和（x，y_1）输入到参考模型中，计算出总对数概率，记为 log_prob_π_ref(y_w) 和 log_prob_π_ref(y_1) 。</p>
</li>
<li><p>计算对数概率差：</p>
<p>获胜回答的对数概率差为<br>$$<br>diff_w &#x3D; log_prob_π_θ(y_w) - log_prob_π_ref(y_w)<br>$$<br>落败回答的对数概率差为<br>$$<br>diff_l &#x3D; log_prob_π_θ(y_l) - log_prob_π_ref(y_l)<br>$$<br>diff_w 衡量了我们的策略模型相比于参考模型，在生成好答案方面的进步有多大。diff_l 衡量了在生成坏答案方面的退步有多大。</p>
</li>
<li><p>计算隐式奖励差：将上述两个差值再相减，并乘以超参数 β<br>$$<br>reward_diff &#x3D; β * (diff_w - diff_l)<br>$$<br>reward_diff 可以被看作是当前模型 π_θ 隐式地赋予 y_w 相对于 y_l 的优势分数。</p>
<p>DPO 的训练目标就是让这个分数尽可能地大。</p>
</li>
<li><p>计算最终损失：<br>   $$<br>   Loss_{DPO} &#x3D; -log(sigmoid(reward_diff))<br>   $$</p>
</li>
<li><p>反向传播：通过标准反向传播算法来更新参数。</p>
</li>
<li><p>重复：不断重复 1-7 步。</p>
</li>
</ol>
<hr>
</li>
<li><h4 id="描述DPO是如何利用“偏好对”（Preference-Pairs，即⼀个“更好”的回答和⼀个“更差”的回答）来直接优化语言模型的。"><a href="#描述DPO是如何利用“偏好对”（Preference-Pairs，即⼀个“更好”的回答和⼀个“更差”的回答）来直接优化语言模型的。" class="headerlink" title="描述DPO是如何利用“偏好对”（Preference Pairs，即⼀个“更好”的回答和⼀个“更差”的回答）来直接优化语言模型的。"></a>描述DPO是如何利用“偏好对”（Preference Pairs，即⼀个“更好”的回答和⼀个“更差”的回答）来直接优化语言模型的。</h4><p>偏好对会调整 π_θ 的参数，使得在下一次遇到类似的 Prompt 时：</p>
<ul>
<li>模型生成 y_w 这类回答的<strong>概率会上升</strong>。</li>
<li>模型生成 y_l 这类回答的<strong>概率会下降</strong>。</li>
</ul>
<p>同时，由于 π_ref 的存在（它隐式地起到了 KL 散度正则化的作用），模型的更新不会过于“激进”，确保了 π_θ 不会与它微调前的 SFT 模型偏离得太远。</p>
</li>
</ul>
<hr>
<ul>
<li><h4 id="相比-PPO，DPO-在训练稳定性和效率方面有哪些优势"><a href="#相比-PPO，DPO-在训练稳定性和效率方面有哪些优势" class="headerlink" title="相比 PPO，DPO 在训练稳定性和效率方面有哪些优势"></a>相比 PPO，DPO 在训练稳定性和效率方面有哪些优势</h4><p>DPO 相比 PPO 而言，核心优势在于 PPO 是在线强化学习算法，而 DPO 则是一个离线监督学习算法，</p>
<p>DPO 是离线的，它在一个预先收集好的人类偏好数据集上进行训练。整个训练过程中不需要模型进行任何的在线生成，训练数据也固定不变，于是 DPO 的训练过程变成了一个确定性的，可重复的损失最小化问题。这样稳定的流程也使得训练过程非常稳定，不会出现损失突然上升等情况。</p>
<p>DPO 没有在线采样的步骤，其只需要计算当前模型和参考模型在一个固定的偏好对上的概率，这个计算要比 PPO 快很多。</p>
</li>
</ul>
<hr>
<h3 id="3-GRPO"><a href="#3-GRPO" class="headerlink" title="3. GRPO"></a>3. GRPO</h3><ul>
<li><h4 id="GRPO-是对-DPO-的改进么"><a href="#GRPO-是对-DPO-的改进么" class="headerlink" title="GRPO 是对 DPO 的改进么"></a>GRPO 是对 DPO 的改进么</h4><p>GRPO 是对 DPO 的改进，旨在解决 DPO 的一个核心局限问题，从而更充分的利用人类偏好信息。</p>
<p>DPO 的训练数据是大量的偏好对，他的损失函数处理这一对回答。但是现实世界的偏好是多层次的，而DPO会造成这种信息的浪费，并且每次只能学习两个信息之间的偏好，无法建立上下文的关联。</p>
<p>GRPO 对 DPO 进行了改进，从一对一变成了一组多。它不再孤立地看待每一个偏好对，而是将一个 Prompt 下的一组多个回复及其排序作为一个整体来进行优化。</p>
</li>
</ul>
<hr>
<ul>
<li><h4 id="理解GRPO的核心思想，特别是它如何利用⼀组生成的回复来更有效地进行优化"><a href="#理解GRPO的核心思想，特别是它如何利用⼀组生成的回复来更有效地进行优化" class="headerlink" title="理解GRPO的核心思想，特别是它如何利用⼀组生成的回复来更有效地进行优化"></a>理解GRPO的核心思想，特别是它如何利用⼀组生成的回复来更有效地进行优化</h4><p>GRPO 的世界中，是由有序的列表构成的。其引入了 <strong>Plackett-Luce 模型</strong>，来计算一个特定排序出现的概率。GRPO 就是将 DPO 中那个隐式奖励的数学形式，代入到这个 Plackett-Luce 模型中，从而构建出了它的损失函数。</p>
<p>GRPO 的最终损失函数 L_GRPO，可以被直观地理解为对一个组内所有优势对的 DPO 损失的加权总和。</p>
<p>GRPO 拥有更丰富的梯度信号，因为可以从一组序列偏好对中获得综合梯度。同时可以整体的看待排行榜。</p>
</li>
</ul>
<hr>
<ul>
<li><h4 id="在需要复杂推理或多样化生成的任务中，GRPO可能比DPO或PPO更有优势吗？为什么？"><a href="#在需要复杂推理或多样化生成的任务中，GRPO可能比DPO或PPO更有优势吗？为什么？" class="headerlink" title="在需要复杂推理或多样化生成的任务中，GRPO可能比DPO或PPO更有优势吗？为什么？"></a>在需要复杂推理或多样化生成的任务中，GRPO可能比DPO或PPO更有优势吗？为什么？</h4><p>GRPO 有更大的优势。</p>
<p>在需要复杂推理的任务中，思维链一般都很复杂且很长。</p>
<p>PPO 的奖励机制难以合理衡量两个思维链的好坏程度，比如一个过程全对但是结果错误的思维链和一个过程错误但结果正确的思维链，PPO 的奖励模型难以精确判断或容易错误判断其好与坏。</p>
<p>DPO 每次只能比较两个思维链的优势，其失去了全局视角。</p>
<p>GRPO 则可以利用一个完整的推理链排行榜，全局性的学习到他们共有的推理模式或思考方式，而不仅仅局限于谁比谁好的二元判断。且 GRPO 还可以包容优劣程度类似的情况。同时 GRPO 还从数据和优化目标层面，鼓励模型生成维护一个多模态的输出分布，这有注意完成多样化生成任务。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大语言模型</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>MoE</tag>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>北航操作系统-OS-lab3-实验报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1. 思考题"></a>1. 思考题</h1><ol>
<li><p>首先，MIPS中的虚拟内存结构如下：<br><img src="/pictures/0e3f01a8e1ec0c314b9baa207a77181.png"></p>
<p>因此，base_pgdir中建立了pages和envs的物理地址与虚存中pages和envs的虚拟地址之间的关系，这也同样解释了在map_segment中传入的UPAGES和UENVS的含义，就是pages和envs的虚存首地址。</p>
<p>之后，由于MOS的内核数据共享机制，需要把UTOP以上UVPT以下，即pages和envs的数据暴露给用户空间，因为base_pgdir中已经有分配好的映射关系，因此需要把UTOP到UVPT所对应的页目录项赋值给每个进程的页目录。又由于用户自身的4MB页表放置在UVPT，因此页目录自映射项相对于页目录的偏移即为PDX(UVPT)，因此需要把e-&gt;env_pgdir[PDX(UVPT)] &#x3D; PADDR(e-&gt;env_pgdir) | PTE_V;</p>
</li>
<li><p>在load_icode中，遍历了每一个程序头表，然后调用了elf_load_seg函数来加载段内容到内存中，并在进程的页目录中建立映射关系。其传参如下图：<br><img src="/pictures/65237be8dbc05512f25aeed37fb582e.png"></p>
<p>从图中可以看到，最后一个参数是e，也就是进程控制块的指针。在elf_load_seg函数中，直接将第四个参数，也就是data，传递给了load_icode_mapper函数，因此data就是e，是进程控制块的指针。</p>
<p>它的作用是要在页目录中建立映射关系，因此需要e-&gt;env_pgdir和e-&gt;env_asid。因此没有这个参数不可以，否则CPU无法通过tlb找到物理内存中的程序或数据。</p>
</li>
<li><p>需要处理三种页面的加载情况：1. 从va开始，未页对齐的部分。2. 开头页对齐的数据页面。3. 超出bin_size部分的.bss内容。<br>第一种情况下，需要在分配的物理页框的offset位置开始写入数据。<br>第二种情况下，在分配的物理页框中写入len字节的数据。<br>第三种情况下，只分配页框，不写入数据。</p>
</li>
<li><p>虚拟地址。CPU访问的都是虚拟地址。</p>
</li>
<li><p>0号异常handle_int定义在kern&#x2F;genex.S中，代码如下：<br><img src="/pictures/e0de14adf62d3822146e2ce8d4b107d.png"></p>
<p>2号异常用grep没有找到，仅在exception_handlers中有。<br>3、4号异常是tlb_miss，异常处理函数是do_tlb_refill</p>
</li>
<li><p>首先，在触发时钟中断后，CPU会跳转至异常处理入口，之后运行异常处理指令。异常处理指令首先会根据异常类型跳转到不同的异常处理函数中，针对时钟中断，会跳转到时钟中断函数。在内部，会判断是否是时钟中断，如果是的话会跳转到time_irq函数中，在进行一些操作后跳转到schedule函数。schedule函数会判断当前进程进程是否需要切换，如果需要切换的话，会将当前进程移至sched队列末尾，并选取sched队列头的进程去运行。从而实现进程的调度。</p>
</li>
</ol>
<h1 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2. 难点分析"></a>2. 难点分析</h1><ol>
<li><p>进程的创建过程需要好好理解。进程的创建大致可以分为两部分：env_alloc 和 load_icode。首先需要申请一个进程控制块，并配置好信息；之后需要将可执行文件中的段数据加载到内存中，并在页目录中建立映射关系。最后再将该进程控制块从空间队列移至调度队列中。</p>
</li>
<li><p>进程的调度。进程的自动调度主要依靠时间片轮转来实现。每个进程拥有一个优先级，这个优先级实质上就是可运行时间片的个数。优先级越高，可运行时间片数目越多，进程运行的时间就越长。每次时间片截至，就会触发时钟中断，之后CPU进入异常处理函数进行处理。如果是时钟中断异常，最后会调用schedule函数。schedule函数首先判断当前进程是否需要切换，有很多原因可以使得当前进程需要切换，比如yield为1，当前进程是NULL，当前进程时间片结束了，当前进程不可运行等等。如果满足以上条件，schedule函数会选择下一个可运行进程并接着运行。如果不满足，说明当前进程仍然可以继续运行，因此时间片计数减一，然后接着运行。</p>
</li>
<li><p>共享页目录。MOS中特有的功能就是将内核的一些数据暴露在用户空间，从而让他们能够访问到内核的数据，具体来说就是 pages 和 envs 。这两个控制块的映射关系被复制到了每一个进程的页目录中，因此所有的用户进程访问这两个的地址，都可以通过二级页表来访问到。</p>
</li>
</ol>
<h1 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3. 实验体会"></a>3. 实验体会</h1><ol>
<li>本次实验总体难度适中，容易理解，但是细节很多，因此课后需要认真复习和研究，明白每一处操作都在干什么。例如共享页目录的时候，要理解MOS是如何给每一个用户进程共享的，实际上是通过复制页目录项，也就是共享二级页表，来实现共享特定的空间内容。同时例如elf_load_seg 函数是如何将段头表内的数据加载到物理内存中并进行映射的，其通过了load_icode_mapper这个回调函数来实现这一操作。回调函数负责将一页的内容加载到内存中并建立映射关系，具体如何加载，加载多少，这些细节都是要研究的。</li>
</ol>
<h1 id="4-原创声明"><a href="#4-原创声明" class="headerlink" title="4. 原创声明"></a>4. 原创声明</h1><p>本片报告所有内容均为个人原创。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MOS</tag>
      </tags>
  </entry>
  <entry>
    <title>北航操作系统-OS-lab1-实验报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1. 思考题"></a>1. 思考题</h1><ol>
<li><p>首先利用如下简单C语言程序(hello.c)来研究x86工具链和mips工具链的区别</p>
<p><img src="/pictures/5b095e4cf090a93ca2d0a95f5a8a1a2.png"></p>
</li>
</ol>
<p>先利用x86工具链编译并反汇编目标文件代码，并观察</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line">objdump -DS hello.o &gt; text.txt</span><br></pre></td></tr></table></figure>

<p>最终text.txt内容如下：</p>
<p><img src="/pictures/f3049ff3f5a73f6137d42b1bd89a79f.png"></p>
<p>再利用mips工具链编译后反汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mips-linux-gnu-gcc -c hello.c -o hello.o</span><br><span class="line">mips-linux-gnu-objdump -DS hello.o &gt; text.txt</span><br></pre></td></tr></table></figure>

<p>最终输出如下：</p>
<p><img src="/pictures/9bb4fcb46e6ef43506536ce31f895d5.png"></p>
<p>之后再让x86的gcc把hello.c编译成可执行文件，之后再反汇编，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br><span class="line">objdump -DS hello &gt; text.txt</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/pictures/b5471bd18ddec43d40cfe5bcfe23549.png"></p>
<p>可以看到call指令后面填充了 puts@plt，说明在链接的时候这块函数地址被填上了。</p>
<p>再用mips工具链重复以上步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mips-linux-gnu-gcc hello.c -o hello</span><br><span class="line">mips-linux-gnu-objdump hello &gt; text.txt</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/pictures/acb897a296a2b5636449b1cfed4f6ed.png"></p>
<p>可以看到 lui 指令后的立即数不是0x0了，addiu 指令后的里结束也不是0了。此时 t9 寄存器的值不一样了，说明链接时函数地址被填上了。</p>
<p>objdump -DS 中，&#x3D;&#x3D;-D 表示 –disassemble-all，即反汇编所有部分的内容；-S表示 –source，即显示与反汇编汇合的源代码&#x3D;&#x3D;。 </p>
<ol start="2">
<li>先用 make 生成MOS内核的ELF文件，之后利用 .&#x2F;readelf target&#x2F;mos 去解析，结果如下：</li>
</ol>
<p><img src="/pictures/d9af4cd6b81b26037a6acdc833cbdb0.png"></p>
<p>以下是用系统工具readelf -S 解析的mos内核：</p>
<p><img src="/pictures/f9577e6bc4d019915c7933f78b04dca.png"></p>
<p>经过尝试发现 .&#x2F;readelf readelf 命令没有任何反应，但是 .&#x2F;readelf hello 命令可以正常输出。下面探究原因。通过输出 .&#x2F;readelf -h readelf 来解析readelf文件的文件头信息，内容如下：</p>
<p><img src="/pictures/b76c288abc8d1e18afecd8ee0c19e18.png"></p>
<p>而解析hello可执行文件的内容如下：</p>
<p><img src="/pictures/225fcb25506d0628bda8f58ac885633.png"></p>
<p>再结合makefile中的不同：</p>
<p><img src="/pictures/e95db4493607c7dc9c94d700aed6d0d.png"></p>
<p>可以看到 make hello 中多了 -m32 -static -g 三个参数。因此初步判断是 -m32 使得hello文件是32位的，而readelf默认生成为64位的了。我们的readelf只能解析32位的elf文件，因此无法解析自己。为了证明我们的判断，我们用readelf -h mos去查看mos内核的文件头，内容如下：</p>
<p><img src="/pictures/9387f11c2f2175f5d931b5aa53dfc3a.png"></p>
<p>可以看到mos内核也是32位的，因此我们的readelf可以解析mos内核。<br>经查询资料发现，系统工具readelf可以解析32位和64位的ELF文件格式。<strong>因此可以确定我们的readelf只能解析32位的程序，由于其本身是64位的，因此其自己无法解析自己，而系统工具readelf可以解析。</strong></p>
<ol start="3">
<li>实验中使用QEMU仿真模拟器来模拟硬件，而QEMU支持直接加载ELF文件格式的内核，因此QEMU相当于已经执行了bootloader的stage1过程了，此时硬件已经被初始化了，可以直接使用。而在stage2阶段，QEMU会加载内核到内存，之后跳转到内核的入口，从而完成启动。&#x3D;&#x3D;因此即使内核入口不是硬件的启动入口地址，也可以通过QEMU来跳转到内核的入口&#x3D;&#x3D;。</li>
</ol>
<h1 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2. 难点分析"></a>2. 难点分析</h1><ol>
<li>首先是ELF文件格式的理解问题。ELF文件格式包含多种类型的文件，包括可重定位文件、可执行文件、共享对象文件等。ELF文件由几部分组成：首先是文件头，用来说明ELF文件的性质等信息，其中给出了段头表和节头表的偏移、大小等信息。其次是节头表，里面存储了文件的节的信息，地址等，用来在链接的时候把相同的节放在同一段中。还有段头表，也叫程序头表，它的作用是表明每一段的虚拟地址，方便在执行的时候把相应的段放入内存中。</li>
</ol>
<p>其中可重定位文件和可执行文件的区别如下：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>可重定位文件（Relocatable Files）</th>
<th>可执行文件（Executable Files）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>文件类型</strong></td>
<td><code>ET_REL</code>（1）</td>
<td><code>ET_EXEC</code>（2）</td>
</tr>
<tr>
<td><strong>主要用途</strong></td>
<td>链接阶段，生成可执行文件或共享库</td>
<td>直接由操作系统加载并执行</td>
</tr>
<tr>
<td><strong>节（Sections）</strong></td>
<td>包含 <code>.text</code>、<code>.data</code>、<code>.bss</code> 等</td>
<td>通常不包含节，而是包含段（Segments）</td>
</tr>
<tr>
<td><strong>段（Segments）</strong></td>
<td>无程序头表</td>
<td>包含程序头表，描述如何加载到内存</td>
</tr>
<tr>
<td><strong>重定位信息</strong></td>
<td>包含重定位信息（如 <code>.rel.text</code>）</td>
<td>通常不包含重定位信息（除非动态链接）</td>
</tr>
<tr>
<td><strong>符号表</strong></td>
<td>包含完整的符号表（<code>.symtab</code>）</td>
<td>可能不包含完整的符号表</td>
</tr>
<tr>
<td><strong>入口点地址</strong></td>
<td>无入口点地址（<code>e_entry</code> 为 0）</td>
<td>包含入口点地址（<code>e_entry</code>）</td>
</tr>
<tr>
<td>2. 注意指针的加法。如果指针是void* 类型，例如 void * p &#x3D; 0x0，则 p + 3 &#x3D; 0x3，即p移动1* num个字节。&#x3D;&#x3D;而如果指针是其他类型，例如 int * p &#x3D;0x0，则 p + 3 &#x3D; 0xb，即p移动sizeof(int)* num个字节&#x3D;&#x3D;。因此我们想让指针只移动num个字节，需要保证指针是 void * 类型，或者指针指向的类型是一字节的。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="3">
<li><p>在Linker Script 中书写段的内存定向时，要先确定放置的地址，此时需要用 . &#x3D; address;来表示接下来的段放在哪里。注意 &#x3D; 两边要有空格，以及行尾要有分号。之后可以接着写<br>.text : {* (.text)}<br>.data : {* (.data)}<br>等，用来表示把所有.text节组成的段放在相应地址上。</p>
</li>
<li><p>内核入口是在 Linker Script 中用ENTRY( _ start )定义的，即内核执行的第一行代码是_start函数。在_start函数中，我们设置了栈指针的位置，并跳转到了mips_init函数完成内核的C语言部分。</p>
</li>
<li><p>在printk函数的书写部分，我们需要注意每一个符号的判断，要记得初始化数据。最终的代码如下所示：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">19</span>         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> <span class="number">20</span>                 <span class="comment">/* scan for the next &#x27;%&#x27; */</span></span><br><span class="line"> <span class="number">21</span>                 <span class="comment">/* Exercise 1.4: Your code here. (1/8) */</span></span><br><span class="line"> <span class="number">22</span>                 <span class="keyword">while</span> ((*fmt)!=<span class="string">&#x27;\0&#x27;</span> &amp;&amp; (*fmt)!=<span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line"> <span class="number">23</span>                         out(data, fmt, <span class="number">1</span>);</span><br><span class="line"> <span class="number">24</span>                         fmt++;</span><br><span class="line"> <span class="number">25</span>                 &#125;</span><br><span class="line"> <span class="number">26</span>                 <span class="comment">/* flush the string found so far */</span></span><br><span class="line"> <span class="number">27</span>                 <span class="comment">/* Exercise 1.4: Your code here. (2/8) */</span></span><br><span class="line"> <span class="number">28</span>                 <span class="keyword">if</span> ((*fmt) == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"> <span class="number">29</span>                         <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">30</span>                 &#125;</span><br><span class="line"> <span class="number">31</span>                 <span class="comment">/* check &quot;are we hitting the end?&quot; */</span></span><br><span class="line"> <span class="number">32</span>                 <span class="comment">/* Exercise 1.4: Your code here. (3/8) */</span></span><br><span class="line"> <span class="number">33</span>                 fmt++;</span><br><span class="line"> <span class="number">34</span>                 <span class="comment">/* we found a &#x27;%&#x27; */</span></span><br><span class="line"> <span class="number">35</span>                 <span class="comment">/* Exercise 1.4: Your code here. (4/8) */</span></span><br><span class="line"> <span class="number">36</span>                 ladjust = <span class="number">0</span>;</span><br><span class="line"> <span class="number">37</span>                 padc = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"> <span class="number">38</span>                 <span class="keyword">if</span> ((*fmt) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line"> <span class="number">39</span>                         ladjust = <span class="number">1</span>;</span><br><span class="line"> <span class="number">40</span>                         fmt++;</span><br><span class="line"> <span class="number">41</span>                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*fmt) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"> <span class="number">42</span>                         padc = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="number">43</span>                         fmt++;</span><br><span class="line"> <span class="number">44</span>                 &#125;</span><br><span class="line"> <span class="number">45</span>                 <span class="comment">/* check format flag */</span></span><br><span class="line"> <span class="number">46</span>                 <span class="comment">/* Exercise 1.4: Your code here. (5/8) */</span></span><br><span class="line"> <span class="number">47</span>                 width = <span class="number">0</span>;</span><br><span class="line"> <span class="number">48</span>                 <span class="keyword">while</span> ((*fmt) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (*fmt) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"> <span class="number">49</span>                         width = width*<span class="number">10</span> + (*fmt) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="number">50</span>                         fmt++;</span><br><span class="line"> <span class="number">51</span>                 &#125;</span><br><span class="line"> <span class="number">52</span>                 <span class="comment">/* get width */</span></span><br><span class="line"> <span class="number">53</span>                 <span class="comment">/* Exercise 1.4: Your code here. (6/8) */</span></span><br><span class="line"> <span class="number">54</span>                 long_flag = <span class="number">0</span>;</span><br><span class="line"> <span class="number">55</span>                 <span class="keyword">while</span> ((*fmt) == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line"> <span class="number">56</span>                         long_flag = <span class="number">1</span>;</span><br><span class="line"> <span class="number">57</span>                         fmt++;</span><br><span class="line"> <span class="number">58</span>                 &#125;</span><br><span class="line"> <span class="number">59</span>                 <span class="comment">/* check for long */</span></span><br><span class="line"> <span class="number">60</span>                 <span class="comment">/* Exercise 1.4: Your code here. (7/8) */</span></span><br><span class="line"> <span class="number">61</span> </span><br><span class="line"> <span class="number">62</span>                 neg_flag = <span class="number">0</span>;</span><br><span class="line"> <span class="number">63</span>                 <span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line"> <span class="number">64</span>                 <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line"> <span class="number">65</span>                         <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line"> <span class="number">66</span>                                 num = va_arg(ap, <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line"> <span class="number">67</span>                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">68</span>                                 num = va_arg(ap, <span class="type">int</span>);</span><br><span class="line"> <span class="number">69</span>                         &#125;</span><br><span class="line"> <span class="number">70</span>                         print_num(out, data, num, <span class="number">2</span>, <span class="number">0</span>, width, ladjust, padc, <span class="number">0</span>);</span><br><span class="line"> <span class="number">71</span>                         <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">72</span> </span><br><span class="line"> <span class="number">73</span>                 <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"> <span class="number">74</span>                 <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line"> <span class="number">75</span>                         <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line"> <span class="number">76</span>                                 num = va_arg(ap, <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line"> <span class="number">77</span>                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">78</span>                                 num = va_arg(ap, <span class="type">int</span>);</span><br><span class="line"> <span class="number">79</span>                         &#125;</span><br><span class="line"> <span class="number">80</span> </span><br><span class="line"> <span class="number">81</span>                         <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 82                          * Refer to other parts (case &#x27;b&#x27;, case &#x27;o&#x27;, etc.) and func &#x27;print_num&#x27; to</span></span><br><span class="line"><span class="comment"> 83                          * complete this part. Think the differences between case &#x27;d&#x27; and the</span></span><br><span class="line"><span class="comment"> 84                          * others. (hint: &#x27;neg_flag&#x27;).</span></span><br><span class="line"><span class="comment"> 85                          */</span></span><br><span class="line"> <span class="number">86</span>                         <span class="comment">/* Exercise 1.4: Your code here. (8/8) */</span></span><br><span class="line"> <span class="number">87</span>                         <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">88</span>                                 neg_flag = <span class="number">1</span>;</span><br><span class="line"> <span class="number">89</span>                                 num = -num;</span><br><span class="line"> <span class="number">90</span>                         &#125;</span><br><span class="line"> <span class="number">91</span>                         print_num(out, data, num, <span class="number">10</span>, neg_flag, width, ladjust, padc, <span class="number">0</span>);</span><br><span class="line"> <span class="number">92</span>                         <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">93</span> </span><br><span class="line"> <span class="number">94</span>                 <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line"> <span class="number">95</span>                 <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line"> <span class="number">96</span>                         <span class="keyword">if</span> (long_flag) &#123;</span><br><span class="line"> <span class="number">97</span>                                 num = va_arg(ap, <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line"> <span class="number">98</span>                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">99</span>                                 num = va_arg(ap, <span class="type">int</span>);</span><br><span class="line"><span class="number">100</span>                         &#125;</span><br><span class="line"><span class="number">101</span>                         print_num(out, data, num, <span class="number">8</span>, <span class="number">0</span>, width, ladjust, padc, <span class="number">0</span>);</span><br><span class="line"><span class="number">102</span>                         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>同时注意变长参数的使用方法，如下图所示：</p>
<p><img src="/pictures/2e37b2eaf9e998328eeddaf04db883c.png"><br>需要先用 va_list ap;声明一个变量。再用 va_start(ap, lastarg);进行初始化。<br>每次获取参数可以用 va_arg(ap, int);获取。其中int为该变量的类型。<br>最后结束的时候要用 va_end(ap);来结束变量。</p>
<h1 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3. 实验体会"></a>3. 实验体会</h1><p>本次实验需要认真体会，反复观看，才能很好的掌握整体逻辑。我在前几次看指导书的时候，都有种不知所云的感觉，感觉读了但不知道在说什么；对于做题也只是简单的完成本题的任务，但不清楚这个题目在整体启动过程中是哪一步骤，发挥了什么作用。这使得我对于整体开机的顺序还是模糊的。</p>
<p>在初次完成任务后，我又在写实验报告的时候认真重温了一遍指导书，这才稍有眉目，多了解了一些内容，并明确了每一部分是在干什么。</p>
<p>我自己理解了一点lab1的内容，不知道对不对，想请大家斧正一下。真正的计算机启动主要分为：硬件启动和内核启动。其中硬件启动在Linux系统上是，当按下电源后，计算机先运行BIOS的代码，这部分代码是存储在断电不丢失的ROM上的，因为这是最最最开始运行的代码，不会被其他方式加载，只能存储在硬件上。之后BIOS进行硬件自检后加载MBR，并运行MBR中的bootloader部分，Linux系统中主要是GRUB或LILO。bootloader分为两部分：stage1先简单初始化硬件，之后初始化RAM，加载stage2代码到RAM中，跳转到stage2入口；stage2再初始化相关硬件，加载内核到内存中（这部分是lab1实验完成的部分），配置内核参数，然后跳转到内核的入口，即把CPU控制权给内核，之后便运行内核代码完成进一步初始化。我们的lab1实验主要是聚焦于加载内核到内存中这一阶段？我们用的是QEMU模拟器，支持直接加载ELF格式的内核，我理解的意思就是QEMU自动完成了加载内核到内存这一步之前的所有操作？我们在实验中通过make来编译链接出mos内核，也就是说内核在make之前是不存在的，那真实启动中，是bootloader来完成make这一任务来创生出内核么？还是通过给定路径去解压下载（这样的话内核一开始是存在的）？这部分完成后只是有了内核，但是还没放到内存中，内核本质是ELF文件格式，它不能自己把自己放到内存中，只是通过段头表给出了每段的虚拟地址而已，那是不是OS根据其段头表的地址把内核的段放到内存中的？ELF中有内核的入口地址en_entry，是不是OS在配置好内核参数后，跳转到entry运行，从而完成跳转到内核入口这一过程？</p>
<p>如果以上内容大致方向理解正确，那我们lab1实验其实没有干任何OS要干的事（应该）只是在完成内核信息而已。我们写的readelf.c跟内核本身没关系，只是为了帮助我们理解ELF文件格式而已；我们写的 LinkerScript 的链接地址，在make后会决定mos内核的段头表的地址，等待后续被OS参考并放入内存；我们补充的_start.S的代码，是内核的入口函数的代码，也是CPU控制权交给内核后运行的代码，之后的 mips_init 会进一步初始化内核。这么多工作其实都只是在完善mos内核而已，我们也没有真正把内核放入内存中，只是给出了地址。所以OS的工作我们还没做？</p>
<h1 id="4-原创声明"><a href="#4-原创声明" class="headerlink" title="4. 原创声明"></a>4. 原创声明</h1><p>以上内容大部分为原创。少部分参考了<a href="https://www.cnblogs.com/emodiary121/p/16061297.html">北航操作系统课程lab1实验报告 - 南风北辰 - 博客园 (cnblogs.com)</a>该博客。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MOS</tag>
      </tags>
  </entry>
  <entry>
    <title>北航操作系统-OS-lab5-实验报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1. 思考题"></a>1. 思考题</h1><p><img src="/pictures/e1b6889ddeaca6282347fbf49cdeb99.png"></p>
<p>使用kseg0去读写设备，会导致读取的数据可能不正确。因为kseg0段使用cache来访存，当CPU访问一个物理地址时，会先检查该地址所在块是否在cache中，如果在那么直接从cache中进行读或写，如果不在那么申请一块并从内存中读取该块的内容到cache中，并重新访问。这样做之所以可行是因为对cache中的块的数据进行操作等效于对内存直接操作。但是如果外设对内存的操作不会引起cache的变化，如果外设对内存中的数据进行了修改，那么cache中对应块没有随之修改，这就会导致cache中的块的数据和内存中块数据不一致，导致CPU访问的时候读取到了错误的数据。同理CPU的写入也会先写进cache，之后再回写到内存中，这样会导致外设有可能读不到CPU写入的数据。</p>
<p><img src="/pictures/5c89083bca3123eda148ac7577691ef.png"></p>
<p>一个磁盘块的大小是4KB，也就是4096字节；而一个文件控制块FCB的大小固定为256字节，因此一个磁盘块中最多能存储16个文件控制块。一个目录最多拥有1024个磁盘块，因此最多能有16384个文件。我们文件系统支持单个文件最多拥有1024个磁盘块，也就是4MB。</p>
<p><img src="/pictures/e121869fc3cd7e5d1b24b8a397e2c50.png"><br>缓冲区的范围是 [DISKMAP, DISKMAP + DISKMAX]，因此其大小为 DISKMAX &#x3D; 0x40000000，也就是 1GB</p>
<p><img src="/pictures/ede1137f8fd27841376b70d65a5cd17.png"><br>fs&#x2F;serv.h 中的宏定义如下： </p>
<p><img src="/pictures/2c5919d1382ed4178244e8fda62bf9c.png"><br>其中较为重要的宏定义有：<br>PTE_DIRTY，磁盘块的脏位，标志磁盘块是否被写过。<br>SECT_SIZE，512Bytes，一个扇区的大小。<br>DISKMAP, DISKMAX，文件系统服务进程中磁盘块的起始虚拟地址和最大大小。  </p>
<p>user&#x2F;include&#x2F;fs.h中宏定义如下：</p>
<p><img src="/pictures/712af2096e25b7d626cf41a22d295bd.png"><br>其中较为重要的宏定义有：<br>MAXNAMELEN，文件名的最大长度。<br>MAXPATHLEN，文件结构的最长路径。<br>NDIRECT，文件控制块中直接记录磁盘块的数量。<br>NINDIRECT，文件控制块中间接记录磁盘块的数量。<br>MAXFILESIZE，文件的最大大小。<br>FILE_STRUCT_SIZE，文件控制块的大小。<br>struct File，文件控制块结构体的定义。</p>
<p><img src="/pictures/044d355bbacbfd2ff31b86da7b412bd.png"><br>fork 之后，父子进程会共享文件描述符和定位指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">int</span> fdnum;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = open(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;wrong when open /newmotd: %d&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	fdnum = r;</span><br><span class="line">	debugf(<span class="string">&quot;fdnum == %d\n&quot;</span>, fdnum); <span class="comment">// 拿到fdnum号</span></span><br><span class="line">	<span class="keyword">if</span> ((n = read(fdnum, buf, <span class="number">5</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;wrong when read /newmotd: %d&quot;</span>, r);</span><br><span class="line">	&#125; <span class="comment">// 读5个字符</span></span><br><span class="line">	debugf(<span class="string">&quot;read: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fdd</span>;</span></span><br><span class="line">    fd_lookup(r, &amp;fdd);</span><br><span class="line">	debugf(<span class="string">&quot;fd == %x\n&quot;</span>, fdd); <span class="comment">// fdd的值</span></span><br><span class="line">    debugf(<span class="string">&quot;now offset == %d\n&quot;</span>,fdd-&gt;fd_offset); <span class="comment">// 偏移量</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">if</span> ((id = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = read(fdnum, buf, <span class="number">5</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;child: wrong when read /newmotd: %d&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">		debugf(<span class="string">&quot;child read: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fdd</span>;</span></span><br><span class="line">        fd_lookup(r, &amp;fdd);</span><br><span class="line">		debugf(<span class="string">&quot;child: fd == %x\n&quot;</span>, fdd);</span><br><span class="line">        debugf(<span class="string">&quot;child: now offset == %d\n&quot;</span>,fdd-&gt;fd_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((n = read(fdnum, buf, <span class="number">5</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;father: wrong when read /newmotd: %d&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">		debugf(<span class="string">&quot;father read: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fdd</span>;</span></span><br><span class="line">        fd_lookup(r, &amp;fdd);</span><br><span class="line">		debugf(<span class="string">&quot;father: fd == %x\n&quot;</span>, fdd);</span><br><span class="line">        debugf(<span class="string">&quot;father: now offset == %d\n&quot;</span>,fdd-&gt;fd_offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/pictures/9585755da19de811e630b10dcacd709.png"><br>三个结构体的定义如下图：</p>
<p><img src="/pictures/13df70778f3844a88230197a06fb246.png"><br>f_name：文件名<br>f_size：文件大小<br>f_type：文件类型（文件或目录）<br>f_direct：文件直接对应的磁盘块号<br>f_indirect：文件简介对应的磁盘块号<br>f_dir：文件所在目录的文件控制块<br>f_pad：填充<br>该结构体会在存储文件信息的时候用到，在查找文件结构、访存文件信息的时候会用到，是磁盘上的物理实体。</p>
<p><img src="/pictures/9fda6c36316f222c2466188ccd36846.png"><br>fd_dev_id：访问的外设的编号，对应磁盘、控制台、管道。<br>fd_offset：在访存文件数据的时候，从多少偏移的位置开始访存。<br>fd_omode：openmode，文件的打开方式。<br>该结构体是一个内存中的数据，不是磁盘中的实体，记录文件的打开信息。</p>
<p><img src="/pictures/003936cbfea7ccccfbe045de60b94b9.png"><br>f_fd：struct Fd 类型的对象，可以通过强制类型转换来解释内存中的内容。<br>f_fileid：文件的id，用于查找Open数组。<br>f_file：struct File 类型的对象，存储访问文件的文件控制块。<br>该结构体也是一个内存中的数据，不是磁盘中的实体，跟 struct Fd 共享存储空间。<br><img src="/pictures/89f9d53a2bdc5fe8860b8386d2e3e86.png"><br>实线黑三角箭头是同步消息，消息发出者需要在消息发出后等待接收者的回信，之后才继续运行。实线折线是异步消息，消息发出后发出者无需等待，可以直接继续运行。<br>虚线是返回消息，用来唤醒等待的同步消息发出线程。<br>操作系统通过进程间通信 IPC 机制来实现通信。消息接收者如果没有收到发送者的消息，会一直让出CPU控制权，直到收到消息。</p>
<h1 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2.难点分析"></a>2.难点分析</h1><p>Lab5 的难点主要在于理解文件系统的体系结构 + 理解MOS操作系统中如何实现文件系统。</p>
<p>文件系统的体系结构主要在于文件控制块和磁盘的存储方式。首先是文件控制块，其内部包含了关于文件的诸多信息，包括文件名、文件大小、文件内容所存储到的磁盘块编号。通过一个文件的文件控制块，可以遍历文件的各种信息，从而完成对文件的访存。其次是磁盘的存储方式，磁盘由磁道、磁头、扇区组成，一般来说一个扇区的大小是512B，对于磁盘来说访存的最小单位是扇区。访问外设可以通过MMIO，也就是内存映射的方式来实现。对于CPU来说，可以通过访问特定内存地址来达到读取外设寄存器的效果。先对外设地址设定参数，之后等待外设准备就绪后就可以读取或写入特定内存地址，从而可以读取或者写入磁盘。但是直接操作扇区并不方便，为了便于管理和隐去接口细节，操作系统规定了磁盘块这一概念，一个磁盘块由相邻的几块扇区组成，大小一般是4KB，操作系统以磁盘块为最小操作单元来访存外设。</p>
<p>MOS中首先编写了设备驱动程序，用来访存外设寄存器，并实现了读取或者写入磁盘块的函数，这样就可以操作一整个磁盘块。之后MOS操作系统中使用一个文件系统服务进程来相应用户程序的请求，二者通过IPC机制来通信。具体过程为，用户进程调用顶层接口，例如 open，read，write，remove等，这些顶层接口的实现用会调用fsipc_open，fsipc_map，fsipc_remove等，这些不同的函数最终都会调用fsipc，并传入请求的类型，fsipc中通过ipc_send和ipc_recv来与文件系统服务进程通信，文件系统系统服务进程通过ipc传入的参数来判断请求类型，并调用相应的file_open，file_read，file_remove等操作，这些操作中又会调用底层的serve_open，serve_remove等函数，最后由这些函数和内存、磁盘交互。</p>
<p>同时文件系统服务进程还采用了缓冲区来提高访存外设的速度。在用户open一个文件的时候，文件系统服务进程就会把该文件的所有磁盘块读取到缓冲区，并为之创建文件描述符，里面含有文件控制块和相关信息，然后在用户进程的对应虚存空间中映射文件磁盘块的页面，之后在用户read或者write的时候，就可以通过共享页面来访问内存中的磁盘信息。</p>
<h1 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3. 实验体会"></a>3. 实验体会</h1><p>本单元的理论和实践同样都很重要，需要细细体会，反复阅读，这样才能细致的掌握文件系统的细节信息，了解文件的组织、访存方法，了解用户进程访问文件的过程和操作系统的工作。</p>
<h1 id="4-原创声明"><a href="#4-原创声明" class="headerlink" title="4. 原创声明"></a>4. 原创声明</h1><p>本实验报告均为原创。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MOS</tag>
      </tags>
  </entry>
  <entry>
    <title>北航操作系统-OS-lab2-实验报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab2-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1. 思考题"></a>1. 思考题</h1><ol>
<li><p>在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，MIPS 汇编程序中 lw 和 sw 指令使用的地址也被视为虚拟地址。CPU访问的都是虚拟地址，通过MMU来转换成对应的物理地址，最后访问内存中的数据。</p>
</li>
<li><p>首先，用宏来处理链表可以化简链表的操作，通过将特定功能的代码封装在宏定义中，可以在实现特定功能时简化操作，增加代码可读性和可维护性。其次，当链表的操作需要修改时，由于该操作会被大量复用，如果逐一修改工作量太大，而用宏则可以只修改宏定义，方便更改。最后，很多种类的链表都包含相似的操作，只要这些链表结构相同，就都可以用这些宏定义来实现相似的操作，只是传入的参数不同，方便了众多链表的使用。</p>
<p>在实验环境中，有单向链表、双向链表、单向队列、双向队列、循环队列。   单向链表插入只需前者指向新者，新者指向后者即可。双向链表插入操作需要新的节点指向前后节点，前后节点再指向新的节点，需要额外判断是否next指向了NULL。循环链表与双向链表运行代码量基本相等，需额外判断是否next指向了头指针。特别的是，插入到头结点对三种链表而言性能相似，单向链表与双向链表插入到尾结点均要遍历完整个链表。 单向链表的删除操作复杂度为O(n)，因为需要靠循环才能找到上一个链表节点的位置，双向链表及循环链表的删除操作与插入性能相近，也还是需要额外判断NULL或HEAD。删除头结点对三种链表而言性能相似，而单向链表与双向链表删除尾结点还是要遍历。</p>
</li>
<li><p>结构如下：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> struct Page &#123;</span><br><span class="line">     Page_LIST_entry_t pp_link;   </span><br><span class="line">     u_short pp_ref;</span><br><span class="line"> &#125;;</span><br><span class="line"> ​</span><br><span class="line">struct Page_list &#123;</span><br><span class="line">	struct Page *lh_first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	struct Page *le_next;</span><br><span class="line">	struct Page **le_prev;</span><br><span class="line">&#125; Page_LIST_entry_t;</span><br></pre></td></tr></table></figure>

<p>答案选C。Page_list中含有的是Page结构体指针头。每一个Page内存控制块都有一个<code>pp_ref</code>用于表示其引用次数（为0时便可remove)，还有一个结构体用于存放实现双向链表的指针。</p>
<ol start="4">
<li><p>ASID的必要性： 同一虚拟地址在不同地址空间中通常映射到不同物理地址，ASID可以判断是在哪个地址空间。例如有多个进程都用到了这个虚拟地址，但若该虚拟地址对应的数据不是共享的，则基本可以表明指向的是不同物理地址，这也是一种对地址空间的保护。</p>
<p>可容纳不同地址空间的最大数量： 64个，参考原文如下： Instead, the OS assigns a 6-bit unique code to each task’s distinct address space. Since the ASID is only 6 bits long, OS software does have to lend a hand if there are ever more than <strong>64 address spaces</strong> in concurrent use; but it probably won’t happen too often.</p>
</li>
<li><p>tlb_invalidate 中 调用了 tlb_out。</p>
<p>tlb_invalidate 的作用是：找到tlb中对需要清除的虚拟地址对应的页表项，并将其全部清零。</p>
</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"> LEAF(tlb_out)</span><br><span class="line"> <span class="keyword">nop</span></span><br><span class="line">     mtc0    a0,CP0_ENTRYHI  <span class="comment">//将传进来的参数放进ENTRYHI中</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     tlbp<span class="comment">// insert tlbp or tlbwi //检测ENTRYHI中的虚拟地址在tlb中是否有对应项，并保存下标</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     mfc0    k0,CP0_INDEX    <span class="comment">//INDEX可以用来判断是否命中</span></span><br><span class="line">     bltz    k0,NOFOUND  <span class="comment">//若未命中，则跳转</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     mtc0    zero,CP0_ENTRYHI    <span class="comment">//将ENTRYHI清零</span></span><br><span class="line">     mtc0    zero,CP0_ENTRYLO0   <span class="comment">//将ENTRYLO清零</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line">     tlbwi<span class="comment">// insert tlbp or tlbwi    //将清零后的两寄存器值写入到对应tlb表项中</span></span><br><span class="line">                                     <span class="comment">//相当于删除原有的tlb表项</span></span><br><span class="line"> NOFOUND:</span><br><span class="line">     </span><br><span class="line">     j   ra  <span class="comment">//return address</span></span><br><span class="line">     <span class="keyword">nop</span></span><br><span class="line"> <span class="meta">END</span>(tlb_out)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p><img src="/pictures/1744383493288.png"></p>
<p>CPU一开始先探测可用的物理内存，数据由QEMU给出，之后根据页面大小计算出物理页框数量。然后根据对应数量alloc出来相同数量的页控制块，之后将已经被kseg0中代码占据的页控制块标记，将剩余的页控制块加入空闲页面队列。由于kseg0段的访存不需要用到tlb和页表，因此MMU仅通过映射的方式即可得到物理地址，然后将CPU初始化的代码存入物理内存中。之后空间页表队列建立好了，用户发出访存请求后，CPU就先访问tlb，如果找到物理地址则直接访问。若没有找到则进行缺页中断，进行tlb重填，其中就会用到我们写的函数和空间队列。</p>
</li>
<li><p>X86用到三个地址空间的概念：物理地址、线性地址和逻辑地址。而MIPS只有物理地址和虚拟地址两个概念。相对而言，段机制对大量应用程序分散地使用大内存的支持能力较弱。所以Intel公司又加入了页机制，每个页的大小是固定的（一般为4KB），也可完成对内存单元的安全保护，隔离，且可有效支持大量应用程序分散地使用大内存的情况。<br>x86体系中，TLB表项更新能够由硬件自己主动发起，也能够有软件主动更新。分段机制和分页机制都启动：逻辑地址—&gt;<strong>段机制处理</strong>—&gt;线性地址—&gt;<strong>页机制处理</strong>—&gt;物理地址。RISC-V提供三种权限模式（MSU），而MIPS只提供内核态和用户态两种权限状态。<br>RISC-V SV39支持39位虚拟内存空间，每一页占用4KB，使用三级页表访存。</p>
</li>
<li><p>页表基地址(page table) 为PTbase。<br>页中间目录基地址(page middle directory) PMDbase：<br>(PTbase &lt;&lt; 12) &gt;&gt; 3 + PTbase<br>页全局目录(page global directory) PGDbase：<br>(PTbase &lt;&lt; 21) &gt;&gt; 3 + PMDbase（三级页表页目录的基地址）<br>页全局目录项（page global directory entry）PGDE：<br>(PTbase &lt;&lt; 30) &gt;&gt; 3 + PGDbase（映射到页目录自身的页目录项）</p>
</li>
</ol>
<h1 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2. 难点分析"></a>2. 难点分析</h1><ol>
<li><p>理解CPU访问的都是虚拟地址，而虚拟地址到底是哪个实际的物理地址，这个是由MMU来决定的。在MIPS框架中，有四块内存区域，分别是kseg0，kseg1，kseg2，kuseg。其中前两个通过高位置零的操作就可以映射到物理地址中，不需要借助tlb，因此想要访问某一个具体的物理地址，可以直接通过kseg0段的虚拟地址来访问。</p>
</li>
<li><p>kseg0段一开始存储了操作系统内核的代码，以及页控制块等，这些代码已经存储到了对应的物理内存中，剩余可用的物理内存组成空闲页控制块，用来分配给kuseg。</p>
</li>
<li><p>链表的宏定义。链表的结构是，有一个指针结构体和一个被引用次数。其中指针结构体有指向下一个链表节点的指针，和指向前一个链表中指向下一个节点指针的指针。通过这样的设计，可以很轻易地修改链表，方便插入和删除操作。</p>
</li>
<li><p>页表分析。页表定义了很多的函数。page_walk函数的作用是，在二级页表结构中查找返回虚拟地址的页表项指针。如果二级页表缺页，会尝试创建一个。page_lookup函数既可以返回在二级页表结构中查找返回虚拟地址的页表项指针，同时也可以返回物理地址所对应的页控制块。page_insert函数可以建立虚拟地址和页控制块的联系。page_remove可以清除虚拟地址和页控制块的关联。page_decref可以减少页控制块被引用次数，如果减少到0则调用page_free将该页框加入空闲页表队列。</p>
</li>
<li><p>宏定义分析。<img src="/pictures/228e2c1dfec2c8a87a3bcbbc1bad41a.png"></p>
</li>
<li><p>tlb_invalidate的作用是删除虚拟地址和物理地址在tlb中的对应关系，其中调用了tlb_out。如果CPU访问失败，则会触发缺页中断，调用do_tlb_refill函数，该函数会先为虚拟地址分配一个物理页框，然后填写到tlb中。</p>
</li>
</ol>
<h1 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3. 实验体会"></a>3. 实验体会</h1><p>链表的宏定义需要熟练掌握应用，今后还有很多能用到的机会。同时自己实现的宏定义也要好好检查，否则课下的问题有可能会引发课上的错误。<br>虚拟地址和物理地址和页控制块的转换宏定义也需要熟练掌握，熟练掌握这些宏定义可以让我们快速完成想要的操作，更加方便简洁。<br>要好好理解多级页表的访存机制，十分清楚，这样才能在底层去操作。</p>
<h1 id="4-原创声明"><a href="#4-原创声明" class="headerlink" title="4. 原创声明"></a>4. 原创声明</h1><p>本实验报告大部分原创，少部分参考了<a href="https://www.cnblogs.com/emodiary121/p/16142108.html">北航操作系统课程lab2实验报告 - 南风北辰 - 博客园 (cnblogs.com)</a>该博客。全部内容都带有自己的思考。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MOS</tag>
      </tags>
  </entry>
  <entry>
    <title>北航操作系统-OS-lab4-实验报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab4-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1. 思考题"></a>1. 思考题</h1><ol>
<li><p><img src="/pictures/0689e815580e6da0fbfaf2186591973.png"></p>
<p>内核在保存现场的时候，通过 SAVE_ALL 宏操作，来将通用寄存器中的值保存在内核栈指针所指向的位置，在异常处理结束时恢复现场，从而防止通用寄存器的值被破坏改变。</p>
<p>可以从当时的 $a0 - $a3 寄存器中得到用户调用 msyscall 时传入的参数。因为在系统调用的时候，这几个寄存器的值不会被改变，因此可以直接获取。</p>
<p>方式就是让sys开头的函数通过正常获取参数的方式，能够获取正确的参数。而这样做的保证是，在用户调用syscall相关函数后，会进行传参，此时会在$a0 - $a3寄存器中保存值，并在用户栈中开辟栈帧，存入相关参数。之后调用msyscall函数，这个函数是个页函数，因此没有栈帧，不会改变栈指针的位置，这个函数直接调用了syscall，陷入了内核态，因此此时 $a0 - $a3 中的值和用户栈中的栈帧跟syscall传参后没有区别，可以通过正常获取参数的方式来获取正确的参数。</p>
<p>将Trapframe中的epc加了4，也就是使其指向了下一条指令。这样做的变化是，当内核态执行完操作后，会调用eret指令，让PC指向epc，此时用户态的函数，也就是msyscall，就会从jr ra 开始运行，从而返回。否则将会再执行syscall而陷入死循环。</p>
</li>
<li><p><img src="/pictures/ad0607b8a2539e926a7a4fc0cf397cb.png"><br>因为需要保证e所指向的env的id就是envid。如果没有这步判断，那么说明 e &#x3D; &amp;envs[ENVX(envid)] 所找到的env的id不是envid，也就是这一步的实现有错。</p>
</li>
<li><p><img src="/pictures/d75dfb04ee9959501444d7d984e88c1.png"></p>
<p><img src="/pictures/aabe33e08570b9ed28c6abc03b2dda2.png"></p>
<p>以上是该函数的具体实现，可以看到该函数中有一个静态全局变量 i，该变量初始值是 0，之后每次 make 新 id 的时候，该值就会++，并存储在 id 的高位。由于 i 初始值就是0，因此第一次调用之后一直都是大于 0 的。因此 id 不会是 0，mkenvid 不会返回 0。</p>
</li>
<li><p><img src="/pictures/629780541c043dcf36ff52288f846c8.png"><br>正确答案应该是C</p>
</li>
<li><p><img src="/pictures/5f1de30c3d51011e5377c24a0766b47.png"><br>仅需映射 0 - USTACKTOP 的部分即可。对于 USTACKTOP 以上的部分，分别是异常处理栈、全局 pages 和 envs 、vpt，这些部分不需要映射。</p>
</li>
<li><p><img src="/pictures/129a0077eb06859626b4e857d3f56eb.png"><br>vpd 是页目录的首地址，vpt是所有页表的首地址。使用方式就是通过下表索引机制。比如想要访问页目录中的第一个页目录项，那么这一项的值就是 vpd[1]。</p>
<p>在 entry.S 中，这两个变量被设置为了 .globl ，也就是说对于用户进程，这两个变量就是全局变量，可以直接访问。</p>
<p>vpt &#x3D; UVPT;<br>vpd &#x3D; UVPT | (UVPT &gt;&gt; 10);<br>这里体现出了页目录自映射机制。</p>
<p>不能，因为用户没有权限去修改自己的页目录项或者页表项，其权限位PTE_R是0。</p>
</li>
<li><p><img src="/pictures/612d62540326ac5597e90aae90a7dc9.png"><br>当用户态的程序尝试对没有写入权限的页进行写入时，将会触发异常，并经过异常分发来到handle_tlb_mod，其调用了do_tlb_mod函数。也就是说在这种情况下会进行异常重入。</p>
<p>因为我们的MOS操作系统采用微内核设计，将大部分的操作移至用户态进行，因此需要把异常现场复制到用户空间来让用户态的函数去访问。</p>
</li>
<li><p><img src="/pictures/c86cfde30149800b0f9a1732804e3ef.png"><br>如果发生崩溃，整个操作系统不会跟着崩溃，可以防止潜在的崩溃隐患。</p>
</li>
<li><p><img src="/pictures/8d15e73e4cefae65958de970377f6bc.png"><br>因为在父进程创建子进程的时候，有可能发生缺页中断，此时也需要进行异常处理。因此父进程需要知道异常处理的函数的入口地址，这样才能在发生异常的时候跳转到cow_entry函数去处理。</p>
<p>如果防止在其之后，那么fork出来的子进程读取到的就是修改后的页面，而不是原来的页面。</p>
</li>
</ol>
<h1 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2. 难点分析"></a>2. 难点分析</h1><ol>
<li><p>本次作业中先让我们填写了很多内核态的系统调用函数，并理解了系统调用的过程，之后让我们了解了IPC机制，进程间是如何互相通信的。最后让我们实现了fork函数。整个过程内容较多，需要我们好好理解其中的细节。</p>
</li>
<li><p>首先，如果系统触发了异常，那么CPU会自动跳转到异常处理入口地址。之后会先调用SAVE_ALL宏操作来保存当前上下文，之后经过exception_handler异常分发到对应的异常处理函数。如果是系统调用异常，那么会跳转到handle_sys，这里会继续调用do_syscall，在这里会先进行epc+4，让返回的PC指向下一条指令，防止重复syscall，之后通过异常调用码来找到对应的异常调用函数，并传入相关参数。最后在执行完内核操作后，调用ret_from_exception，返回用户态。</p>
</li>
<li><p>进程间通信机制，即ipc，依赖于进程控制块内的信息存储和共享页面机制。接收进程可以调用recv函数，设置自己状态并让出CPU。发送进程可以调用sending去给接收进程发送信息。有两种信息传输途径，发送进程可以把信息保存到接收进程的env中，同时可以通过共享页面操作让两个进程访问相同的内存。</p>
</li>
<li><p>fork机制可以让一个进程创造出一个子进程。二者共享代码段、数据段，同时还保留了解释复制机制。</p>
</li>
</ol>
<h1 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3. 实验体会"></a>3. 实验体会</h1><ol>
<li><p>本次实验需要认真体会，好好复习。首先要理解异常处理流程，明确系统调用和陷入机制。我们在实验中填写了众多系统调用函数，从而让用户态的进程可以调用这些系统调用函数，完成相关的操作。</p>
</li>
<li><p>fork操作需要先设置父进程的写时复制处理函数入口地址，这样父进程在接下来的fork操作时如果发生了写入异常，那么可以跳转到cow_entry函数完成写时复制操作。之后调用syscall_exoenv来创建子进程的进程控制块。之后需要将父进程的页面映射到子进程中，并把PTE_D有效同时PTE_COW有效的页面设置成PTE_D为0，这样进程在写这样的页面时会触发异常，从而分配出新的一页，不妨碍另外一个进程读页面。最后再设置状态并加入调度队列即可。</p>
</li>
</ol>
<h1 id="4-原创声明"><a href="#4-原创声明" class="headerlink" title="4. 原创声明"></a>4. 原创声明</h1><p>本实验报告均为原创。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MOS</tag>
      </tags>
  </entry>
  <entry>
    <title>北航操作系统-OS-lab6-实验报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-lab6-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1. 思考题"></a>1. 思考题</h1><p><img src="/pictures/533a9dfd040b7b72ff21d161dff8cdd.png"><br>想让父进程作为读者，只需要反过来操作就可以了。先关闭写，再进行读操作，最后关闭读并退出即可。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	close(fildes[<span class="number">1</span>]);</span><br><span class="line">	read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;father-process read:%s&quot;</span>, buf);</span><br><span class="line">	close(fildes[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure>
<p><img src="/pictures/6bcf73074f4d8a4717dfa28a8365589.png"><br>dup 函数的具体内容如下图所示：</p>
<p><img src="/pictures/ba6e6f1d2e8e789bb66d276a946c033.png"></p>
<p>可以看到该函数的主要功能是复制文件描述符，即让访问newfdnum的fd或data时，实际访问到的页框是oldfdnum的页框，也就是实现共享页面。</p>
<p>在共享页面之后，oldfdnum所对应的fd的页框的pp_ref会+1，同理pipe的引用也会+1。如果在fd的引用+1之后，pipe的引用还没来得及+1，此时发生了时钟中断并切换了进程，那么此时该fd的引用和pipe的引用数相同，会导致进程在检验另一端是否关闭时返回真，进而导致其误以为读端&#x2F;写端已经关闭，从而提前结束。</p>
<p><img src="/pictures/b95ff0c9cf79f29ad172f5a5743a6fe.png"><br>在执行系统调用后，操作系统会陷入内核态，此时会关闭CPU的时钟中断权限，相关代码如下：</p>
<p><img src="/pictures/3ddcd6729d635f63a1aa6195663e30f.png"><br>可以看到 STATUS_IE 被置零了，说明此时中断被禁止，因此在内核态执行系统调用时不会被时钟中断，是原子操作。</p>
<p><img src="/pictures/a23c27634ce617c6a2aebc629844367.png"><br>可以解决，若在<code>pageref(pipe) &gt; pageref(fd)</code>的情况下便没有问题，而如果<code>pageref(pipe) == pageref(fd)</code>的话，那么当读缓冲区为空，写缓冲区为满时会<strong>再次循环</strong>直到进程切换两者全部unmap为止。</p>
<p><code>dup</code>也会出现同样的问题，先对<code>pipe</code>进行map，再对<code>fd</code>进行map即可。目的就是时刻保持<code>pageref(pipe) &gt; pageref(fd)</code>。</p>
<p><img src="/pictures/23353cae7e59cb1bdba1ecd5a71cd64.png"><br>文件打开的过程：</p>
<ol>
<li>用户进程调用open函数，其中传入要打开文件的路径和打开方式。</li>
<li>调用fsipc_open函数。</li>
<li>调用fsipc与文件系统服务进程通信。</li>
<li>通过识别req的种类来调用serve_open函数。</li>
<li>serve_open先找到要打开的文件的文件控制块，然后申请一个struct Open，并填写相关信息。</li>
<li>用户进程申请一个struct Filefd，并通过共享页面来访问文件系统服务进程的struct Filefd。</li>
<li>通过其中的文件控制块来在data区域映射文件的磁盘块，调用map函数来与文件系统服务进程共享页面。</li>
</ol>
<p>如何读取加载ELF文件：先验证elf文件的文件头，看看该文件是否是符合要求的elf文件。之后通过文件头的偏移找到程序头表。遍历每一个程序头表，对每一个程序头表，将其数据按照其规定的虚拟地址进行页面映射。进而完成elf文件的加载。</p>
<p>elf_load_seg()函数的主要功能是将一个程序头表的数据按照程序头表所规定的虚拟地址映射到进程的页表中。其中将一段程序分成了三部分，第一部分是开头未页对齐的部分，第二部分是中段有内容的data段，第三部分是最后的bss段。该函数通过调用load_icode_mapper来每次实现一页的加载。对于bss段，对于申请后的页面，用0来填充，这样就起到了bss段初始值为0的效果。</p>
<p><img src="/pictures/298b2e9ccb507f999780946dd4d9af0.png"><br>在 user&#x2F;init.c 中如下代码片段实现了该功能：</p>
<p><img src="/pictures/aa6a2dec845acdca255e0e003116d5a.png"><br><img src="/pictures/d4c8c61c5cb1fffe1c72042114ba9c4.png"><br>我们用到的shell命令是外部命令，因为我们的user文件夹中有<code>cat.c</code> <code>ls.c</code>文件，Linux下的cd指令没有对应的文件，使用时也不需要单独的创建一个子进程。cd 所做的是改变 shell 的 <strong>PWD</strong>。 因此倘若 cd 是一个外部命令，那么它改变的将会是子 shell 的 PWD，也不会向父 shell 返回任何东西。所以，当前 shell 的 PWD 就不会做任何改变。<strong>所有能对当前 shell的环境作出改变的命令都必须是内部命令。</strong> 因此如果我们将 cd 做成外部命令，就无法像原来一样改变当前目录了。</p>
<p><img src="/pictures/936c3dd4a34a35d2fc0d2f948ec28a2.png"><br><img src="/pictures/f669e8655a7a8ebd9a9368cc5cd8945.png"><br>两次spawn，四次destroying。</p>
<h1 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2. 难点分析"></a>2. 难点分析</h1><h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h4><p>管道分为有名管道和无名管道，是半双工的单向管道。其中我们实现的管道只能在父子进程间通信。<br>pipe函数对两个文件描述符的操作十分重要，两个文件描述符本身是不同的，但他们却指向的是同一个管道，先<code>syscall_mem_alloc</code>，再<code>syscall_mem_map</code>，通过<code>fd_omode</code>限定该文件描述符的读写。<br>要注意在检测另外一个端是否结束的时候，必须考虑所有中断情况，保证在每一种可能的中断情况下该检查函数都能正确返回。否则可能会出现提前结束的情况。<br>在<code>_pipeisclosed</code>函数里，我们发现了<code>env_runs</code>这个从lab 3就一直跟随着我们的属性的价值，这或许也可以作为其他函数用于判断是否是类原子操作的一个方法。</p>
<h4 id="2-shell"><a href="#2-shell" class="headerlink" title="2. shell"></a>2. shell</h4><p>shell主要作用是解析输入的字符串，根据输入指令来完成对应的操作，最后输出相应的结果。<br>其中需要从磁盘中读取文件并运行，用到了spawn这个函数。这个函数通过传入地址，参数，来创建一个进程运行地址所指向的elf文件。<br>load_icode_mapper函数已经写过了，这次需要在<strong>用户态</strong>下实现这个函数，用户态实现二进制文件的加载不像内核态的调用那样简单，但大体的思路差不多，也会用到<code>user_bcopy</code>、<code>user_bzero</code>。<code>spawn</code>函数的填写更是需要看一下ELF文件格式才好理解。而解析shell命令的<code>runcmd</code>函数相对就简单一点。<br>判断当前的字符是否是特殊符号可以有一个更快捷的方法，这样可以避免书写过长的switch。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">define</span> SYMBOLS <span class="string">&quot;&lt;|&gt;&amp;;()&quot;</span></span></span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">strchr</span>(SYMBOLS, *s)) &#123;</span><br><span class="line">         <span class="comment">/* do something */</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3. 实验体会"></a>3. 实验体会</h1><p>个人感觉，lab6难度比lab5小一点，但是需要仔细认真的阅读和理解。需要仔细阅读的代码量也比较小，但需要在理解lab5的基础上才能快速上手。</p>
<p>OS的实验课就到此结束了，学了很多理论知识，也看了很多代码，具体的函数实现也没有想着能够一直记下来，大概能有个印象我觉得就行了。在我看来，这门课学到的其实也不止这些代码（因为感觉以后大概率也用不上），主要是学会了很多有用的工具，把c语言的应用也提升了一个档次，这就足够啦。</p>
<h1 id="4-原创声明"><a href="#4-原创声明" class="headerlink" title="4. 原创声明"></a>4. 原创声明</h1><p>本实验报告部分参考了<a href="https://www.cnblogs.com/emodiary121/p/16364653.html">北航操作系统lab6实验报告 - 南风北辰 - 博客园 (cnblogs.com)</a>其余部分均为原创。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MOS</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成原理-CO-CPU-P3-设计报告</title>
    <url>/2025/06/30/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CO-CPU-P3-%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-分析指令集"><a href="#1-分析指令集" class="headerlink" title="1. 分析指令集"></a>1. 分析指令集</h1><ul>
<li>经过分类，指令共包含R型指令和I型指令</li>
<li>列出其对应的32位机器码，寻找共性差异</li>
</ul>
<h2 id="R型指令："><a href="#R型指令：" class="headerlink" title="R型指令："></a>R型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Rd</th>
<th align="center">Shamt</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100000</td>
<td>相加(rs+rt-&gt;rd)</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100010</td>
<td>相减(rs-rt-&gt;rd)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="I型指令："><a href="#I型指令：" class="headerlink" title="I型指令："></a>I型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Immediate</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ori</td>
<td align="center">001101</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>或运算(rs|immediate-&gt;rt)</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">001111</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>立即数加载至高16位({immediate||{16{1’b0}}}-&gt;rt)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Offset</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lw</td>
<td align="center">100011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>加载字(rs+offset在memory中data-&gt;rt)</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">101011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>保存字(rt-&gt;rs+offset在memory中的data)</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">000100</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs与rt相等则PC偏移offset*4</td>
</tr>
</tbody></table>
<ul>
<li>可以分析得到，通过Op能够区分R型指令和I型指令</li>
<li>R型指令中通过Func再具体区别运算类型</li>
</ul>
<h1 id="2-分析Controller"><a href="#2-分析Controller" class="headerlink" title="2. 分析Controller"></a>2. 分析Controller</h1><table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">作用（0）</th>
<th>作用（1）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">RegDst</td>
<td align="center">GRF写入端地址选择Rt</td>
<td>GRF写入端地址选择Rd</td>
<td></td>
</tr>
<tr>
<td align="center">ALUSrc</td>
<td align="center">ALU输入端B选择R[rt]</td>
<td>ALU输入端B选择Signext</td>
<td></td>
</tr>
<tr>
<td align="center">MemtoReg</td>
<td align="center">GRF写入端数据来自ALU输出</td>
<td>GRF写入端数据来自DM输出</td>
<td></td>
</tr>
<tr>
<td align="center">RegWrite</td>
<td align="center">无</td>
<td>把数据写入GRF中对应寄存器</td>
<td></td>
</tr>
<tr>
<td align="center">MemWrite</td>
<td align="center">无</td>
<td>数据存储器DM写输入</td>
<td></td>
</tr>
<tr>
<td align="center">nPC_Sel</td>
<td align="center">PC&#x3D;PC+4</td>
<td>PC&#x3D;PC+4+移位</td>
<td></td>
</tr>
<tr>
<td align="center">ExtOp</td>
<td align="center"></td>
<td></td>
<td>选择扩展类型</td>
</tr>
<tr>
<td align="center">ALU_Op</td>
<td align="center"></td>
<td></td>
<td>选择计算类型</td>
</tr>
</tbody></table>
<h1 id="3-设计PC状态转移模块"><a href="#3-设计PC状态转移模块" class="headerlink" title="3.设计PC状态转移模块"></a>3.设计PC状态转移模块</h1><ul>
<li>经过分析，PC只会转移到两个状态：1. PC+4  2. PC+4+移位</li>
<li>1.状态是除beq以外其他指令的转移</li>
<li>2.状态时beq成立时的转移</li>
<li>PC是保存的状态</li>
<li>Moore状态机，输出是PC所对应的ROM中的地址</li>
<li>reset异步复位</li>
</ul>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">PCop</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">PC</td>
<td align="center">[15:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">beq</td>
<td align="center">[15:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">instruction</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<h3 id="因此可设计如下PC状态机："><a href="#因此可设计如下PC状态机：" class="headerlink" title="因此可设计如下PC状态机："></a>因此可设计如下PC状态机：</h3><p><img src="/pictures/07f14f64a1db155afead97371e8172d.png" alt="alt text"></p>
<h3 id="其中PCshift模块为："><a href="#其中PCshift模块为：" class="headerlink" title="其中PCshift模块为："></a>其中PCshift模块为：</h3><p><img src="/pictures/80885f2a7fdbb17a126ed74a5f4af7b.png" alt="alt text"></p>
<p><strong>需要注意，因为PC实际是从0x00003000开始的，而ROM是从0x00000000开始的，因此二者有差值。在获取PC值的时候，需要加上初始地址0x00003000</strong></p>
<h1 id="4-设计splitter"><a href="#4-设计splitter" class="headerlink" title="4. 设计splitter"></a>4. 设计splitter</h1><ul>
<li>根据不同指令从对应位数拆分出相关信息，用于后续操作。</li>
</ul>
<p><img src="/pictures/21d42a09c8443fced31562d565c985e.png" alt="alt text"></p>
<h1 id="5-设计ALU"><a href="#5-设计ALU" class="headerlink" title="5. 设计ALU"></a>5. 设计ALU</h1><h3 id="ALU端口设计："><a href="#ALU端口设计：" class="headerlink" title="ALU端口设计："></a>ALU端口设计：</h3><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">num1</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">num2</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">ALUop</td>
<td align="center">[3:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ans</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<h3 id="ALUop解释："><a href="#ALUop解释：" class="headerlink" title="ALUop解释："></a>ALUop解释：</h3><table>
<thead>
<tr>
<th align="center">ALUop</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">加法</td>
</tr>
<tr>
<td align="center">0001</td>
<td align="center">减法</td>
</tr>
<tr>
<td align="center">0010</td>
<td align="center">或运算</td>
</tr>
<tr>
<td align="center">0011</td>
<td align="center">相等</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">0101</td>
<td align="center">大于</td>
</tr>
</tbody></table>
<h3 id="ALU实现电路："><a href="#ALU实现电路：" class="headerlink" title="ALU实现电路："></a>ALU实现电路：</h3><p><img src="/pictures/4b2f67627254f828510a00340b4e4d5.png" alt="alt text"></p>
<h1 id="6-CU"><a href="#6-CU" class="headerlink" title="6. CU"></a>6. CU</h1><h3 id="端口设计："><a href="#端口设计：" class="headerlink" title="端口设计："></a>端口设计：</h3><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">op</td>
<td align="center">[5:0]</td>
<td>机器码高6位</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">func</td>
<td align="center">[5:0]</td>
<td>机器码低6位</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">RegDst</td>
<td align="center">1</td>
<td>GRF被写入寄存器是rt还是rd。0是rt，1是rd</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ALUSrc</td>
<td align="center">1</td>
<td>ALU第二个运算值是rt还是立即数。0是rt，1是立即数</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">mentoReg</td>
<td align="center">1</td>
<td>GRF写入值是ALUans还是DMans。0是ALUans，1是DMans</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Regwrite</td>
<td align="center">1</td>
<td>是否写入GRF</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Menwrite</td>
<td align="center">1</td>
<td>是否写入RAM</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">PCsel</td>
<td align="center">1</td>
<td>当前指令是否是beq</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Extop</td>
<td align="center">[1:0]</td>
<td>扩展操作类型类型，详见Extender</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ALUop</td>
<td align="center">[3:0]</td>
<td>ALU运算类型，详见ALU</td>
</tr>
</tbody></table>
<ul>
<li>内部电路采用最小项表达式判断法，先判断Op，再判断Func<br><img src="/pictures/7a58a7231680b093b7121e6b404d678.png" alt="alt text"></li>
<li>之后根据每种指令对应的输出来用或逻辑接线。<br><img src="/pictures/761ba2735cbea0b555e852b9d42e2d5.png" alt="alt text"></li>
<li>对于ALUop的判断，再次采用最小项表达式的方法。<br><img src="/pictures/f7eaf24d608e99cfd72d185c239d672.png" alt="alt text"></li>
</ul>
<h1 id="7-Extender"><a href="#7-Extender" class="headerlink" title="7. Extender"></a>7. Extender</h1><p>端口类型：</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">num</td>
<td align="center">[15:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">Extop</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ans</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<p>Extop类型解释：</p>
<table>
<thead>
<tr>
<th align="center">Extop</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00</td>
<td align="center">zero扩展</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">sign扩展</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">低16位移至高16位，补0</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">sign扩展，左移2位，补0</td>
</tr>
<tr>
<td align="center">实现过程：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><img src="/pictures/ab168230aa6fd5765c7c7bba5351e4c.png" alt="alt text"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="8-控制信号操作电路"><a href="#8-控制信号操作电路" class="headerlink" title="8. 控制信号操作电路"></a>8. 控制信号操作电路</h1><ul>
<li>凭借splitter提供的寄存器信息、立即数信息，和CU提供的控制信号，我们可以组合连接GRF与RAM，以达到完成指令操作的效果。<br><img src="/pictures/3a54bacbecdae20a779b22d3238b7d4.png" alt="alt text"></li>
<li>通过CU的控制信号来决定MUX的输出是什么，从而特性化处理不同指令的要求。</li>
</ul>
<h1 id="9-输出"><a href="#9-输出" class="headerlink" title="9. 输出"></a>9. 输出</h1><p><img src="/pictures/9cc7cc795eeeb138592cb68279baaed.png" alt="alt text"><br>通过tunnel获取相应输出的结果，并从端口输出。(PC要加上初始地址)</p>
<h1 id="10-测试方案"><a href="#10-测试方案" class="headerlink" title="10. 测试方案"></a>10. 测试方案</h1><ol>
<li>理论检验。一个个指令单独检测，从CU产生的控制信号，到这些控制信号实际所控制的内容，分别进行检查核对，确保指令正确执行。</li>
<li>数据检验。利用教程平台提供的机器码，导入ROM中运行CPU，通过翻译机器码获取MIPS指令，并利用MARS计算出正确结果，与CPU中的GRF和RAM核对信息。</li>
</ol>
<h1 id="11-思考题"><a href="#11-思考题" class="headerlink" title="11. 思考题"></a>11. 思考题</h1><ol>
<li>CPU中有两个FSM。一个是由PC和PCop组成的FSM，是一个Moore状态机，输出是当前PC所对应的指令机器码；另一个是GRF和RAM与Splitter和CU组成的FSM，是一个Mealy状态机，输出是众多信号。PC、GRF、RAM起到状态存储功能，PCshifter、ALU、Extender实现状态转移功能(即计算出下一状态)。</li>
<li>我认为比较合理。ROM是只读寄存器，不可修改，其存储的是指令的机器码，而程序指令一经写好就是固定的，因此可以应用。GRF是寄存器堆，用来对应32个寄存器，能起到数据存储的作用，我认为也比较合理。RAM是随机访存寄存器，且读出和写入操作分离，满足内存中访问和存储的操作，因此也合理。但也有一些问题，比如 $sp寄存器是栈指针，其初始值并不是0，而是一个地址。进行入栈操作时会先 $sp自减4字节，之后再在内存中 $sp的位置存储数据。而寄存器默认初始值是0，因此需要注意特殊寄存器赋初值的问题。</li>
<li>除了教程中提及的模块，我还设计了PCshifter模块，其作用是根据PC和PCop来计算出下一周期的PC。利用PCop当MUX的sel信号，根据PCop的不同，决定不同的PC输出<img src="/pictures/df0b89c25261476827243e17d41a76f.png" alt="alt text"></li>
<li>nop的作用是让当前电路不发生任何改变。当CU中不设计nop指令时，出现nop指令后CU所有控制信号都是0，包括Regwrite和Menwrite，此时不会对GRF和RAM进行任何改变，满足nop指令的作用，因此不需要设计。</li>
<li>该测试样例的覆盖率和强度都较高，但是对于特定样例、边界情况的测试还有些不足。<br>ori指令：应该增加立即数的符号位是1的测试样例，以判断是否是无符号扩展。<br>lui指令：测试较为全面<br>add指令：应增加溢出情况测试<br>sw指令：应增加对某一地址重复赋值的测试，应变换寄存器中的值测试偏移量<br>lw指令：应变换寄存器中的值测试偏移量<br>beq指令：应增加label是beq指令的下一条指令的跳转，测试跳转情况下PC是否+4再偏移。</li>
</ol>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成原理-CO-CPU-P4-设计报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CO-CPU-P4-%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-分析指令集"><a href="#1-分析指令集" class="headerlink" title="1. 分析指令集"></a>1. 分析指令集</h1><ul>
<li>经过分类，指令共包含R型指令和I型指令</li>
<li>列出其对应的32位机器码，寻找共性差异</li>
</ul>
<h2 id="R型指令："><a href="#R型指令：" class="headerlink" title="R型指令："></a>R型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Rd</th>
<th align="center">Shamt</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100000</td>
<td>相加(rs+rt-&gt;rd)</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100010</td>
<td>相减(rs-rt-&gt;rd)</td>
</tr>
</tbody></table>
<h2 id="I型指令："><a href="#I型指令：" class="headerlink" title="I型指令："></a>I型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Immediate</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ori</td>
<td align="center">001101</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>或运算(rs|immediate-&gt;rt)</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">001111</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>立即数加载至高16位({immediate||{16{1’b0}}}-&gt;rt)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Offset</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lw</td>
<td align="center">100011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>加载字(rs+offset在memory中data-&gt;rt)</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">101011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>保存字(rt-&gt;rs+offset在memory中的data)</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">000100</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs与rt相等则PC偏移offset*4</td>
</tr>
</tbody></table>
<h2 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h2><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Op</th>
<th align="center">instr_index</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jal</td>
<td align="center">000011</td>
<td align="center">(26)</td>
<td>跳转至index并且PC+4 -&gt; $ra</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Op</th>
<th align="center">rs</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jr</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">{10{1’b0}}</td>
<td align="center">{5{1’b0}}</td>
<td align="center">001000</td>
<td>跳转至$rs中的地址</td>
</tr>
</tbody></table>
<h1 id="2-PC设计"><a href="#2-PC设计" class="headerlink" title="2. PC设计"></a>2. PC设计</h1><p> 端口设计：</p>
<table>
<thead>
<tr>
<th align="center">方向</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">PCop</td>
<td align="center">[3:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">beq</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">jal</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">jr</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">reset</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">clk</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">PC</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<p>转移设计：</p>
<table>
<thead>
<tr>
<th align="center">PCop</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">PC &lt;&#x3D; PC + 4</td>
</tr>
<tr>
<td align="center">0001</td>
<td align="center">PC &lt;&#x3D; PC + 4 + beq</td>
</tr>
<tr>
<td align="center">0010</td>
<td align="center">PC &lt;&#x3D; jal</td>
</tr>
<tr>
<td align="center">0011</td>
<td align="center">PC &lt;&#x3D; jr</td>
</tr>
</tbody></table>
<h1 id="3-IM设计"><a href="#3-IM设计" class="headerlink" title="3. IM设计"></a>3. IM设计</h1><p>端口设计：</p>
<table>
<thead>
<tr>
<th align="center">方向</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">PC</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">instruction</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<p>转移设计：</p>
<table>
<thead>
<tr>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">instruction &lt;&#x3D; instruction_memory[PC]</td>
</tr>
</tbody></table>
<h1 id="4-设计splitter"><a href="#4-设计splitter" class="headerlink" title="4. 设计splitter"></a>4. 设计splitter</h1><p>端口设计：</p>
<table>
<thead>
<tr>
<th align="center">方向</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">instruction</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Op</td>
<td align="center">[5:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Func</td>
<td align="center">[5:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">rs</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">rt</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">rd</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">immediate</td>
<td align="center">[15:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">jal</td>
<td align="center">[25:0]</td>
</tr>
</tbody></table>
<p><img src="/pictures/4c661ff3913a8130203a1af4148f1d0.png" alt="alt text"></p>
<h1 id="5-设计ALU"><a href="#5-设计ALU" class="headerlink" title="5. 设计ALU"></a>5. 设计ALU</h1><h3 id="ALU端口设计："><a href="#ALU端口设计：" class="headerlink" title="ALU端口设计："></a>ALU端口设计：</h3><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">num1</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">num2</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">ALUop</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ans</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<h3 id="ALUop解释："><a href="#ALUop解释：" class="headerlink" title="ALUop解释："></a>ALUop解释：</h3><table>
<thead>
<tr>
<th align="center">ALUop</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10001</td>
<td align="center">加法</td>
</tr>
<tr>
<td align="center">10010</td>
<td align="center">减法</td>
</tr>
<tr>
<td align="center">10011</td>
<td align="center">与运算</td>
</tr>
<tr>
<td align="center">10100</td>
<td align="center">或运算</td>
</tr>
<tr>
<td align="center">10101</td>
<td align="center">异或运算</td>
</tr>
<tr>
<td align="center">10110</td>
<td align="center">相等</td>
</tr>
<tr>
<td align="center">10111</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">11000</td>
<td align="center">小于</td>
</tr>
</tbody></table>
<h1 id="6-CU"><a href="#6-CU" class="headerlink" title="6. CU"></a>6. CU</h1><h3 id="端口设计："><a href="#端口设计：" class="headerlink" title="端口设计："></a>端口设计：</h3><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">Op</td>
<td align="center">[5:0]</td>
<td>机器码高6位</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">Func</td>
<td align="center">[5:0]</td>
<td>机器码低6位</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">RegDst</td>
<td align="center">[1:0]</td>
<td>GRF被写入寄存器是rt还是rd。0是rt，1是rd，10是$ra</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ALUSrc</td>
<td align="center">[1:0]</td>
<td>ALU第二个运算值是rt还是立即数。0是rt，1是立即数</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">memtoReg</td>
<td align="center">[1:0]</td>
<td>GRF写入值是ALUans还是DMans。0是ALUans，1是DMans，10是PC + 4</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Regwrite</td>
<td align="center">1</td>
<td>是否写入GRF</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Memwrite</td>
<td align="center">1</td>
<td>是否写入RAM</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">PCsel</td>
<td align="center">[3:0]</td>
<td>当前指令是否是beq\jal\jr</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Extop</td>
<td align="center">[7:0]</td>
<td>扩展操作类型类型，详见Extender</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ALUop</td>
<td align="center">[7:0]</td>
<td>ALU运算类型，详见ALU</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">instr_type</td>
<td align="center">[7:0]</td>
<td>指令类型</td>
</tr>
</tbody></table>
<ul>
<li>内部电路采用最小项表达式判断法，先判断Op，再判断Func</li>
</ul>
<p>每种指令所需控制信号：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RegDst</th>
<th align="center">ALUSrc</th>
<th align="center">memtoReg</th>
<th align="center">Regwrite</th>
<th align="center">Memwrite</th>
<th align="center">PCsel</th>
<th align="center">Extop</th>
<th align="center">ALUop</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center"></td>
<td align="center">ADD</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center"></td>
<td align="center">SUB</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0000</td>
<td align="center">OR</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0010</td>
<td align="center">ADD</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">01</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">ADD</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center"></td>
<td align="center">01</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">ADD</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center"></td>
<td align="center">00</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0001</td>
<td align="center">0011</td>
<td align="center">EQUAL</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">10</td>
<td align="center"></td>
<td align="center">10</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0010</td>
<td align="center">0100</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center"></td>
<td align="center">00</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0011</td>
<td align="center"></td>
<td align="center">ADD</td>
</tr>
</tbody></table>
<h1 id="7-Extender"><a href="#7-Extender" class="headerlink" title="7. Extender"></a>7. Extender</h1><p>端口类型：</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">num</td>
<td align="center">[15:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">jal</td>
<td align="center">[25:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">Extop</td>
<td align="center">[3:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">PC</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ans</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<p>Extop类型解释：</p>
<table>
<thead>
<tr>
<th align="center">Extop</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">zero扩展</td>
</tr>
<tr>
<td align="center">0001</td>
<td align="center">sign扩展</td>
</tr>
<tr>
<td align="center">0010</td>
<td align="center">低16位移至高16位，补0</td>
</tr>
<tr>
<td align="center">0011</td>
<td align="center">sign扩展，左移2位，补0</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">PC高4位，jal补2位0</td>
</tr>
</tbody></table>
<h1 id="8-GRF"><a href="#8-GRF" class="headerlink" title="8.GRF"></a>8.GRF</h1><p><img src="/pictures/eed57cbfc45250ecf501fd01aa60a0e.png" alt="alt text"></p>
<h1 id="9-DM"><a href="#9-DM" class="headerlink" title="9. DM"></a>9. DM</h1><p>端口设计：</p>
<table>
<thead>
<tr>
<th align="center">方向</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">addr</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">WD</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">clk</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">reset</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">WE</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">data</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<h1 id="10-测试方案"><a href="#10-测试方案" class="headerlink" title="10. 测试方案"></a>10. 测试方案</h1><ol>
<li>通过机器码来检验正确性。根据输出来比对MARS中操作行为。</li>
<li>通过评测机来检验正确性。</li>
</ol>
<h1 id="11-思考题"><a href="#11-思考题" class="headerlink" title="11. 思考题"></a>11. 思考题</h1><ol>
<li><p>addr信号是ALU计算得到的，在lw或sw指令中，ALU将一个寄存器中的值和立即数经扩展移位之后的结果相加，得到的运算结果为address，作为addr端传入到DM中去访存数据。addr位数是[11:2]是因为addr的单位是字节，但是DM中memory数组的位宽是[31:0]，也就是一字。一字等于四字节。取addr的[11:2]位相当于将addr右移两位，即整除4，其代表的含义是该addr所在的字地址。通过该字地址，我们可以访存DM中addr的数据。</p>
</li>
<li><p>第一种是<strong>每种指令所对应的控制信息</strong>，代码示例如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg [31:0] instr;</span><br><span class="line"></span><br><span class="line">(identify instr)</span><br><span class="line"></span><br><span class="line">(assume outputs are o1,o2,o3...)</span><br><span class="line"></span><br><span class="line">always@(*) begin</span><br><span class="line">	case(instr)</span><br><span class="line">		instr1: begin</span><br><span class="line">			o1 = 1;</span><br><span class="line">			o2 = 1;</span><br><span class="line">			o3 = 0;</span><br><span class="line">			o4 = 1;</span><br><span class="line">			...</span><br><span class="line">			on = 1;</span><br><span class="line">		end</span><br><span class="line">		instr2: begin</span><br><span class="line">			o1 = 0;</span><br><span class="line">			o2 = 0;</span><br><span class="line">			o3 = 0;</span><br><span class="line">			o4 = 1;</span><br><span class="line">			...</span><br><span class="line">			on = 1;</span><br><span class="line">		end</span><br><span class="line">		instr3: begin</span><br><span class="line">			o1 = 1;</span><br><span class="line">			o2 = 1;</span><br><span class="line">			o3 = 0;</span><br><span class="line">			o4 = 0;</span><br><span class="line">			...</span><br><span class="line">			on = 0;</span><br><span class="line">		end</span><br><span class="line">		(similar codes like above)</span><br><span class="line">	endcase</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>好处</strong>：条理清晰，每种指令所对应的输出端口一目了然，结构层级明显，不容易出错，debug难度较低，便于统计。<br><strong>坏处</strong>：每一条指令均需要罗列全部的输出端口，重复性操作较多，添加指令较为麻烦。</p>
<p>  第二种是每种控制信息所需要的指令，代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg [31:0] instr;</span><br><span class="line"></span><br><span class="line">(identify instr)</span><br><span class="line"></span><br><span class="line">(assume outputs are o1,o2,o3...)</span><br><span class="line"></span><br><span class="line">always@(*) begin</span><br><span class="line">	if(instr == `instr1</span><br><span class="line">	|| instr == `instr2</span><br><span class="line">	|| instr == `instr4) begin</span><br><span class="line">		o1 = 1;</span><br><span class="line">	end else begin</span><br><span class="line">		o1 = 0;</span><br><span class="line">	end</span><br><span class="line"></span><br><span class="line">	if(instr == `instr3) begin</span><br><span class="line">		o2 = 1;</span><br><span class="line">	end else begin</span><br><span class="line">		o2 = 0;</span><br><span class="line">	end</span><br><span class="line"></span><br><span class="line">	if(instr == `instr4</span><br><span class="line">	|| instr == `instr5) begin</span><br><span class="line">		o3 = 1;</span><br><span class="line">	end else begin</span><br><span class="line">		o3 = 0;</span><br><span class="line">	end</span><br><span class="line">	(similar codes like above)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>好处</strong>：操作简单，新增指令只需要新增对应输出端口的判断条件即可，可维护性较强。<br><strong>缺点</strong>：可读性差，debug难度较高，无法直观显示指令与输出之间的关系。</p>
<ol start="3">
<li><p>同步复位是指，所有复位操作均在时钟上升沿进行。即reset在时钟周期中有效不会立即生效，得保持到clk上升沿才能复位。clk优先级高于reset。 异步复位是指，reset有效时立即复位，因此不用等到clk上升沿即可复位。reset优先级高于clk。</p>
</li>
<li><p>add或者addi首先检查两个操作数是否是合法的word，如果不是，会抛出UndefinedResult()异常。之后尝试相加并判断相加之后是否有符号溢出，如果符号溢出则会抛出SignalException()异常。如果不溢出则赋值给相应寄存器。addu或者addiu也会首先检查两个操作数是否是合法的word，如果不是则同样抛出UndefinedResult()异常。不一样的地方在于，相加之后取结果的[31:0]位直接复制给对应寄存器。这是因为对于无符号数，没有符号位，每一位的位权都是正的，因此直接相加即可，取低32位为运算结果。但有符号数的最高位是符号位，如果因为相加进位导致符号位的改变，则会改变运算结果的符号，因此需要判断是否有符号溢出。如果不考虑符号溢出，则无需关注相加是否导致符号位改变，只需要相加取低32位即可，默认程序员会维护加法运算。因此在不考虑溢出的情况下，有符号加法和无符号加法的操作方式都是一样的，可以认为是等价。</p>
</li>
</ol>
<blockquote>
<p>附一张Logisim的CPU框架方便理解<br><img src="/pictures/a6dc336229f1b8fd0a66cfe38d659c36.jpg" alt="alt text"></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成原理-CO-CPU-P5-设计报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CO-CPU-P5-%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-分析指令集"><a href="#1-分析指令集" class="headerlink" title="1. 分析指令集"></a>1. 分析指令集</h1><ul>
<li>经过分类，指令共包含R型指令和I型指令</li>
<li>列出其对应的32位机器码，寻找共性差异</li>
</ul>
<h2 id="R型指令："><a href="#R型指令：" class="headerlink" title="R型指令："></a>R型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Rd</th>
<th align="center">Shamt</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100000</td>
<td>相加(rs+rt-&gt;rd)</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100010</td>
<td>相减(rs-rt-&gt;rd)</td>
</tr>
</tbody></table>
<h2 id="I型指令："><a href="#I型指令：" class="headerlink" title="I型指令："></a>I型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Immediate</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ori</td>
<td align="center">001101</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>或运算(rs|immediate-&gt;rt)</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">001111</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>立即数加载至高16位({immediate||{16{1’b0}}}-&gt;rt)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Offset</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lw</td>
<td align="center">100011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>加载字(rs+offset在memory中data-&gt;rt)</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">101011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>保存字(rt-&gt;rs+offset在memory中的data)</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">000100</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs与rt相等则PC偏移offset*4</td>
</tr>
</tbody></table>
<h2 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h2><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Op</th>
<th align="center">instr_index</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jal</td>
<td align="center">000011</td>
<td align="center">(26)</td>
<td>跳转至index并且PC+4 -&gt; $ra</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Op</th>
<th align="center">rs</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jr</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">{10{1’b0}}</td>
<td align="center">{5{1’b0}}</td>
<td align="center">001000</td>
<td>跳转至$rs中的地址</td>
</tr>
</tbody></table>
<h1 id="2-阶段分析"><a href="#2-阶段分析" class="headerlink" title="2. 阶段分析"></a>2. 阶段分析</h1><p><img src="/pictures/888df695e6b12d3c9ed7e9c5219360f.png" alt="alt text"><br>F阶段PC值已经确定，进行的是根据PC访存相应的Instruction操作。<strong>此时指令已经确定好了</strong><br>D阶段是将instruction转换成对应的操作数、产生控制信号。<br>E阶段是将操作数转换成计算结果。<br>M阶段是方寸数据内存。<br>W阶段是写入GRF。</p>
<h1 id="3-命名规则"><a href="#3-命名规则" class="headerlink" title="3.命名规则"></a>3.命名规则</h1><p>采用首字母大写命名法，每个单词首字母大写。</p>
<h1 id="4-PC设计"><a href="#4-PC设计" class="headerlink" title="4. PC设计"></a>4. PC设计</h1><p> 端口设计：</p>
<table>
<thead>
<tr>
<th align="center">方向</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">PcOp</td>
<td align="center">[3:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">BeqPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">JalPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">JrPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">reset</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">clk</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Pc_F</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<p>转移设计：</p>
<table>
<thead>
<tr>
<th align="center">PcOp</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">Pc_F &lt;&#x3D; Pc_F + 4</td>
</tr>
<tr>
<td align="center">0001</td>
<td align="center">Pc_F &lt;&#x3D; BeqPc</td>
</tr>
<tr>
<td align="center">0010</td>
<td align="center">Pc_F &lt;&#x3D; JalPc</td>
</tr>
<tr>
<td align="center">0011</td>
<td align="center">Pc_F &lt;&#x3D; JrPc</td>
</tr>
</tbody></table>
<h1 id="5-CU控制信号分析"><a href="#5-CU控制信号分析" class="headerlink" title="5. CU控制信号分析"></a>5. CU控制信号分析</h1><h3 id="端口设计："><a href="#端口设计：" class="headerlink" title="端口设计："></a>端口设计：</h3><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">Op</td>
<td align="center">[5:0]</td>
<td>机器码高6位</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">Func</td>
<td align="center">[5:0]</td>
<td>机器码低6位</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">RegDst</td>
<td align="center">[1:0]</td>
<td>GRF被写入寄存器是rt还是rd。0是rt，1是rd，10是$ra</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">AluSrc</td>
<td align="center">[1:0]</td>
<td>ALU第二个运算值是rt还是立即数。0是rt，1是立即数</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">MemToReg</td>
<td align="center">[1:0]</td>
<td>GRF写入值是ALUans还是DMans。0是ALUans，1是DMans，10是PC + 4</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">RegWrite</td>
<td align="center">1</td>
<td>是否写入GRF</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">MemWrite</td>
<td align="center">1</td>
<td>是否写入RAM</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">PcSel</td>
<td align="center">[3:0]</td>
<td>当前指令是否是beq\jal\jr</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ExtOp</td>
<td align="center">[7:0]</td>
<td>扩展操作类型类型，详见Extender</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">AluOp</td>
<td align="center">[7:0]</td>
<td>ALU运算类型，详见ALU</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">InstrType</td>
<td align="center">[7:0]</td>
<td>指令类型</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">TNew_D</td>
<td align="center">[3:0]</td>
<td>从D级开始，经过多少周期该指令产生运算结果</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">TUse1_D,TUse2_D</td>
<td align="center">[3:0]</td>
<td>从D级开始，经过多少周期要用到运算结果</td>
</tr>
</tbody></table>
<ul>
<li>内部电路采用最小项表达式判断法，先判断Op，再判断Func</li>
</ul>
<p>每种指令所需控制信号：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RegDst</th>
<th align="center">AluSrc</th>
<th align="center">MemToReg</th>
<th align="center">RegWrite</th>
<th align="center">MemWrite</th>
<th align="center">PcSel</th>
<th align="center">ExtOp</th>
<th align="center">AluOp</th>
<th>TNew</th>
<th>TUse1</th>
<th>TUse2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center"></td>
<td align="center">ADD</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center"></td>
<td align="center">SUB</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0000</td>
<td align="center">OR</td>
<td>2</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0010</td>
<td align="center">ADD</td>
<td>2</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">01</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">ADD</td>
<td>3</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">11</td>
<td align="center">01</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">ADD</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0001</td>
<td align="center">0011</td>
<td align="center">EQUAL</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">10</td>
<td align="center"></td>
<td align="center">10</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0010</td>
<td align="center">0100</td>
<td align="center"></td>
<td>0</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0011</td>
<td align="center"></td>
<td align="center">ADD</td>
<td>0</td>
<td>0</td>
<td>10</td>
</tr>
</tbody></table>
<h1 id="6-流水线寄存器存储信息分析"><a href="#6-流水线寄存器存储信息分析" class="headerlink" title="6. 流水线寄存器存储信息分析"></a>6. 流水线寄存器存储信息分析</h1><h3 id="F级："><a href="#F级：" class="headerlink" title="F级："></a>F级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_F</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">Instruction_F</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<h3 id="D级："><a href="#D级：" class="headerlink" title="D级："></a>D级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">RD1_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">RD2_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_D</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">ExtAns_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_D</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_D</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">AluSrc_D</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">MemWrite_D</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">AluOp_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">InstrType_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">Addr1_D</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">Addr2_D</td>
<td align="center">[4:0]</td>
</tr>
</tbody></table>
<h3 id="E级："><a href="#E级：" class="headerlink" title="E级："></a>E级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_E</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">RD2_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_E</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_E</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">MemWrite_E</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_E</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_E</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">Addr2_E</td>
<td align="center">[4:0]</td>
</tr>
</tbody></table>
<h3 id="M级："><a href="#M级：" class="headerlink" title="M级："></a>M级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_M</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">DmAns_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_M</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">RegWrite_M</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_M</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_M</td>
<td align="center">[7:0]</td>
</tr>
</tbody></table>
<h3 id="W级："><a href="#W级：" class="headerlink" title="W级："></a>W级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_W</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">DmAns_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_W</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_W</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_W</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_W</td>
<td align="center">[7:0]</td>
</tr>
</tbody></table>
<h1 id="7-流水线转发数据"><a href="#7-流水线转发数据" class="headerlink" title="7. 流水线转发数据"></a>7. 流水线转发数据</h1><h3 id="E级：-1"><a href="#E级：-1" class="headerlink" title="E级："></a>E级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_E</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_E + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="M级：-1"><a href="#M级：-1" class="headerlink" title="M级："></a>M级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_M</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_M + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="W级：-1"><a href="#W级：-1" class="headerlink" title="W级："></a>W级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_W</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_W + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">DmAns_W</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h1 id="8-测试方案"><a href="#8-测试方案" class="headerlink" title="8. 测试方案"></a>8. 测试方案</h1><h4 id="1-数据通路测试：先不考虑转发和阻塞，单纯检验数据通路是否正确，为了避免冒险情况，相邻两个指令之间间隔三个nop指令。"><a href="#1-数据通路测试：先不考虑转发和阻塞，单纯检验数据通路是否正确，为了避免冒险情况，相邻两个指令之间间隔三个nop指令。" class="headerlink" title="1. 数据通路测试：先不考虑转发和阻塞，单纯检验数据通路是否正确，为了避免冒险情况，相邻两个指令之间间隔三个nop指令。"></a>1. 数据通路测试：先不考虑转发和阻塞，单纯检验数据通路是否正确，为了避免冒险情况，相邻两个指令之间间隔三个nop指令。</h4><p><img src="/pictures/ea18bc7fef45d031c01125d4f954bc5.png"></p>
<p><img src="/pictures/3cc02e3e2c5554e03be5d6c21c9611a.png"></p>
<p><img src="/pictures/d566ff89e1b755e36c04faba2d7e924.png"></p>
<h4 id="2-转发阻塞测试：测试连续访存的指令，跳转指令，与MARS行为对应。"><a href="#2-转发阻塞测试：测试连续访存的指令，跳转指令，与MARS行为对应。" class="headerlink" title="2. 转发阻塞测试：测试连续访存的指令，跳转指令，与MARS行为对应。"></a>2. 转发阻塞测试：测试连续访存的指令，跳转指令，与MARS行为对应。</h4><h1 id="9-思考题"><a href="#9-思考题" class="headerlink" title="9. 思考题"></a>9. 思考题</h1><ol>
<li>原因：我们跳转指令的判断在D级进行，但实际上是在D级的最后进行的。在此之前，我们需要完成指令译码、产生控制信号、阻塞判断、GRF读取、转发判断等操作，之后再依据跳转指令类型决定后续操作(beq：判断两个寄存器值是否相等；jal：立即数位扩展；jr：$rs寄存器的值)。这些前置步骤会消耗一定的时间，导致最后剩余给跳转判断的时间很紧张，容易产生数据冒险，使跳转判断不准确，因此并非总能提高效率。并且由于在D级就要使用数据，所以Tuse&#x3D;0，这使得如果要使用的数据还未被算出，则要阻塞很长时间，导致指令效率下降。<br>例子：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lui $t0 1</span><br><span class="line">sw $t0 0($0)</span><br><span class="line">lw $t1 0($0)</span><br><span class="line">beq $t1 $0 label</span><br><span class="line">label:</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>因为jal本意是PC跳转到标签处，并把当前指令的下一条要执行的指令存入$ra，当没有延迟槽的时候，当前指令的下一条指令就是PC + 4。而有延迟槽时，jal指令并不会立即跳转，而是会先执行PC + 4这条指令再跳转，因此真正的下一条要执行的指令是PC + 8。这样可以多执行一条指令，又不耽误之后的指令执行，提高指令执行效率。</li>
<li>因为功能部件产生转发数据是需要时间的，如果我们使用功能部件产生的数据转发，那么之后我们还要用转发的数据再进行一些操作，这些操作挤占在一个时钟周期内反而会降低效率。如果我们使用流水寄存器的数据，我们可以在周期刚开始就获得转发数据，从而有充足的时间去进行后续操作。</li>
<li>因为W级的数据会写入GRF,同时D级数据也会读取GRF。如果被写入数据和被读取数据是同一个，那么被读取的数据应该是写入的结果而不是原来的结果。此时可以用GRF内部转发解决问题。实现方式为：判断该寄存器是不是$0，如果是则为0，如果不是，判断写入寄存器和读取寄存器是否是同一个，如果是，则读取写入结果，否则读取原来寄存器的值。</li>
<li>转发数据的需求者可能来自于D,E,M级，转发供给者可能来自于E,M,W级。转发数据通路有：D级接受E,M,W级的转发，E级接受M,W的转发，M级接受W级的转发。</li>
<li>可能扩展ALU的运算类型，控制信号的类型，寄存器传递的控制信号的种类，阻塞条件等。</li>
<li>我采用集中式译码器，在D级集中产生控制信号，并随着流水线传递控制信号。这种架构的好处是只需要一个译码器，只需要产生一次控制信号，进行一次状态判断。不足之处是流水线寄存器需要传递较多控制信号，操作量比较大，且修改需要一并修改后面的流水线寄存器。</li>
<li>测试方案分为数据通路测试和转发阻塞测试。数据通路测试不涉及转发阻塞，单纯用来检测每一条指令能否正常执行，为了避免产生冒险，在编写测试代码的时候，相邻指令之间要相隔3-4个nop指令。测试转发和阻塞数据时，主要针对冒险情况来编写代码，可以列举哪些指令相邻出现需要转发或者阻塞，然后抽样测试，与MARS行为进行对照。</li>
</ol>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成原理-CO-CPU-P7-设计报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CO-CPU-P7-%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-分析指令集"><a href="#1-分析指令集" class="headerlink" title="1. 分析指令集"></a>1. 分析指令集</h1><ul>
<li>经过分类，指令共包含R型指令和I型指令</li>
<li>列出其对应的32位机器码，寻找共性差异</li>
</ul>
<h2 id="R型指令："><a href="#R型指令：" class="headerlink" title="R型指令："></a>R型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Rd</th>
<th align="center">Shamt</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100000</td>
<td>相加(rs+rt-&gt;rd)</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100010</td>
<td>相减(rs-rt-&gt;rd)</td>
</tr>
<tr>
<td align="center">and</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100100</td>
<td>rs &amp; rt -&gt; rd</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100101</td>
<td>rs | rt -&gt; rd</td>
</tr>
<tr>
<td align="center">slt</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">101010</td>
<td>rs &lt; rt ? 1 : 0(signed)</td>
</tr>
<tr>
<td align="center">sltu</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">101011</td>
<td>rs &lt; rt ? 1 : 0(unsigned)</td>
</tr>
<tr>
<td align="center">mfhi</td>
<td align="center">000000</td>
<td align="center">00000</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">010000</td>
<td>HI -&gt;rd</td>
</tr>
<tr>
<td align="center">mflo</td>
<td align="center">000000</td>
<td align="center">00000</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">010010</td>
<td>LO -&gt; rd</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">0</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mult</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">0000000000</td>
<td align="center">011000</td>
<td>rs * rt -&gt; (HI, LO)(signed)</td>
</tr>
<tr>
<td align="center">multu</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">0000000000</td>
<td align="center">011001</td>
<td>rs * rt -&gt; (HI, LO)(unsigned)</td>
</tr>
<tr>
<td align="center">div</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">0000000000</td>
<td align="center">011010</td>
<td>rs &#x2F; rt -&gt; (HI, LO)(signed)</td>
</tr>
<tr>
<td align="center">divu</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">0000000000</td>
<td align="center">011011</td>
<td>rs &#x2F; rt -&gt; (HI, LO)(unsigned)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">0</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mthi</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">000000000000000</td>
<td align="center">010001</td>
<td>rs -&gt; HI</td>
</tr>
<tr>
<td align="center">mtlo</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">000000000000000</td>
<td align="center">010011</td>
<td>rs -&gt; LO</td>
</tr>
</tbody></table>
<h2 id="I型指令："><a href="#I型指令：" class="headerlink" title="I型指令："></a>I型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Immediate</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ori</td>
<td align="center">001101</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>或运算(rs|immediate-&gt;rt)</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">001111</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>立即数加载至高16位({immediate||{16{1’b0}}}-&gt;rt)</td>
</tr>
<tr>
<td align="center">addi</td>
<td align="center">001000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs + immediate -&gt; rt</td>
</tr>
<tr>
<td align="center">andi</td>
<td align="center">001100</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs &amp; immediate -&gt; rt</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Offset</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lw</td>
<td align="center">100011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>加载字(rs+offset在memory中data-&gt;rt)</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">101011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>保存字(rt-&gt;rs+offset在memory中的data)</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">000100</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs与rt相等则PC偏移offset*4</td>
</tr>
<tr>
<td align="center">lb</td>
<td align="center">100000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>mem中rs +offset对应字节符号拓展 -&gt; rt</td>
</tr>
<tr>
<td align="center">lh</td>
<td align="center">100001</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>mem中rs +offset对应半字符号拓展 -&gt; rt</td>
</tr>
<tr>
<td align="center">sb</td>
<td align="center">101000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rt[7:0] -&gt; mem(offset + rs)</td>
</tr>
<tr>
<td align="center">sh</td>
<td align="center">101001</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rt[15:0] -&gt; mem(offset + rs)</td>
</tr>
<tr>
<td align="center">bne</td>
<td align="center">000101</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>不相等则跳转</td>
</tr>
</tbody></table>
<h2 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h2><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Op</th>
<th align="center">instr_index</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jal</td>
<td align="center">000011</td>
<td align="center">(26)</td>
<td>跳转至index并且PC+4 -&gt; $ra</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Op</th>
<th align="center">rs</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jr</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">{10{1’b0}}</td>
<td align="center">{5{1’b0}}</td>
<td align="center">001000</td>
<td>跳转至$rs中的地址</td>
</tr>
</tbody></table>
<h1 id="2-阶段分析"><a href="#2-阶段分析" class="headerlink" title="2. 阶段分析"></a>2. 阶段分析</h1><p><img src="/pictures/888df695e6b12d3c9ed7e9c5219360f.png"><br>F阶段PC值已经确定，进行的是根据PC访存相应的Instruction操作。<strong>此时指令已经确定好了</strong><br>D阶段是将instruction转换成对应的操作数、产生控制信号。<br>E阶段是将操作数转换成计算结果。<br>M阶段是方寸数据内存。<br>W阶段是写入GRF。</p>
<h1 id="3-命名规则"><a href="#3-命名规则" class="headerlink" title="3.命名规则"></a>3.命名规则</h1><p>采用首字母大写命名法，每个单词首字母大写。</p>
<h1 id="4-PC设计"><a href="#4-PC设计" class="headerlink" title="4. PC设计"></a>4. PC设计</h1><p> 端口设计：</p>
<table>
<thead>
<tr>
<th align="center">方向</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">PcOp</td>
<td align="center">[3:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">BeqPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">JalPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">JrPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">reset</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">clk</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Pc_F</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">BnePc</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<p>转移设计：</p>
<table>
<thead>
<tr>
<th align="center">PcOp</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">Pc_F &lt;&#x3D; Pc_F + 4</td>
</tr>
<tr>
<td align="center">0001</td>
<td align="center">Pc_F &lt;&#x3D; BeqPc</td>
</tr>
<tr>
<td align="center">0010</td>
<td align="center">Pc_F &lt;&#x3D; JalPc</td>
</tr>
<tr>
<td align="center">0011</td>
<td align="center">Pc_F &lt;&#x3D; JrPc</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">Pc_F &lt;&#x3D; BnePc</td>
</tr>
</tbody></table>
<h1 id="5-CU控制信号分析"><a href="#5-CU控制信号分析" class="headerlink" title="5. CU控制信号分析"></a>5. CU控制信号分析</h1><h3 id="端口设计："><a href="#端口设计：" class="headerlink" title="端口设计："></a>端口设计：</h3><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">Op</td>
<td align="center">[5:0]</td>
<td>机器码高6位</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">Func</td>
<td align="center">[5:0]</td>
<td>机器码低6位</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">RegDst</td>
<td align="center">[1:0]</td>
<td>GRF被写入寄存器是rt还是rd。0是rt，1是rd，10是$ra</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">AluSrc</td>
<td align="center">[1:0]</td>
<td>ALU第二个运算值是rt还是立即数。0是rt，1是立即数</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">MemToReg</td>
<td align="center">[1:0]</td>
<td>GRF写入值是ALUans还是DMans。0是ALUans，1是DMans，10是PC + 4</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">RegWrite</td>
<td align="center">1</td>
<td>是否写入GRF</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">MemWrite</td>
<td align="center">1</td>
<td>是否写入RAM</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">PcSel</td>
<td align="center">[3:0]</td>
<td>当前指令是否是beq\jal\jr</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ExtOp</td>
<td align="center">[7:0]</td>
<td>扩展操作类型类型，详见Extender</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">AluOp</td>
<td align="center">[7:0]</td>
<td>ALU运算类型，详见ALU</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">InstrType</td>
<td align="center">[7:0]</td>
<td>指令类型</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">TNew_D</td>
<td align="center">[3:0]</td>
<td>从D级开始，经过多少周期该指令产生运算结果</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">TUse1_D,TUse2_D</td>
<td align="center">[3:0]</td>
<td>从D级开始，经过多少周期要用到运算结果</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Multiply_D</td>
<td align="center">1</td>
<td>是否进行乘法操作</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Divide_D</td>
<td align="center">1</td>
<td>是否进行除法操作</td>
</tr>
</tbody></table>
<ul>
<li>内部电路采用最小项表达式判断法，先判断Op，再判断Func</li>
</ul>
<p>每种指令所需控制信号：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RegDst</th>
<th align="center">AluSrc</th>
<th align="center">MemToReg</th>
<th align="center">RegWrite</th>
<th align="center">MemWrite</th>
<th align="center">PcSel</th>
<th align="center">ExtOp</th>
<th align="center">AluOp</th>
<th>TNew</th>
<th>TUse1</th>
<th>TUse2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center"></td>
<td align="center">ADD</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center"></td>
<td align="center">SUB</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0000</td>
<td align="center">OR</td>
<td>2</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0010</td>
<td align="center">ADD</td>
<td>2</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">01</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">ADD</td>
<td>3</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">11</td>
<td align="center">01</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">ADD</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0001</td>
<td align="center">0011</td>
<td align="center">EQUAL</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">10</td>
<td align="center"></td>
<td align="center">10</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0010</td>
<td align="center">0100</td>
<td align="center"></td>
<td>0</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0011</td>
<td align="center"></td>
<td align="center">ADD</td>
<td>0</td>
<td>0</td>
<td>10</td>
</tr>
</tbody></table>
<h1 id="6-流水线寄存器存储信息分析"><a href="#6-流水线寄存器存储信息分析" class="headerlink" title="6. 流水线寄存器存储信息分析"></a>6. 流水线寄存器存储信息分析</h1><h3 id="F级："><a href="#F级：" class="headerlink" title="F级："></a>F级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_F</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">Instruction_F</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<h3 id="D级："><a href="#D级：" class="headerlink" title="D级："></a>D级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">RD1_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">RD2_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_D</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">ExtAns_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_D</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_D</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">AluSrc_D</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">MemWrite_D</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">AluOp_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">InstrType_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">Addr1_D</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">Addr2_D</td>
<td align="center">[4:0]</td>
</tr>
</tbody></table>
<h3 id="E级："><a href="#E级：" class="headerlink" title="E级："></a>E级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_E</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">RD2_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_E</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_E</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">MemWrite_E</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_E</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_E</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">Addr2_E</td>
<td align="center">[4:0]</td>
</tr>
</tbody></table>
<h3 id="M级："><a href="#M级：" class="headerlink" title="M级："></a>M级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_M</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">DmAns_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_M</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">RegWrite_M</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_M</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_M</td>
<td align="center">[7:0]</td>
</tr>
</tbody></table>
<h3 id="W级："><a href="#W级：" class="headerlink" title="W级："></a>W级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_W</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">DmAns_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_W</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_W</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_W</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_W</td>
<td align="center">[7:0]</td>
</tr>
</tbody></table>
<h1 id="7-流水线转发数据"><a href="#7-流水线转发数据" class="headerlink" title="7. 流水线转发数据"></a>7. 流水线转发数据</h1><h3 id="E级：-1"><a href="#E级：-1" class="headerlink" title="E级："></a>E级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_E</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_E + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="M级：-1"><a href="#M级：-1" class="headerlink" title="M级："></a>M级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_M</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_M + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="W级：-1"><a href="#W级：-1" class="headerlink" title="W级："></a>W级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_W</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_W + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">DmAns_W</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h1 id="8-测试方案"><a href="#8-测试方案" class="headerlink" title="8. 测试方案"></a>8. 测试方案</h1><p>针对每一条新添加的指令都进行测试，确保有符号、无符号的正确性，以及周期数的正确。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3508000c</span><br><span class="line">35290015</span><br><span class="line">01095024</span><br><span class="line">000a5820</span><br><span class="line">35080010</span><br><span class="line">35290019</span><br><span class="line">01095025</span><br><span class="line">01405820</span><br><span class="line">2108ffff</span><br><span class="line">2108ffff</span><br><span class="line">2108fffe</span><br><span class="line">310a0079</span><br><span class="line">314a0015</span><br><span class="line">000a582a</span><br><span class="line">2009ffff</span><br><span class="line">0120582a</span><br><span class="line">0000582a</span><br><span class="line">200afffe</span><br><span class="line">012a582a</span><br><span class="line">0149582a</span><br><span class="line">012a582b</span><br><span class="line">340c03e8</span><br><span class="line">012c582a</span><br><span class="line">012c582b</span><br><span class="line">0169582b</span><br><span class="line">14000007</span><br><span class="line">20080001</span><br><span class="line">20080002</span><br><span class="line">20080003</span><br><span class="line">14080003</span><br><span class="line">20080004</span><br><span class="line">20080005</span><br><span class="line">20080006</span><br><span class="line">20080003</span><br><span class="line">2009fffe</span><br><span class="line">200a0002</span><br><span class="line">01090018</span><br><span class="line">01090019</span><br><span class="line">010a0018</span><br><span class="line">0109001a</span><br><span class="line">0109001b</span><br><span class="line">010a001a</span><br><span class="line">00004010</span><br><span class="line">21080001</span><br><span class="line">00004012</span><br><span class="line">21080003</span><br><span class="line">00004010</span><br><span class="line">1100fff1</span><br><span class="line">20090003</span><br><span class="line">20090007</span><br><span class="line">01200011</span><br><span class="line">00005010</span><br><span class="line">012a0018</span><br><span class="line">01600013</span><br><span class="line">00005812</span><br><span class="line">016a5824</span><br><span class="line">2008fffd</span><br><span class="line">20090001</span><br><span class="line">200a0002</span><br><span class="line">200b0003</span><br><span class="line">a0080000</span><br><span class="line">a1280000</span><br><span class="line">a1480000</span><br><span class="line">a1680000</span><br><span class="line">a4080004</span><br><span class="line">a5480008</span><br><span class="line">800c0004</span><br><span class="line">218c0002</span><br><span class="line">814c0004</span><br><span class="line">218c000d</span><br><span class="line">840c0004</span><br><span class="line">218c0034</span><br><span class="line">34080005</span><br><span class="line">34090022</span><br><span class="line">00084022</span><br><span class="line">00094822</span><br><span class="line">01280018</span><br><span class="line">00005010</span><br><span class="line">00005812</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="9-思考题汇总"><a href="#9-思考题汇总" class="headerlink" title="9. 思考题汇总"></a>9. 思考题汇总</h1><ol>
<li>鼠标和键盘的信号被CPU知晓的过程涉及到<strong>硬件中断、信号传输、以及操作系统的参与</strong>。</li>
</ol>
<h3 id="鼠标信号被CPU知晓的过程"><a href="#鼠标信号被CPU知晓的过程" class="headerlink" title="鼠标信号被CPU知晓的过程"></a>鼠标信号被CPU知晓的过程</h3><ol>
<li><strong>鼠标信号的产生</strong>：当鼠标移动或点击时，会产生相应的电信号或数字信号。这些信号代表了鼠标的位置、移动方向、点击动作等信息。</li>
<li><strong>信号传输到计算机</strong>：这些信号通过鼠标线（有线鼠标）或无线方式（无线鼠标）传输到计算机的USB接口或其他类型的接口上。</li>
<li><strong>中断请求</strong>：一旦鼠标信号到达计算机，它会触发一个硬件中断。这个中断请求会被送到中断控制器，中断控制器再将请求转发给CPU。</li>
<li><strong>CPU处理中断</strong>：CPU在接收到中断请求后，会暂停当前正在执行的任务，转而处理鼠标中断。CPU会读取鼠标控制器中的数据，这些数据包含了鼠标的位置信息和状态信息。</li>
<li><strong>操作系统的角色</strong>：操作系统会进一步处理这些原始数据，将其转换为更高级别的事件，如鼠标移动事件或点击事件，并将这些事件传递给应用程序。</li>
</ol>
<h3 id="键盘信号被CPU知晓的过程"><a href="#键盘信号被CPU知晓的过程" class="headerlink" title="键盘信号被CPU知晓的过程"></a>键盘信号被CPU知晓的过程</h3><ol>
<li><p><strong>键盘信号的产生</strong>：当用户按下键盘上的某个键时，键盘内部的电路会产生一个相应的电信号。这个信号代表了被按下的键的位置信息。</p>
</li>
<li><p><strong>信号编码</strong>：键盘控制器将这些电信号转换为键盘扫描码，这是一种二进制编码，用于表示键盘上每个键的唯一标识。</p>
</li>
<li><p><strong>信号传输到计算机</strong>：键盘扫描码通过键盘线传输到计算机的USB接口或其他类型的接口上。</p>
</li>
<li><p><strong>中断请求与CPU处理</strong>：与鼠标类似，键盘信号也会引起硬件中断。CPU在接收到中断请求后，会读取键盘控制器中的扫描码，并将其存储在特定的内存位置（如键盘缓冲区）中。</p>
</li>
<li><p><strong>操作系统与驱动程序</strong>：操作系统和键盘驱动程序会进一步处理这些扫描码，将其转换为ASCII码或Unicode码等字符编码，以便应用程序能够理解和使用。</p>
</li>
<li><p>因为这样，我们就可以提前在该地址处书写异常处理程序；当异常发生时，只需要固定跳转到该地址，即可运行相对应的异常处理程序来处理异常。如果是用户自定义处理异常中断的入口地址，自己提供程序，那么CPU仍然可以正常提供异常中断修复的功能。但是这样的问题在于用户的自定义程序入口或自定义程序可能占用了DM的存储空间，导致DM空间不足或者访存指令出错。</p>
</li>
<li><p>因为每种外设的接口不同，格式不同，方寸方式也不同。如果不用Bridge，则CPU需要为每一种外设都新增新的方寸方式或者接口，这不利于维护CPU的正常工作。而Bridge可以解决这一问题，通过读取CPU的信号和外设的信号，来进行中间的交互，转移了工作量，有利于CPU的功能维护和扩展。</p>
</li>
<li><p>两种中断模式在计数为0后的行为不同。一种是自动填装初值再重新倒数，一种是保持为0直到使能信号置位再计数。![[810a3c13b390e6a91ad2365bd55281f.jpg]]<br>![[12ac7de1353c985830c21aa192065fc.jpg]]</p>
</li>
<li><p>会发生的问题是，空泡的PC和BD可能不是我们所期待的，从而导致eret指令返回地址异常。因此空泡指令需要保存原指令的PC和BD，如果在空泡时遇到了中断，也能根据PC和BD返回正确的指令。</p>
</li>
<li><p>因为会存在冒险。jalr指令的功能是跳转到对应寄存器中的地址，同时把PC+4（有延迟槽则PC+8）的值写入对应寄存器中。如果后面两个寄存器都是相同的，则先跳转再写入还是先写入再跳转就会产生两种不一样的结果。因此为了避免这种未知情况的发生，不能这样写。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>北航计算机组成原理-CO-CPU-P6-设计报告</title>
    <url>/2025/07/01/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-CO-CPU-P6-%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="1-分析指令集"><a href="#1-分析指令集" class="headerlink" title="1. 分析指令集"></a>1. 分析指令集</h1><ul>
<li>经过分类，指令共包含R型指令和I型指令</li>
<li>列出其对应的32位机器码，寻找共性差异</li>
</ul>
<h2 id="R型指令："><a href="#R型指令：" class="headerlink" title="R型指令："></a>R型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Rd</th>
<th align="center">Shamt</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100000</td>
<td>相加(rs+rt-&gt;rd)</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100010</td>
<td>相减(rs-rt-&gt;rd)</td>
</tr>
<tr>
<td align="center">and</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100100</td>
<td>rs &amp; rt -&gt; rd</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">100101</td>
<td>rs | rt -&gt; rd</td>
</tr>
<tr>
<td align="center">slt</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">101010</td>
<td>rs &lt; rt ? 1 : 0(signed)</td>
</tr>
<tr>
<td align="center">sltu</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">101011</td>
<td>rs &lt; rt ? 1 : 0(unsigned)</td>
</tr>
<tr>
<td align="center">mfhi</td>
<td align="center">000000</td>
<td align="center">00000</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">010000</td>
<td>HI -&gt;rd</td>
</tr>
<tr>
<td align="center">mflo</td>
<td align="center">000000</td>
<td align="center">00000</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">00000</td>
<td align="center">010010</td>
<td>LO -&gt; rd</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">0</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mult</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">0000000000</td>
<td align="center">011000</td>
<td>rs * rt -&gt; (HI, LO)(signed)</td>
</tr>
<tr>
<td align="center">multu</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">0000000000</td>
<td align="center">011001</td>
<td>rs * rt -&gt; (HI, LO)(unsigned)</td>
</tr>
<tr>
<td align="center">div</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">0000000000</td>
<td align="center">011010</td>
<td>rs &#x2F; rt -&gt; (HI, LO)(signed)</td>
</tr>
<tr>
<td align="center">divu</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">0000000000</td>
<td align="center">011011</td>
<td>rs &#x2F; rt -&gt; (HI, LO)(unsigned)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">0</th>
<th align="center">Func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mthi</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">000000000000000</td>
<td align="center">010001</td>
<td>rs -&gt; HI</td>
</tr>
<tr>
<td align="center">mtlo</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">000000000000000</td>
<td align="center">010011</td>
<td>rs -&gt; LO</td>
</tr>
</tbody></table>
<h2 id="I型指令："><a href="#I型指令：" class="headerlink" title="I型指令："></a>I型指令：</h2><table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Immediate</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ori</td>
<td align="center">001101</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>或运算(rs|immediate-&gt;rt)</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">001111</td>
<td align="center">00000</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>立即数加载至高16位({immediate||{16{1’b0}}}-&gt;rt)</td>
</tr>
<tr>
<td align="center">addi</td>
<td align="center">001000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs + immediate -&gt; rt</td>
</tr>
<tr>
<td align="center">andi</td>
<td align="center">001100</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs &amp; immediate -&gt; rt</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Op</th>
<th align="center">Rs</th>
<th align="center">Rt</th>
<th align="center">Offset</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lw</td>
<td align="center">100011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>加载字(rs+offset在memory中data-&gt;rt)</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">101011</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>保存字(rt-&gt;rs+offset在memory中的data)</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">000100</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rs与rt相等则PC偏移offset*4</td>
</tr>
<tr>
<td align="center">lb</td>
<td align="center">100000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>mem中rs +offset对应字节符号拓展 -&gt; rt</td>
</tr>
<tr>
<td align="center">lh</td>
<td align="center">100001</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>mem中rs +offset对应半字符号拓展 -&gt; rt</td>
</tr>
<tr>
<td align="center">sb</td>
<td align="center">101000</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rt[7:0] -&gt; mem(offset + rs)</td>
</tr>
<tr>
<td align="center">sh</td>
<td align="center">101001</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>rt[15:0] -&gt; mem(offset + rs)</td>
</tr>
<tr>
<td align="center">bne</td>
<td align="center">000101</td>
<td align="center">(5)</td>
<td align="center">(5)</td>
<td align="center">(16)</td>
<td>不相等则跳转</td>
</tr>
</tbody></table>
<h2 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h2><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Op</th>
<th align="center">instr_index</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jal</td>
<td align="center">000011</td>
<td align="center">(26)</td>
<td>跳转至index并且PC+4 -&gt; $ra</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Op</th>
<th align="center">rs</th>
<th align="center">0</th>
<th align="center">0</th>
<th align="center">func</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jr</td>
<td align="center">000000</td>
<td align="center">(5)</td>
<td align="center">{10{1’b0}}</td>
<td align="center">{5{1’b0}}</td>
<td align="center">001000</td>
<td>跳转至$rs中的地址</td>
</tr>
</tbody></table>
<h1 id="2-阶段分析"><a href="#2-阶段分析" class="headerlink" title="2. 阶段分析"></a>2. 阶段分析</h1><p><img src="/pictures/888df695e6b12d3c9ed7e9c5219360f.png"><br>F阶段PC值已经确定，进行的是根据PC访存相应的Instruction操作。<strong>此时指令已经确定好了</strong><br>D阶段是将instruction转换成对应的操作数、产生控制信号。<br>E阶段是将操作数转换成计算结果。<br>M阶段是方寸数据内存。<br>W阶段是写入GRF。</p>
<h1 id="3-命名规则"><a href="#3-命名规则" class="headerlink" title="3.命名规则"></a>3.命名规则</h1><p>采用首字母大写命名法，每个单词首字母大写。</p>
<h1 id="4-PC设计"><a href="#4-PC设计" class="headerlink" title="4. PC设计"></a>4. PC设计</h1><p> 端口设计：</p>
<table>
<thead>
<tr>
<th align="center">方向</th>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">PcOp</td>
<td align="center">[3:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">BeqPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">JalPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">JrPc</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">reset</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">clk</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Pc_F</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">BnePc</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<p>转移设计：</p>
<table>
<thead>
<tr>
<th align="center">PcOp</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">Pc_F &lt;&#x3D; Pc_F + 4</td>
</tr>
<tr>
<td align="center">0001</td>
<td align="center">Pc_F &lt;&#x3D; BeqPc</td>
</tr>
<tr>
<td align="center">0010</td>
<td align="center">Pc_F &lt;&#x3D; JalPc</td>
</tr>
<tr>
<td align="center">0011</td>
<td align="center">Pc_F &lt;&#x3D; JrPc</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">Pc_F &lt;&#x3D; BnePc</td>
</tr>
</tbody></table>
<h1 id="5-CU控制信号分析"><a href="#5-CU控制信号分析" class="headerlink" title="5. CU控制信号分析"></a>5. CU控制信号分析</h1><h3 id="端口设计："><a href="#端口设计：" class="headerlink" title="端口设计："></a>端口设计：</h3><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">位宽</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">Op</td>
<td align="center">[5:0]</td>
<td>机器码高6位</td>
</tr>
<tr>
<td align="center">input</td>
<td align="center">Func</td>
<td align="center">[5:0]</td>
<td>机器码低6位</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">RegDst</td>
<td align="center">[1:0]</td>
<td>GRF被写入寄存器是rt还是rd。0是rt，1是rd，10是$ra</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">AluSrc</td>
<td align="center">[1:0]</td>
<td>ALU第二个运算值是rt还是立即数。0是rt，1是立即数</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">MemToReg</td>
<td align="center">[1:0]</td>
<td>GRF写入值是ALUans还是DMans。0是ALUans，1是DMans，10是PC + 4</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">RegWrite</td>
<td align="center">1</td>
<td>是否写入GRF</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">MemWrite</td>
<td align="center">1</td>
<td>是否写入RAM</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">PcSel</td>
<td align="center">[3:0]</td>
<td>当前指令是否是beq\jal\jr</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">ExtOp</td>
<td align="center">[7:0]</td>
<td>扩展操作类型类型，详见Extender</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">AluOp</td>
<td align="center">[7:0]</td>
<td>ALU运算类型，详见ALU</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">InstrType</td>
<td align="center">[7:0]</td>
<td>指令类型</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">TNew_D</td>
<td align="center">[3:0]</td>
<td>从D级开始，经过多少周期该指令产生运算结果</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">TUse1_D,TUse2_D</td>
<td align="center">[3:0]</td>
<td>从D级开始，经过多少周期要用到运算结果</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Multiply_D</td>
<td align="center">1</td>
<td>是否进行乘法操作</td>
</tr>
<tr>
<td align="center">output</td>
<td align="center">Divide_D</td>
<td align="center">1</td>
<td>是否进行除法操作</td>
</tr>
</tbody></table>
<ul>
<li>内部电路采用最小项表达式判断法，先判断Op，再判断Func</li>
</ul>
<p>每种指令所需控制信号：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RegDst</th>
<th align="center">AluSrc</th>
<th align="center">MemToReg</th>
<th align="center">RegWrite</th>
<th align="center">MemWrite</th>
<th align="center">PcSel</th>
<th align="center">ExtOp</th>
<th align="center">AluOp</th>
<th>TNew</th>
<th>TUse1</th>
<th>TUse2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center"></td>
<td align="center">ADD</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center"></td>
<td align="center">SUB</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0000</td>
<td align="center">OR</td>
<td>2</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">00</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0010</td>
<td align="center">ADD</td>
<td>2</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">00</td>
<td align="center">01</td>
<td align="center">01</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">ADD</td>
<td>3</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">11</td>
<td align="center">01</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">ADD</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0001</td>
<td align="center">0011</td>
<td align="center">EQUAL</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">10</td>
<td align="center"></td>
<td align="center">10</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0010</td>
<td align="center">0100</td>
<td align="center"></td>
<td>0</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">11</td>
<td align="center">00</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0011</td>
<td align="center"></td>
<td align="center">ADD</td>
<td>0</td>
<td>0</td>
<td>10</td>
</tr>
</tbody></table>
<h1 id="6-流水线寄存器存储信息分析"><a href="#6-流水线寄存器存储信息分析" class="headerlink" title="6. 流水线寄存器存储信息分析"></a>6. 流水线寄存器存储信息分析</h1><h3 id="F级："><a href="#F级：" class="headerlink" title="F级："></a>F级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_F</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">Instruction_F</td>
<td align="center">[31:0]</td>
</tr>
</tbody></table>
<h3 id="D级："><a href="#D级：" class="headerlink" title="D级："></a>D级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">RD1_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">RD2_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_D</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">ExtAns_D</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_D</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_D</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">AluSrc_D</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">MemWrite_D</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">AluOp_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">InstrType_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_D</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">Addr1_D</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">Addr2_D</td>
<td align="center">[4:0]</td>
</tr>
</tbody></table>
<h3 id="E级："><a href="#E级：" class="headerlink" title="E级："></a>E级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_E</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">RD2_E</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_E</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_E</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">MemWrite_E</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_E</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_E</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">Addr2_E</td>
<td align="center">[4:0]</td>
</tr>
</tbody></table>
<h3 id="M级："><a href="#M级：" class="headerlink" title="M级："></a>M级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_M</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">DmAns_M</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_M</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">RegWrite_M</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_M</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_M</td>
<td align="center">[7:0]</td>
</tr>
</tbody></table>
<h3 id="W级："><a href="#W级：" class="headerlink" title="W级："></a>W级：</h3><table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">位宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Pc_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">AluAns_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">WR_W</td>
<td align="center">[4:0]</td>
</tr>
<tr>
<td align="center">DmAns_W</td>
<td align="center">[31:0]</td>
</tr>
<tr>
<td align="center">MemToReg_W</td>
<td align="center">[1:0]</td>
</tr>
<tr>
<td align="center">RegWrite_W</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">InstrType_W</td>
<td align="center">[7:0]</td>
</tr>
<tr>
<td align="center">TNew_W</td>
<td align="center">[7:0]</td>
</tr>
</tbody></table>
<h1 id="7-流水线转发数据"><a href="#7-流水线转发数据" class="headerlink" title="7. 流水线转发数据"></a>7. 流水线转发数据</h1><h3 id="E级：-1"><a href="#E级：-1" class="headerlink" title="E级："></a>E级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_E</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_E + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="M级：-1"><a href="#M级：-1" class="headerlink" title="M级："></a>M级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_M</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">AluAns_M</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_M + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="W级：-1"><a href="#W级：-1" class="headerlink" title="W级："></a>W级：</h3><table>
<thead>
<tr>
<th align="center">instruction</th>
<th align="center">Data_W</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">sub</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">ori</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">lui</td>
<td align="center">AluAns_W</td>
</tr>
<tr>
<td align="center">beq</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">jal</td>
<td align="center">Pc_W + 8</td>
</tr>
<tr>
<td align="center">jr</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">lw</td>
<td align="center">DmAns_W</td>
</tr>
<tr>
<td align="center">sw</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h1 id="8-测试方案"><a href="#8-测试方案" class="headerlink" title="8. 测试方案"></a>8. 测试方案</h1><p>针对每一条新添加的指令都进行测试，确保有符号、无符号的正确性，以及周期数的正确。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ori $t0 12</span><br><span class="line">ori $t1 21</span><br><span class="line">and $t2 $t0 $t1</span><br><span class="line">add $t3 $0 $t2</span><br><span class="line">ori $t0 16 </span><br><span class="line">ori $t1 25</span><br><span class="line">or $t2 $t0 $t1</span><br><span class="line">add $t3 $t2 $0</span><br><span class="line">addi $t0 $t0 -1</span><br><span class="line">addi $t0 $t0 -1</span><br><span class="line">addi $t0 $t0 -2</span><br><span class="line">andi $t2 $t0 121</span><br><span class="line">andi $t2 $t2 21</span><br><span class="line">slt $t3 $0 $t2</span><br><span class="line">addi $t1 $0 -1</span><br><span class="line">slt $t3 $t1 $0</span><br><span class="line">slt $t3 $0 $0</span><br><span class="line">addi $t2 $0 -2</span><br><span class="line">slt $t3 $t1 $t2</span><br><span class="line">slt $t3 $t2 $t1</span><br><span class="line">sltu $t3 $t1 $t2</span><br><span class="line">ori $t4 $0 1000</span><br><span class="line">slt $t3 $t1 $t4</span><br><span class="line">sltu $t3 $t1 $t4</span><br><span class="line">sltu $t3 $t3 $t1</span><br><span class="line">bne $0 $0 label</span><br><span class="line">addi $t0 $0 1</span><br><span class="line">addi $t0 $0 2</span><br><span class="line">addi $t0 $0 3</span><br><span class="line">bne $0 $t0 label</span><br><span class="line">addi $t0 $0 4</span><br><span class="line">addi $t0 $0 5</span><br><span class="line">addi $t0 $0 6</span><br><span class="line">label: </span><br><span class="line">addi $t0 $0 3</span><br><span class="line">addi $t1 $0 -2</span><br><span class="line">addi $t2 $0 2</span><br><span class="line">mult $t0 $t1</span><br><span class="line">multu $t0 $t1</span><br><span class="line">mult $t0 $t2</span><br><span class="line">div $t0 $t1</span><br><span class="line">divu $t0 $t1</span><br><span class="line">div $t0 $t2</span><br><span class="line">mfhi $t0</span><br><span class="line">addi $t0 $t0 1</span><br><span class="line">mflo $t0</span><br><span class="line">addi $t0 $t0 3</span><br><span class="line">mfhi $t0</span><br><span class="line">beq $t0 $0 label</span><br><span class="line">addi $t1 $0 3</span><br><span class="line">addi $t1 $0 7</span><br><span class="line">mthi $t1</span><br><span class="line">mfhi $t2</span><br><span class="line">mult $t1 $t2</span><br><span class="line">mtlo $t3</span><br><span class="line">mflo $t3</span><br><span class="line">and $t3 $t3 $t2</span><br><span class="line">addi $t0 $0 -3</span><br><span class="line">addi $t1 $0 1</span><br><span class="line">addi $t2 $0 2</span><br><span class="line">addi $t3 $0 3</span><br><span class="line">sb $t0 0($0)</span><br><span class="line">sb $t0 0($t1)</span><br><span class="line">sb $t0 0($t2)</span><br><span class="line">sb $t0 0($t3)</span><br><span class="line">sh $t0 4($0)</span><br><span class="line">sh $t0 8($t2)</span><br><span class="line">lb $t4 4($0)</span><br><span class="line">addi $t4 $t4 2</span><br><span class="line">lb $t4 4($t2)</span><br><span class="line">addi $t4 $t4 13</span><br><span class="line">lh $t4 4($0)</span><br><span class="line">addi $t4 $t4 52</span><br><span class="line">ori $t0 $0 5</span><br><span class="line">ori $t1 $0 34</span><br><span class="line">sub $t0 $0 $t0</span><br><span class="line">sub $t1 $0 $t1</span><br><span class="line">mult $t1 $t0</span><br><span class="line">mfhi $t2</span><br><span class="line">mflo $t3</span><br><span class="line"></span><br><span class="line">3508000c</span><br><span class="line">35290015</span><br><span class="line">01095024</span><br><span class="line">000a5820</span><br><span class="line">35080010</span><br><span class="line">35290019</span><br><span class="line">01095025</span><br><span class="line">01405820</span><br><span class="line">2108ffff</span><br><span class="line">2108ffff</span><br><span class="line">2108fffe</span><br><span class="line">310a0079</span><br><span class="line">314a0015</span><br><span class="line">000a582a</span><br><span class="line">2009ffff</span><br><span class="line">0120582a</span><br><span class="line">0000582a</span><br><span class="line">200afffe</span><br><span class="line">012a582a</span><br><span class="line">0149582a</span><br><span class="line">012a582b</span><br><span class="line">340c03e8</span><br><span class="line">012c582a</span><br><span class="line">012c582b</span><br><span class="line">0169582b</span><br><span class="line">14000007</span><br><span class="line">20080001</span><br><span class="line">20080002</span><br><span class="line">20080003</span><br><span class="line">14080003</span><br><span class="line">20080004</span><br><span class="line">20080005</span><br><span class="line">20080006</span><br><span class="line">20080003</span><br><span class="line">2009fffe</span><br><span class="line">200a0002</span><br><span class="line">01090018</span><br><span class="line">01090019</span><br><span class="line">010a0018</span><br><span class="line">0109001a</span><br><span class="line">0109001b</span><br><span class="line">010a001a</span><br><span class="line">00004010</span><br><span class="line">21080001</span><br><span class="line">00004012</span><br><span class="line">21080003</span><br><span class="line">00004010</span><br><span class="line">1100fff1</span><br><span class="line">20090003</span><br><span class="line">20090007</span><br><span class="line">01200011</span><br><span class="line">00005010</span><br><span class="line">012a0018</span><br><span class="line">01600013</span><br><span class="line">00005812</span><br><span class="line">016a5824</span><br><span class="line">2008fffd</span><br><span class="line">20090001</span><br><span class="line">200a0002</span><br><span class="line">200b0003</span><br><span class="line">a0080000</span><br><span class="line">a1280000</span><br><span class="line">a1480000</span><br><span class="line">a1680000</span><br><span class="line">a4080004</span><br><span class="line">a5480008</span><br><span class="line">800c0004</span><br><span class="line">218c0002</span><br><span class="line">814c0004</span><br><span class="line">218c000d</span><br><span class="line">840c0004</span><br><span class="line">218c0034</span><br><span class="line">34080005</span><br><span class="line">34090022</span><br><span class="line">00084022</span><br><span class="line">00094822</span><br><span class="line">01280018</span><br><span class="line">00005010</span><br><span class="line">00005812</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="9-思考题汇总"><a href="#9-思考题汇总" class="headerlink" title="9. 思考题汇总"></a>9. 思考题汇总</h1><ol>
<li>因为乘除法所需的时钟周期不同，分别是5和10，而一般的ALU操作的时钟周期都是1。如果将乘除功能整合进ALU，会阻塞其他指令的正常进行，使得总周期数变长，指令效率变低。而独立出来则可以与ALU分别计算，增加指令执行效率。需要额外增加HI、LO是因为乘除法的计算结果需要保留，直到reset或者被重新计算新的乘除结果。如果不加，那就会被其他的计算覆盖掉，导致mfhi、mflo指令来不及生效。</li>
<li>从80486时代开始，CPU有了专用的乘法器、移位器运算单元，这些单元可以高效处理乘除法。乘法器通常把乘法运算拆分成多个步骤，例如分解成部分积生成、部分积相加、最终结果输出等几个阶段。CPU也有专用的除法器用来实现除法操作。通常采用特定的算法（Radix-2算法）来实现。</li>
<li>可以把乘法、除法运算当作Moore型有限状态机来处理，start和busy信号是输出。当E级的start或busy信号置1同时D级是乘除法相关的指令时，需要阻塞。</li>
<li>好处有很多：sw、sh、sb三种store型指令都可以用这个byteen信号来调控写入的字节段，不用为了每种指令单独设计写入信号，起到了统一的作用。同时byteen的每一个1都对应了一个专属的字节，这样可以清晰的写入，不怕混淆。</li>
<li>并不是一字节，而是一字，即四字节。当每次只写入或读出一字节时，按字节读写的效率会高于按字读写。</li>
<li>我对指令采取了归类的方式，先将具体的小指令提取共性归为同一类型的指令，再根据该类型的指令的特点来驱动输出信号。例如mult和multu指令分为乘法类，用来驱动Multiply_D信号，div和divu指令分为除法类等。这种手段在译码的时候能够降低指令的复杂度，减少操作次数，更清楚的分类分层。同时在阻塞和转发的时候也根据每一级的指令类型来决定转发的数据，这有助于在处理数据冲突时降低复杂度，封装结果。</li>
<li>有很多冲突，例如lb和bne的冒险，结构冒险，控制冒险等。解决方法就是AT法判断阻塞+无脑转发。相关测试样例在测试方案中包含了。</li>
<li>我是手动构造的样例。首先测试指令的基本功能，如果该指令是有符号数，那么还要测试负数的情况。之后再考虑转发和阻塞，如果该指令很早就要用到操作数（例如bne），那么就在让上一条指令写入该指令需要用的寄存器，测试阻塞功能。同时也要测试该条指令能否正常转发，因此如果该指令写入某一寄存器，那么下一条指令就要对该寄存器进行操作，验证是否转发成功。</li>
</ol>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>北航操作系统-OS-shell-挑战性任务</title>
    <url>/2025/06/29/%E5%8C%97%E8%88%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-shell-%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>我实现挑战性任务的顺序并不是按照题目顺序，而是根据我认为的合理顺序来实现的，实验报告也将按照我实现指令的顺序来书写。</p>
</blockquote>
<h3 id="重写-sh-c-架构"><a href="#重写-sh-c-架构" class="headerlink" title="重写 sh.c 架构"></a>重写 sh.c 架构</h3><p>指导书中提出， Shell是一种命令解释器，对输入指令进行解析并执行。现有MOS实现的Shell较为简陋，如果在其基础上尝试实现挑战性任务内容可能复杂度较高，可以参考sh,bash等工业界shell实现原理进行重新实现，以下是一个可行的实现方案:</p>
<p><img src="/pictures/image-5.png" alt="alt text"></p>
<p>因此，我第一步先按照上述架构把 sh.c 重写了一遍，抛弃了原有课程组的代码，按照AST语法树来解析输入。代码如下（最后的完整版代码）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;args.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_INPUT_BUF 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TOKEN_LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMD_ARGS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VAR_NAME_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VAR_VALUE_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SHELL_VARS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EXPANDED_STR_LEN (MAX_TOKEN_LEN * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UP <span class="string">&#x27;A&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOWN <span class="string">&#x27;B&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OTHER -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HISTFILESIZE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HISTORY_FILE <span class="string">&quot;/.mos_history&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITESPACE <span class="string">&quot; \t\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMD_SUBST_OUTPUT_LEN (MAX_INPUT_BUF * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMD_SUBST_BUFFERS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> cmd_subst_output_pool[MAX_CMD_SUBST_BUFFERS][MAX_CMD_SUBST_OUTPUT_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cmd_subst_output_pool_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">execute_command_substitution</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* command_to_run, <span class="type">int</span> parent_is_interactive)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> history_lines[HISTFILESIZE][MAX_INPUT_BUF];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> history_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> history_add_idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> history_latest_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> current_typed_line[MAX_INPUT_BUF] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> expansion_buffer_pool[<span class="number">100</span>][MAX_EXPANDED_STR_LEN];</span><br><span class="line"><span class="type">int</span> expansion_buffer_pool_index = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">expand_string_variables</span><span class="params">(<span class="type">char</span> *input_str)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymemmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_history</span><span class="params">(<span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_history</span><span class="params">(<span class="type">char</span> ope[][<span class="number">600</span>],<span class="type">int</span> *sz)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> value[MAX_VAR_VALUE_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> is_exported;</span><br><span class="line">    <span class="type">int</span> is_readonly;</span><br><span class="line">    <span class="type">int</span> is_set;</span><br><span class="line">&#125; ShellVar;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> ShellVar shell_vars[MAX_SHELL_VARS];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_set_vars = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_shell_vars</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ShellVar* <span class="title function_">find_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">set_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> export_flag, <span class="type">int</span> readonly_flag, <span class="type">int</span> update_flags_if_exists)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unset_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_all_variables</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_variable_value</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> <span class="title">ASTNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NODE_ILLEGAL = <span class="number">0</span>,</span><br><span class="line">    NODE_COMMAND,</span><br><span class="line">    NODE_PIPELINE,</span><br><span class="line">    NODE_LIST_SEMI,</span><br><span class="line">    NODE_LIST_AMP,</span><br><span class="line">    NODE_AND,</span><br><span class="line">    NODE_OR,</span><br><span class="line">&#125; ASTNodeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TOKEN_ERROR = <span class="number">0</span>,</span><br><span class="line">    TOKEN_EOF = <span class="number">1</span>,</span><br><span class="line">    TOKEN_EOL = <span class="number">2</span>,</span><br><span class="line">    TOKEN_WORD,</span><br><span class="line">    TOKEN_PIPE,</span><br><span class="line">    TOKEN_SEMI,</span><br><span class="line">    TOKEN_AMP,</span><br><span class="line">    TOKEN_AND,</span><br><span class="line">    TOKEN_OR,</span><br><span class="line">    TOKEN_REDIR_IN,</span><br><span class="line">    TOKEN_REDIR_OUT,</span><br><span class="line">    TOKEN_REDIR_APP,</span><br><span class="line">&#125; TokenType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TokenType type;</span><br><span class="line">    <span class="type">char</span> value[MAX_TOKEN_LEN];</span><br><span class="line">&#125; Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    REDIR_TYPE_IN,</span><br><span class="line">    REDIR_TYPE_OUT,</span><br><span class="line">    REDIR_TYPE_APP,</span><br><span class="line">&#125; RedirType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RedirNode</span> &#123;</span></span><br><span class="line">    RedirType type;</span><br><span class="line">    <span class="type">char</span> *filename;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RedirNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RedirNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *argv[MAX_CMD_ARGS];</span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    RedirNode *redirects;</span><br><span class="line">&#125; CMDNodeData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ASTNode *left;</span><br><span class="line">    ASTNode *right;</span><br><span class="line">&#125; BinaryOpNodeData;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> &#123;</span></span><br><span class="line">    ASTNodeType type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        CMDNodeData command;</span><br><span class="line">        BinaryOpNodeData binary_op;</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_list</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n, <span class="type">int</span> interactive)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_ast_resources</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> strdup_pool[<span class="number">100</span>][<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> strdup_pool_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ASTNode astnode_pool[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> astnode_pool_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RedirNode redirnode_pool[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> redirnode_pool_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_subst_output_buffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cmd_subst_output_pool_idx &gt;= MAX_CMD_SUBST_BUFFERS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sh: too many command substitutions on one line\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (MAX_CMD_SUBST_BUFFERS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cmd_subst_output_pool[MAX_CMD_SUBST_BUFFERS <span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        user_panic(<span class="string">&quot;cmd_subst_output_pool out of space and no fallback buffer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cmd_subst_output_pool[cmd_subst_output_pool_idx], <span class="number">0</span>, MAX_CMD_SUBST_OUTPUT_LEN);</span><br><span class="line">    <span class="keyword">return</span> cmd_subst_output_pool[cmd_subst_output_pool_idx++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">execute_command_substitution</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* command_to_run, <span class="type">int</span> parent_is_interactive)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> child_pid_for_sh_c;</span><br><span class="line">    <span class="type">char</span> *output_buffer = get_subst_output_buffer();</span><br><span class="line">    output_buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    u_int output_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> read_char;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_fds) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sh: pipe failed for command substitution\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> output_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    child_pid_for_sh_c = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid_for_sh_c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sh: fork failed for command substitution\n&quot;</span>);</span><br><span class="line">        close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> output_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid_for_sh_c == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (dup(pipe_fds[<span class="number">1</span>], <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;sh: dup stdout to pipe failed in cmd_subst child\n&quot;</span>);</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">char</span> temp_cmd_buffer_for_argv[MAX_INPUT_BUF];</span><br><span class="line">        mystrcpy(temp_cmd_buffer_for_argv, command_to_run);</span><br><span class="line">        <span class="type">char</span> *sh_argv[] = &#123;<span class="string">&quot;sh.b&quot;</span>, <span class="string">&quot;-c&quot;</span>, temp_cmd_buffer_for_argv, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        spawn(<span class="string">&quot;/sh.b&quot;</span>, sh_argv);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> ((r = read(pipe_fds[<span class="number">0</span>], &amp;read_char, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output_len &lt; MAX_CMD_SUBST_OUTPUT_LEN - <span class="number">1</span>) &#123;</span><br><span class="line">                output_buffer[output_len++] = read_char;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                debugf(<span class="string">&quot;sh: command substitution output too long, truncated.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(read(pipe_fds[<span class="number">0</span>], &amp;read_char, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh: error reading from pipe in command substitution\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[output_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">        wait(child_pid_for_sh_c, <span class="literal">NULL</span>); <span class="comment">// Modified to match new wait signature if necessary</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (output_len &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">               (output_buffer[output_len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span> || output_buffer[output_len - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)) &#123;</span><br><span class="line">            output_buffer[--output_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; output_len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output_buffer[i] == <span class="string">&#x27;\n&#x27;</span> || output_buffer[i] == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">                output_buffer[i] = <span class="string">&#x27; &#x27;</span>; <span class="comment">// Changed from &#x27;\0&#x27; to &#x27; &#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get_subst_output_buffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset_allocators</span><span class="params">()</span> &#123;</span><br><span class="line">    strdup_pool_index = <span class="number">0</span>;</span><br><span class="line">    astnode_pool_index = <span class="number">0</span>;</span><br><span class="line">    redirnode_pool_index = <span class="number">0</span>;</span><br><span class="line">    expansion_buffer_pool_index = <span class="number">0</span>;</span><br><span class="line">    cmd_subst_output_pool_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">user_strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(s) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;strdup: string too long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strdup_pool_index &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;strdup_pool out of space&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *new_s = strdup_pool[strdup_pool_index++];</span><br><span class="line">    <span class="built_in">memcpy</span>(new_s, s, len);</span><br><span class="line">    <span class="keyword">return</span> new_s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">alloc_ast_node</span><span class="params">(ASTNodeType type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (astnode_pool_index &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;astnode_pool out of space&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ASTNode *node = &amp;astnode_pool[astnode_pool_index++];</span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(ASTNode));</span><br><span class="line">    node-&gt;type = type;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedirNode *<span class="title function_">alloc_redir_node</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (redirnode_pool_index &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;redirnode_pool out of space&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RedirNode *node = &amp;redirnode_pool[redirnode_pool_index++];</span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(RedirNode));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *current_pos;</span><br><span class="line"><span class="type">static</span> Token current_token;</span><br><span class="line"><span class="type">static</span> Token peeked_token;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> has_peeked_token;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skip_whitespace_and_comments</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*current_pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(<span class="string">&quot; \t\r\n&quot;</span>, *current_pos)) &#123;</span><br><span class="line">            current_pos++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (*current_pos &amp;&amp; *current_pos != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                current_pos++;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                 current_pos++;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Token <span class="title function_">get_next_raw_token</span><span class="params">()</span> &#123;</span><br><span class="line">    Token token;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;token, <span class="number">0</span>, <span class="keyword">sizeof</span>(Token));</span><br><span class="line">    token.type = TOKEN_ERROR;</span><br><span class="line"></span><br><span class="line">    skip_whitespace_and_comments();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_EOF;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mystrncmp(current_pos, <span class="string">&quot;&amp;&amp;&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        token.type = TOKEN_AND;</span><br><span class="line">        mystrncpy(token.value, <span class="string">&quot;&amp;&amp;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        token.value[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrncmp(current_pos, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        token.type = TOKEN_OR;</span><br><span class="line">        mystrncpy(token.value, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        token.value[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrncmp(current_pos, <span class="string">&quot;&gt;&gt;&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        token.type = TOKEN_REDIR_APP;</span><br><span class="line">        mystrncpy(token.value, <span class="string">&quot;&gt;&gt;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        token.value[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_PIPE;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;|&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;;&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_SEMI;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;;&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_AMP;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;&amp;&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_REDIR_IN;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;&lt;&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;&gt;&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_REDIR_OUT;</span><br><span class="line">        token.value[<span class="number">0</span>] = <span class="string">&#x27;&gt;&#x27;</span>; token.value[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        current_pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;`&#x27;</span>) &#123;</span><br><span class="line">        token.type = TOKEN_WORD;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        token.value[i++] = *current_pos++;</span><br><span class="line">        <span class="keyword">while</span> (*current_pos &amp;&amp; i &lt; MAX_TOKEN_LEN - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;`&#x27;</span>) &#123;</span><br><span class="line">                token.value[i++] = *current_pos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            token.value[i++] = *current_pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        token.value[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; token.value[i<span class="number">-1</span>] != <span class="string">&#x27;`&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh: unclosed backtick\n&quot;</span>);</span><br><span class="line">            token.type = TOKEN_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (i==<span class="number">1</span> &amp;&amp; token.value[<span class="number">0</span>] == <span class="string">&#x27;`&#x27;</span> &amp;&amp; *current_pos == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                token.type = TOKEN_ERROR;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        token.type = TOKEN_WORD;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (*current_pos &amp;&amp;</span><br><span class="line">               !<span class="built_in">strchr</span>(<span class="string">&quot; \t\r\n&quot;</span>, *current_pos) &amp;&amp;</span><br><span class="line">               !<span class="built_in">strchr</span>(<span class="string">&quot;|;&amp;&lt;&gt;`#&quot;</span>, *current_pos) &amp;&amp;</span><br><span class="line">               i &lt; MAX_TOKEN_LEN - <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (mystrncmp(current_pos, <span class="string">&quot;&amp;&amp;&quot;</span>, <span class="number">2</span>) == <span class="number">0</span> ||</span><br><span class="line">                mystrncmp(current_pos, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>) == <span class="number">0</span> ||</span><br><span class="line">                mystrncmp(current_pos, <span class="string">&quot;&gt;&gt;&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            token.value[i++] = *current_pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        token.value[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (*current_pos == <span class="string">&#x27;\0&#x27;</span>) token.type = TOKEN_EOF;</span><br><span class="line">             <span class="keyword">else</span> token.type = TOKEN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tokenizer_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *input)</span> &#123;</span><br><span class="line">    current_pos = input;</span><br><span class="line">    has_peeked_token = <span class="number">0</span>;</span><br><span class="line">    current_token = get_next_raw_token();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Token <span class="title function_">consume_token</span><span class="params">()</span> &#123;</span><br><span class="line">    Token old_current = current_token;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type == TOKEN_EOF) <span class="keyword">return</span> old_current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_peeked_token) &#123;</span><br><span class="line">        current_token = peeked_token;</span><br><span class="line">        has_peeked_token = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current_token = get_next_raw_token();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old_current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Token <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type == TOKEN_EOF) <span class="keyword">return</span> current_token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!has_peeked_token) &#123;</span><br><span class="line">        peeked_token = get_next_raw_token();</span><br><span class="line">        has_peeked_token = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> peeked_token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_and_or</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ASTNode *<span class="title function_">parse_pipeline</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ASTNode *<span class="title function_">parse_command</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_line</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parse_list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_list</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_and_or();</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_SEMI || current_token.type == TOKEN_AMP) &#123;</span><br><span class="line">        TokenType op_type = current_token.type;</span><br><span class="line">        consume_token();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) &#123;</span><br><span class="line">            ASTNode *new_list_node = alloc_ast_node(op_type == TOKEN_SEMI ? NODE_LIST_SEMI : NODE_LIST_AMP);</span><br><span class="line">            new_list_node-&gt;data.binary_op.left = node;</span><br><span class="line">            new_list_node-&gt;data.binary_op.right = <span class="literal">NULL</span>;</span><br><span class="line">            node = new_list_node;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ASTNode *right_node = parse_and_or();</span><br><span class="line">        <span class="keyword">if</span> (!right_node &amp;&amp; (op_type == TOKEN_SEMI || (op_type == TOKEN_AMP &amp;&amp; current_token.type != TOKEN_EOF &amp;&amp; current_token.type != TOKEN_EOL ) ) ) &#123;</span><br><span class="line">             debugf(<span class="string">&quot;Syntax error after &#x27;%s&#x27;\n&quot;</span>, op_type == TOKEN_SEMI ? <span class="string">&quot;;&quot;</span> : <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ASTNode *new_list_node = alloc_ast_node(op_type == TOKEN_SEMI ? NODE_LIST_SEMI : NODE_LIST_AMP);</span><br><span class="line">        new_list_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_list_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_list_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_and_or</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_pipeline();</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_AND || current_token.type == TOKEN_OR) &#123;</span><br><span class="line">        TokenType op_type = current_token.type;</span><br><span class="line">        consume_token();</span><br><span class="line">        ASTNode *right_node = parse_pipeline();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error: &#x27;%s&#x27; not followed by pipeline\n&quot;</span>, op_type == TOKEN_AND ? <span class="string">&quot;&amp;&amp;&quot;</span> : <span class="string">&quot;||&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_op_node = alloc_ast_node(op_type == TOKEN_AND ? NODE_AND : NODE_OR);</span><br><span class="line">        new_op_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_op_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_op_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_pipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_command();</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_PIPE) &#123;</span><br><span class="line">        consume_token();</span><br><span class="line">        ASTNode *right_node = parse_command();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error: &#x27;|&#x27; not followed by command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_pipe_node = alloc_ast_node(NODE_PIPELINE);</span><br><span class="line">        new_pipe_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_pipe_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_pipe_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASTNode *<span class="title function_">parse_command</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type != TOKEN_WORD &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_IN &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_OUT &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_APP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASTNode *cmd_node_ast = alloc_ast_node(NODE_COMMAND);</span><br><span class="line">    CMDNodeData *cmd_data = &amp;cmd_node_ast-&gt;data.command;</span><br><span class="line">    RedirNode **next_redir_ptr = &amp;cmd_data-&gt;redirects;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent_shell_is_interactive = iscons(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_WORD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmd_data-&gt;argc &lt; MAX_CMD_ARGS - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> *arg_after_var_expansion = expand_string_variables(current_token.value);</span><br><span class="line">                <span class="type">char</span> *final_arg_for_argv = arg_after_var_expansion;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> rebuilt_arg_buffer[MAX_EXPANDED_STR_LEN * <span class="number">2</span>];</span><br><span class="line">                rebuilt_arg_buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="type">char</span> *current_rebuilt_ptr = rebuilt_arg_buffer;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *scan_ptr = arg_after_var_expansion;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (*scan_ptr) &#123;</span><br><span class="line">                    <span class="type">char</span> *backtick_start = <span class="built_in">strchr</span>(scan_ptr, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (backtick_start) &#123;</span><br><span class="line">                        <span class="type">char</span> *backtick_end = <span class="built_in">strchr</span>(backtick_start + <span class="number">1</span>, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (backtick_end) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (backtick_start &gt; scan_ptr) &#123;</span><br><span class="line">                                mystrncpy(current_rebuilt_ptr, scan_ptr, backtick_start - scan_ptr);</span><br><span class="line">                                current_rebuilt_ptr += (backtick_start - scan_ptr);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="type">char</span> cmd_to_subst[MAX_INPUT_BUF];</span><br><span class="line">                            <span class="type">int</span> cmd_len = backtick_end - (backtick_start + <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span> (cmd_len &gt;= MAX_INPUT_BUF) cmd_len = MAX_INPUT_BUF <span class="number">-1</span>;</span><br><span class="line">                            mystrncpy(cmd_to_subst, backtick_start + <span class="number">1</span>, cmd_len);</span><br><span class="line">                            cmd_to_subst[cmd_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                            <span class="type">char</span> *subst_output = execute_command_substitution(cmd_to_subst, parent_shell_is_interactive);</span><br><span class="line">                            <span class="keyword">if</span> (subst_output) &#123;</span><br><span class="line">                                mystrcat(current_rebuilt_ptr, subst_output);</span><br><span class="line">                                current_rebuilt_ptr += mystrlen(subst_output);</span><br><span class="line">                            &#125;</span><br><span class="line">                            scan_ptr = backtick_end + <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mystrcat(current_rebuilt_ptr, scan_ptr);</span><br><span class="line">                            current_rebuilt_ptr += mystrlen(scan_ptr);</span><br><span class="line">                            scan_ptr += mystrlen(scan_ptr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mystrcat(current_rebuilt_ptr, scan_ptr);</span><br><span class="line">                        current_rebuilt_ptr += mystrlen(scan_ptr);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                *current_rebuilt_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rebuilt_arg_buffer[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span> || arg_after_var_expansion[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                    final_arg_for_argv = user_strdup(rebuilt_arg_buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    final_arg_for_argv = user_strdup(arg_after_var_expansion);</span><br><span class="line">                &#125;</span><br><span class="line">                cmd_data-&gt;argv[cmd_data-&gt;argc++] = final_arg_for_argv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">            consume_token();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_token.type == TOKEN_REDIR_IN ||</span><br><span class="line">                   current_token.type == TOKEN_REDIR_OUT ||</span><br><span class="line">                   current_token.type == TOKEN_REDIR_APP) &#123;</span><br><span class="line">            TokenType redir_op_type = current_token.type;</span><br><span class="line">            consume_token();</span><br><span class="line">            <span class="keyword">if</span> (current_token.type != TOKEN_WORD) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;Syntax error: Redirection operator not followed by filename\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RedirNode *redir_node = alloc_redir_node();</span><br><span class="line">            <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_IN) redir_node-&gt;type = REDIR_TYPE_IN;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_OUT) redir_node-&gt;type = REDIR_TYPE_OUT;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_APP) redir_node-&gt;type = REDIR_TYPE_APP;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> *filename_after_vars = expand_string_variables(current_token.value);</span><br><span class="line">            <span class="type">char</span> *final_filename = filename_after_vars;</span><br><span class="line">            <span class="comment">// Apply command substitution to filenames as well</span></span><br><span class="line">            <span class="type">char</span> rebuilt_fname_buffer[MAX_EXPANDED_STR_LEN * <span class="number">2</span>];</span><br><span class="line">            rebuilt_fname_buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="type">char</span> *current_rebuilt_fname_ptr = rebuilt_fname_buffer;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *scan_fname_ptr = filename_after_vars;</span><br><span class="line">            <span class="keyword">while</span>(*scan_fname_ptr)&#123;</span><br><span class="line">                <span class="type">char</span> *bt_start = <span class="built_in">strchr</span>(scan_fname_ptr, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(bt_start)&#123;</span><br><span class="line">                    <span class="type">char</span> *bt_end = <span class="built_in">strchr</span>(bt_start + <span class="number">1</span>, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(bt_end)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(bt_start &gt; scan_fname_ptr)&#123;</span><br><span class="line">                            mystrncpy(current_rebuilt_fname_ptr, scan_fname_ptr, bt_start - scan_fname_ptr);</span><br><span class="line">                            current_rebuilt_fname_ptr += (bt_start - scan_fname_ptr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">char</span> cmd_to_subst_fname[MAX_INPUT_BUF];</span><br><span class="line">                        <span class="type">int</span> cmd_len_fname = bt_end - (bt_start + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(cmd_len_fname &gt;= MAX_INPUT_BUF) cmd_len_fname = MAX_INPUT_BUF <span class="number">-1</span>;</span><br><span class="line">                        mystrncpy(cmd_to_subst_fname, bt_start + <span class="number">1</span>, cmd_len_fname);</span><br><span class="line">                        cmd_to_subst_fname[cmd_len_fname] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                        <span class="type">char</span> *subst_out_fname = execute_command_substitution(cmd_to_subst_fname, parent_shell_is_interactive);</span><br><span class="line">                        <span class="keyword">if</span>(subst_out_fname)&#123;</span><br><span class="line">                            mystrcat(current_rebuilt_fname_ptr, subst_out_fname);</span><br><span class="line">                            current_rebuilt_fname_ptr += mystrlen(subst_out_fname);</span><br><span class="line">                        &#125;</span><br><span class="line">                        scan_fname_ptr = bt_end + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mystrcat(current_rebuilt_fname_ptr, scan_fname_ptr);</span><br><span class="line">                        current_rebuilt_fname_ptr += mystrlen(scan_fname_ptr);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mystrcat(current_rebuilt_fname_ptr, scan_fname_ptr);</span><br><span class="line">                    current_rebuilt_fname_ptr += mystrlen(scan_fname_ptr);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            *current_rebuilt_fname_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(rebuilt_fname_buffer[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span> || filename_after_vars[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">                final_filename = user_strdup(rebuilt_fname_buffer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                final_filename = user_strdup(filename_after_vars);</span><br><span class="line">            &#125;</span><br><span class="line">            redir_node-&gt;filename = final_filename;</span><br><span class="line">            consume_token();</span><br><span class="line">            *next_redir_ptr = redir_node;</span><br><span class="line">            next_redir_ptr = &amp;redir_node-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cmd_data-&gt;argv[cmd_data-&gt;argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmd_data-&gt;argc == <span class="number">0</span> &amp;&amp; cmd_data-&gt;redirects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cmd_node_ast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset_expansion_buffer_pool</span><span class="params">()</span> &#123;</span><br><span class="line">    expansion_buffer_pool_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_expansion_buffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (expansion_buffer_pool_index &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;expansion_buffer_pool out of space&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(expansion_buffer_pool[expansion_buffer_pool_index], <span class="number">0</span>, MAX_EXPANDED_STR_LEN);</span><br><span class="line">    <span class="keyword">return</span> expansion_buffer_pool[expansion_buffer_pool_index++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">expand_string_variables</span><span class="params">( <span class="type">char</span> *input_str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!input_str || !<span class="built_in">strchr</span>(input_str, <span class="string">&#x27;$&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> user_strdup(input_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *output_buf = get_expansion_buffer();</span><br><span class="line">    output_buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *out_ptr = output_buf;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *in_ptr = input_str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*in_ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*in_ptr == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">            in_ptr++;</span><br><span class="line">            <span class="type">char</span> var_name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (*in_ptr &amp;&amp;</span><br><span class="line">                   i &lt; MAX_VAR_NAME_LEN &amp;&amp;</span><br><span class="line">                   !<span class="built_in">strchr</span>(<span class="string">&quot; \t\r\n$|;&amp;&lt;&gt;/`&quot;</span>, *in_ptr) <span class="comment">// Added ` to terminators</span></span><br><span class="line">                   ) &#123;</span><br><span class="line">                var_name[i++] = *in_ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            var_name[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *var_value = get_variable_value(var_name);</span><br><span class="line">                <span class="keyword">if</span> (var_value) &#123;</span><br><span class="line">                    <span class="type">size_t</span> val_len = mystrlen(var_value);</span><br><span class="line">                    <span class="keyword">if</span> ((out_ptr - output_buf) + val_len &lt; MAX_EXPANDED_STR_LEN) &#123;</span><br><span class="line">                        mystrcpy(out_ptr, var_value);</span><br><span class="line">                        out_ptr += val_len;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* Buffer overflow */</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((out_ptr - output_buf) &lt; MAX_EXPANDED_STR_LEN <span class="number">-1</span>) &#123;</span><br><span class="line">                    *out_ptr++ = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((out_ptr - output_buf) &lt; MAX_EXPANDED_STR_LEN - <span class="number">1</span>) &#123;</span><br><span class="line">                *out_ptr++ = *in_ptr++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                in_ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *out_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> output_buf; <span class="comment">// Returns from expansion_buffer_pool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_inner_cmd</span><span class="params">(CMDNodeData *cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;pwd&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;declare&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;unset&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">	    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_inner_cmd</span><span class="params">(CMDNodeData *cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;pwd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pwd: expected 0 arguments; got %d\n&quot;</span>, cmd-&gt;argc - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			syscall_get_cwd(buf);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">char</span> finalpath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span> (cmd-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">			mystrcpy(finalpath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            syscall_set_cwd(finalpath); <span class="comment">// cd to root if no argument</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">char</span> cwd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			syscall_get_cwd(cwd);</span><br><span class="line">			<span class="type">int</span> r;</span><br><span class="line">			<span class="keyword">if</span> ((r = get_final_path(cwd, cmd-&gt;argv[<span class="number">1</span>], finalpath)) == <span class="number">0</span>) &#123;</span><br><span class="line">				syscall_set_cwd(finalpath);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: The directory &#x27;%s&#x27; does not exist\n&quot;</span>, cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: &#x27;%s&#x27; is not a directory\n&quot;</span>, cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: error processing path (null args)\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-2</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: path too long\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-3</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: failed to normalize path\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;cd: too many arguments\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Default exit with 0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;declare&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> export_f = <span class="number">0</span>;</span><br><span class="line">       		<span class="type">int</span> readonly_f = <span class="number">0</span>;</span><br><span class="line">        	<span class="type">int</span> arg_idx = <span class="number">1</span>;</span><br><span class="line">        	<span class="type">char</span> *name_val_pair = <span class="literal">NULL</span>;</span><br><span class="line">        	<span class="keyword">while</span> (cmd-&gt;argv[arg_idx] &amp;&amp; cmd-&gt;argv[arg_idx][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            		<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-x&quot;</span>) == <span class="number">0</span>) export_f = <span class="number">1</span>;</span><br><span class="line">            		<span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-r&quot;</span>) == <span class="number">0</span>) readonly_f = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-xr&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">				 mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-rx&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				export_f = <span class="number">1</span>; readonly_f = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="built_in">printf</span>(<span class="string">&quot;declare: invalid option %s\n&quot;</span>, cmd-&gt;argv[arg_idx]);</span><br><span class="line">                		<span class="keyword">return</span>;</span><br><span class="line">            		&#125;</span><br><span class="line">            		arg_idx++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (cmd-&gt;argv[arg_idx]) &#123;</span><br><span class="line">            		name_val_pair = cmd-&gt;argv[arg_idx];</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (!name_val_pair) &#123;</span><br><span class="line">            		print_all_variables();</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            		<span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            		<span class="type">char</span> value_buf[MAX_VAR_VALUE_LEN + <span class="number">1</span>];</span><br><span class="line">            		<span class="type">char</span> *value_ptr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            		<span class="type">char</span> *eq_ptr = <span class="built_in">strchr</span>(name_val_pair, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            		<span class="keyword">if</span> (eq_ptr) &#123;</span><br><span class="line">                		<span class="type">int</span> name_len = eq_ptr - name_val_pair;</span><br><span class="line">                		<span class="keyword">if</span> (name_len &gt; MAX_VAR_NAME_LEN) &#123;<span class="built_in">printf</span>(<span class="string">&quot;sh: var name too long\n&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrncpy(name, name_val_pair, name_len);</span><br><span class="line">                		name[name_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                		value_ptr = eq_ptr + <span class="number">1</span>;</span><br><span class="line">                		<span class="keyword">if</span> (mystrlen(value_ptr) &gt; MAX_VAR_VALUE_LEN) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sh: var value too long\n&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrcpy(value_buf, value_ptr);</span><br><span class="line">                		value_ptr = value_buf;</span><br><span class="line">            		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="keyword">if</span> (mystrlen(name_val_pair) &gt; MAX_VAR_NAME_LEN) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sh: var name too long\n&quot;</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrcpy(name, name_val_pair);</span><br><span class="line">            		&#125;</span><br><span class="line">            		set_variable(name, value_ptr, export_f, readonly_f, <span class="number">1</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;unset&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (cmd-&gt;argc != <span class="number">2</span>) &#123;</span><br><span class="line">            		<span class="built_in">printf</span>(<span class="string">&quot;unset: usage: unset NAME\n&quot;</span>);</span><br><span class="line">            		<span class="keyword">return</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	unset_variable(cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">&quot;history: too many arguments\n&quot;</span>);</span><br><span class="line">        		<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="type">int</span> start_idx;</span><br><span class="line">    		<span class="keyword">if</span> (history_count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    		<span class="keyword">if</span> (history_count &lt; HISTFILESIZE) start_idx = <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">else</span> start_idx = history_add_idx;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; history_count; ++i) &#123;</span><br><span class="line">        		<span class="type">int</span> current_entry_idx = (start_idx + i) % HISTFILESIZE;</span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, history_lines[current_entry_idx]);</span><br><span class="line">    		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_final_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cwd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *finalpath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cwd || !path || !finalpath) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> constructed_path[MAXPATHLEN * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mystrlen(path) &gt;= MAXPATHLEN) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        mystrcpy(constructed_path, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mystrlen(cwd) + <span class="number">1</span> + mystrlen(path) + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(constructed_path)) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        mystrcpy(constructed_path, cwd);</span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span> &amp;&amp; constructed_path[mystrlen(constructed_path) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            mystrcat(constructed_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mystrcat(constructed_path, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (normalize_path(constructed_path) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// Only stat if original path was relative for cd behavior</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">        <span class="type">int</span> r_stat = stat(constructed_path, &amp;st);</span><br><span class="line">        <span class="keyword">if</span> (r_stat &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (st.st_isdir == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mystrcpy(finalpath, constructed_path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">normalize_path</span><span class="params">(<span class="type">char</span> *path_buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path_buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> components[MAX_CMD_ARGS][MAXNAMELEN];</span><br><span class="line">    <span class="type">int</span> comp_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = path_buf;</span><br><span class="line">    <span class="type">int</span> is_absolute = (*p == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        p++; <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="type">char</span> current_comp_val[MAXNAMELEN];</span><br><span class="line">        <span class="type">char</span> *c_ptr = current_comp_val;</span><br><span class="line">        <span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c_ptr - current_comp_val &lt; MAXNAMELEN - <span class="number">1</span>) *c_ptr++ = *p;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        *c_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &gt; <span class="number">0</span> &amp;&amp; mystrcmp(components[comp_idx - <span class="number">1</span>], <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) comp_idx--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute) &#123;</span><br><span class="line">                <span class="keyword">if</span> (comp_idx &lt; MAX_CMD_ARGS) mystrncpy(components[comp_idx++], <span class="string">&quot;..&quot;</span>, MAXNAMELEN<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; current_comp_val[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &lt; MAX_CMD_ARGS) mystrncpy(components[comp_idx++], current_comp_val, MAXNAMELEN<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *write_ptr = path_buf;</span><br><span class="line">    <span class="keyword">if</span> (is_absolute) *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; comp_idx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> || (is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i==<span class="number">0</span> &amp;&amp; write_ptr &gt; path_buf &amp;&amp; *(write_ptr<span class="number">-1</span>) != <span class="string">&#x27;/&#x27;</span>)) &#123; <span class="comment">// ensure slash for non-first components or if root isn&#x27;t only thing</span></span><br><span class="line">             <span class="keyword">if</span>(write_ptr == path_buf &amp;&amp; is_absolute &amp;&amp; *path_buf == <span class="string">&#x27;/&#x27;</span>)&#123;<span class="comment">/* no extra slash if only / */</span>&#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (write_ptr &gt; path_buf &amp;&amp; *(write_ptr<span class="number">-1</span>) != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (write_ptr - path_buf &gt;= MAXPATHLEN <span class="number">-1</span>) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">                *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (write_ptr == path_buf &amp;&amp; !is_absolute &amp;&amp; i &gt; <span class="number">0</span>) &#123; <span class="comment">// relative path, non-first component</span></span><br><span class="line">                <span class="keyword">if</span> (write_ptr - path_buf &gt;= MAXPATHLEN <span class="number">-1</span>) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">                 *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = mystrlen(components[i]);</span><br><span class="line">        <span class="keyword">if</span> ((write_ptr - path_buf) + len &gt;= MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        <span class="built_in">memcpy</span>(write_ptr, components[i], len);</span><br><span class="line">        write_ptr += len;</span><br><span class="line">    &#125;</span><br><span class="line">    *write_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (path_buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_absolute) mystrcpy(path_buf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> mystrcpy(path_buf, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; write_ptr == path_buf + <span class="number">1</span> &amp;&amp; path_buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; comp_idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Path was like &quot;//&quot; or &quot;/./&quot; or &quot;/foo/..&quot;, normalized to just &quot;/&quot;</span></span><br><span class="line">        <span class="comment">// Ensure it&#x27;s exactly &quot;/&quot; and not &quot;/\0&quot; if write_ptr is path_buf+1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; path_buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path_buf[<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path_buf[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123; <span class="comment">// Fix &quot;///&quot; to &quot;/&quot;</span></span><br><span class="line">	path_buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_ast</span><span class="params">(ASTNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> child_pid;</span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (node-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> NODE_COMMAND: &#123;</span><br><span class="line">            CMDNodeData *cmd = &amp;node-&gt;data.command;</span><br><span class="line">            <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">0</span> &amp;&amp; cmd-&gt;redirects == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">0</span> &amp;&amp; cmd-&gt;redirects != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 <span class="comment">// Handle redirection-only command if necessary, or error</span></span><br><span class="line">                 <span class="comment">// For now, if no command, but redirects, it&#x27;s tricky.</span></span><br><span class="line">                 <span class="comment">// Bash creates files but doesn&#x27;t run anything. Let&#x27;s assume error for simplicity.</span></span><br><span class="line">                 debugf(<span class="string">&quot;sh: missing command for redirection\n&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	    <span class="keyword">if</span> (is_inner_cmd(cmd)) &#123;</span><br><span class="line">	    	execute_inner_cmd(cmd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;execute_ast: fork failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">                RedirNode *redir = cmd-&gt;redirects;</span><br><span class="line">                <span class="keyword">while</span> (redir) &#123;</span><br><span class="line">                    <span class="type">int</span> open_flags = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> target_fd_std = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_IN) &#123; open_flags = O_RDONLY; target_fd_std = <span class="number">0</span>; &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_OUT) &#123; open_flags = O_WRONLY | O_CREAT | O_TRUNC; target_fd_std = <span class="number">1</span>; &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_APP) &#123; open_flags = O_WRONLY | O_CREAT | O_APPEND; target_fd_std = <span class="number">1</span>; &#125;</span><br><span class="line">                    <span class="type">int</span> opened_fd = open(redir-&gt;filename, open_flags);</span><br><span class="line">                    <span class="keyword">if</span> (opened_fd &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;sh: cannot open %s\n&quot;</span>, redir-&gt;filename); <span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">                    dup(opened_fd, target_fd_std);</span><br><span class="line">                    close(opened_fd);</span><br><span class="line">                    redir = redir-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">		<span class="type">int</span> spawn_ret;</span><br><span class="line">		<span class="type">char</span> *spawn_argv[MAX_CMD_ARGS + MAX_SHELL_VARS + <span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> spawn_argc = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;sh.b&quot;</span>) == <span class="number">0</span> || mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;sh&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">		    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;/sh.b&quot;</span>) == <span class="number">0</span> || mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;/sh&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cmd-&gt;argc; ++i) spawn_argv[spawn_argc++] = cmd-&gt;argv[i];</span><br><span class="line">            <span class="type">char</span> env_str_pool[MAX_SHELL_VARS][MAX_VAR_NAME_LEN + MAX_VAR_VALUE_LEN + <span class="number">3</span>]; <span class="comment">// +2 for =,\0, +1 for readonly flag</span></span><br><span class="line">            <span class="type">int</span> env_str_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shell_vars[i].is_set &amp;&amp; shell_vars[i].is_exported) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (spawn_argc &lt; (MAX_CMD_ARGS + MAX_SHELL_VARS) &amp;&amp; env_str_idx &lt; MAX_SHELL_VARS) &#123;</span><br><span class="line">                        <span class="type">char</span> *current_env_str = env_str_pool[env_str_idx++];</span><br><span class="line">                        current_env_str[<span class="number">0</span>] = shell_vars[i].is_readonly ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>; <span class="comment">// Prepend readonly flag</span></span><br><span class="line">                        current_env_str[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// Null terminate after flag</span></span><br><span class="line">                        mystrcat(current_env_str, shell_vars[i].name);</span><br><span class="line">                        mystrcat(current_env_str, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">                        mystrcat(current_env_str, shell_vars[i].value);</span><br><span class="line">                        spawn_argv[spawn_argc++] = current_env_str;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            spawn_argv[spawn_argc] = <span class="literal">NULL</span>;</span><br><span class="line">			spawn_ret = spawn(cmd-&gt;argv[<span class="number">0</span>], spawn_argv);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               		spawn_ret = spawn(cmd-&gt;argv[<span class="number">0</span>], (<span class="type">char</span> **)cmd-&gt;argv);</span><br><span class="line">		&#125;</span><br><span class="line">                <span class="keyword">if</span> (spawn_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: failed to spawn &#x27;%s&#x27; (err %d)\n&quot;</span>, cmd-&gt;argv[<span class="number">0</span>], spawn_ret);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">127</span>); <span class="comment">// Standard for command not found</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Default success if spawn *somehow* returns but didn&#x27;t error.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wait(child_pid, <span class="literal">NULL</span>); <span class="comment">// Parent waits, ignore status for now</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NODE_PIPELINE: &#123;</span><br><span class="line">            <span class="keyword">if</span> (pipe(pipe_fds) &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;pipe creation failed&quot;</span>);</span><br><span class="line">            <span class="type">int</span> pid1 = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid1 &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for pipe left failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pid1 == <span class="number">0</span>) &#123;</span><br><span class="line">                close(pipe_fds[<span class="number">0</span>]); dup(pipe_fds[<span class="number">1</span>], <span class="number">1</span>); close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.left); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> pid2 = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid2 &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for pipe right failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pid2 == <span class="number">0</span>) &#123;</span><br><span class="line">                close(pipe_fds[<span class="number">1</span>]); dup(pipe_fds[<span class="number">0</span>], <span class="number">0</span>); close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            close(pipe_fds[<span class="number">0</span>]); close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">            wait(pid1, <span class="literal">NULL</span>); wait(pid2, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NODE_LIST_SEMI:</span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_LIST_AMP:</span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for &amp; failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123; execute_ast(node-&gt;data.binary_op.left); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_AND:</span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left); <span class="comment">// Needs status</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) execute_ast(node-&gt;data.binary_op.right); <span class="comment">// Temp</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_OR:</span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left); <span class="comment">// Needs status</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) execute_ast(node-&gt;data.binary_op.right); <span class="comment">// Temp</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            user_panic(<span class="string">&quot;Unknown AST node type: %d&quot;</span>, node-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> outbuf[<span class="number">20000</span>];</span><br><span class="line"><span class="type">char</span> now_cmd_buf[<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> all_line_count;</span><br><span class="line"><span class="type">int</span> now_line_index;</span><br><span class="line"><span class="type">char</span> all_lines[<span class="number">25</span>][<span class="number">1025</span>];</span><br><span class="line"><span class="type">char</span> copy_buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n, <span class="type">int</span> interactive)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int current_len; </span><br><span class="line">    u_int cursor_pos;  </span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    u_int onscreen_cmd_len = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">        mystrcpy(buf, current_typed_line); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">        <span class="keyword">if</span> (history_count &gt; <span class="number">0</span> &amp;&amp; history_current_nav_offset &lt;= history_count) &#123; </span><br><span class="line">             mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    current_len = mystrlen(buf);</span><br><span class="line">    cursor_pos = current_len; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive &amp;&amp; current_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r$ &quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; current_len; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">        onscreen_cmd_len = current_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = read(<span class="number">0</span>, &amp;c, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (interactive &amp;&amp; current_len == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buf[current_len] = <span class="number">0</span>; <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> requires_full_reprint = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0x1b</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123;</span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0x1b</span>) &#123; </span><br><span class="line">            <span class="type">char</span> seq[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;seq[<span class="number">0</span>], <span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (seq[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;seq[<span class="number">1</span>], <span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (history_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">                            mystrcpy(current_typed_line, buf); </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset &lt; history_count) &#123;</span><br><span class="line">                            history_current_nav_offset++;</span><br><span class="line">                            <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">                            mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">                            current_len = mystrlen(buf);</span><br><span class="line">                            cursor_pos = current_len;</span><br><span class="line">                            requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (history_current_nav_offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        history_current_nav_offset--;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">                            mystrcpy(buf, current_typed_line);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">                            mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        current_len = mystrlen(buf);</span><br><span class="line">                        cursor_pos = current_len;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        cursor_pos--;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;C&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                        cursor_pos++;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\b&#x27;</span> || c == <span class="number">0x7f</span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mymemmove(&amp;buf[cursor_pos - <span class="number">1</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                cursor_pos--;</span><br><span class="line">                current_len--;</span><br><span class="line">                requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x01</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (cursor_pos != <span class="number">0</span>) &#123; cursor_pos = <span class="number">0</span>; requires_full_reprint = <span class="number">1</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x05</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (cursor_pos != current_len) &#123; cursor_pos = current_len; requires_full_reprint = <span class="number">1</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x0B</span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                buf[cursor_pos] = <span class="string">&#x27;\0&#x27;</span>; current_len = cursor_pos; requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x15</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mymemmove(&amp;buf[<span class="number">0</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                current_len -= cursor_pos; cursor_pos = <span class="number">0</span>; requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x17</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                u_int original_cursor_pos = cursor_pos;</span><br><span class="line">                u_int end_of_deletion_span = cursor_pos;</span><br><span class="line">                <span class="keyword">while</span> (cursor_pos &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot; \t&quot;</span>, buf[cursor_pos - <span class="number">1</span>])) cursor_pos--;</span><br><span class="line">                u_int start_of_word_to_delete = cursor_pos;</span><br><span class="line">                <span class="keyword">while</span> (start_of_word_to_delete &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">strchr</span>(<span class="string">&quot; \t&quot;</span>, buf[start_of_word_to_delete - <span class="number">1</span>])) &#123;</span><br><span class="line">                    start_of_word_to_delete--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (start_of_word_to_delete &lt; end_of_deletion_span) &#123;</span><br><span class="line">                    mymemmove(&amp;buf[start_of_word_to_delete], &amp;buf[end_of_deletion_span], current_len - end_of_deletion_span + <span class="number">1</span>);</span><br><span class="line">                    current_len -= (end_of_deletion_span - start_of_word_to_delete);</span><br><span class="line">                    cursor_pos = start_of_word_to_delete;</span><br><span class="line">                    requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor_pos = original_cursor_pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span> || c == <span class="string">&#x27;\n&#x27;</span>) &#123; </span><br><span class="line">            buf[current_len] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interactive) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="number">0x20</span> &amp;&amp; c &lt; <span class="number">0x7f</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_len &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                    mymemmove(&amp;buf[cursor_pos + <span class="number">1</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buf[cursor_pos] = c;</span><br><span class="line">                current_len++;</span><br><span class="line">                cursor_pos++;</span><br><span class="line">                requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requires_full_reprint &amp;&amp; interactive) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; current_len; ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current_len &lt; onscreen_cmd_len) &#123;</span><br><span class="line">                <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; (onscreen_cmd_len - current_len); ++i) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u_int effective_displayed_cmd_len = (current_len &gt; onscreen_cmd_len) ? current_len : onscreen_cmd_len;</span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; (effective_displayed_cmd_len - cursor_pos); ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            onscreen_cmd_len = current_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> input_buf[MAX_INPUT_BUF];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usage: sh [-ix] [script-file]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_history</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd, r, i;</span><br><span class="line">    <span class="type">char</span> line_buf[MAX_INPUT_BUF];</span><br><span class="line">    <span class="type">int</span> line_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    history_count = <span class="number">0</span>;</span><br><span class="line">    history_add_idx = <span class="number">0</span>;</span><br><span class="line">    history_latest_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(HISTORY_FILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> temp_history_load[HISTFILESIZE][MAX_INPUT_BUF];</span><br><span class="line">    <span class="type">int</span> temp_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((r = read(fd, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                line_buf[line_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">                    mystrcpy(temp_history_load[temp_count++], line_buf);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; HISTFILESIZE - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                        mystrcpy(temp_history_load[i], temp_history_load[i+<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mystrcpy(temp_history_load[HISTFILESIZE<span class="number">-1</span>], line_buf);</span><br><span class="line">                &#125;</span><br><span class="line">                line_len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line_len &lt; MAX_INPUT_BUF - <span class="number">1</span>) &#123;</span><br><span class="line">            line_buf[line_len++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (line_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        line_buf[line_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">            mystrcpy(temp_history_load[temp_count++], line_buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; HISTFILESIZE - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                mystrcpy(temp_history_load[i], temp_history_load[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            mystrcpy(temp_history_load[HISTFILESIZE<span class="number">-1</span>], line_buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; temp_count; ++i) &#123;</span><br><span class="line">        mystrcpy(history_lines[history_add_idx], temp_history_load[i]);</span><br><span class="line">        history_latest_idx = history_add_idx;</span><br><span class="line">        history_add_idx = (history_add_idx + <span class="number">1</span>) % HISTFILESIZE;</span><br><span class="line">        <span class="keyword">if</span> (history_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">            history_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_history</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd, i, r;</span><br><span class="line">    <span class="type">int</span> start_idx;</span><br><span class="line"></span><br><span class="line">    fd = open(HISTORY_FILE, O_WRONLY | O_CREAT | O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sh: error saving history to %s\n&quot;</span>, HISTORY_FILE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_count == <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">        start_idx = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start_idx = history_add_idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; history_count; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> current_entry_idx = (start_idx + i) % HISTFILESIZE;</span><br><span class="line">        r = write(fd, history_lines[current_entry_idx], mystrlen(history_lines[current_entry_idx]));</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        r = write(fd, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_to_history</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd_line)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cmd_line[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_count &gt; <span class="number">0</span> &amp;&amp; mystrcmp(history_lines[history_latest_idx], cmd_line) == <span class="number">0</span>) &#123;</span><br><span class="line">        history_current_nav_offset = <span class="number">0</span>; <span class="comment">// Still reset nav offset</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mystrcpy(history_lines[history_add_idx], cmd_line);</span><br><span class="line">    history_latest_idx = history_add_idx;</span><br><span class="line">    history_add_idx = (history_add_idx + <span class="number">1</span>) % HISTFILESIZE;</span><br><span class="line">    <span class="keyword">if</span> (history_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">        history_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    init_shell_vars();</span><br><span class="line">    <span class="type">int</span> interactive = iscons(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> echocmds = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *command_string_from_arg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> arg_idx_after_opts = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; mystrcmp(argv[<span class="number">1</span>], <span class="string">&quot;-c&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            command_string_from_arg = argv[<span class="number">2</span>];</span><br><span class="line">            interactive = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Process other options if any for sh -c ... sh_options ... &quot;cmd&quot; arg1 arg2</span></span><br><span class="line">            <span class="comment">// For now, assume argv[0]=sh, argv[1]=-c, argv[2]=cmd_string</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh: -c option requires an argument\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123; <span class="comment">// Potential script file if not an option</span></span><br><span class="line">         <span class="comment">// This logic needs to be integrated with ARGBEGIN or done before.</span></span><br><span class="line">         <span class="comment">// Simplified: If first arg after &quot;sh&quot; is not an option, assume it&#x27;s a script file.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command_string_from_arg) &#123;</span><br><span class="line">        reset_allocators();</span><br><span class="line">        mystrcpy(input_buf, command_string_from_arg);</span><br><span class="line">        <span class="keyword">if</span> (echocmds) <span class="built_in">printf</span>(<span class="string">&quot;+ %s\n&quot;</span>, input_buf);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* temp_scan = input_buf;</span><br><span class="line">        <span class="keyword">while</span> (*temp_scan &amp;&amp; <span class="built_in">strchr</span>(WHITESPACE, *temp_scan)) temp_scan++;</span><br><span class="line">        <span class="keyword">if</span> (*temp_scan != <span class="string">&#x27;#&#x27;</span> &amp;&amp; *temp_scan != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            tokenizer_init(input_buf);</span><br><span class="line">            ASTNode *ast = parse_line();</span><br><span class="line">            <span class="keyword">if</span> (ast) execute_ast(ast);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (input_buf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;sh: syntax error in command string\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// Shell exits after -c</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!command_string_from_arg) &#123; <span class="comment">// only parse options if not already in -c mode</span></span><br><span class="line">        ARGBEGIN &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: interactive = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: echocmds = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: usage();</span><br><span class="line">        &#125; ARGEND</span><br><span class="line">        arg_idx_after_opts = ARGC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arg_idx_after_opts; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> *arg = argv[i];</span><br><span class="line">        <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (arg[<span class="number">1</span>] == <span class="string">&#x27;c&#x27;</span> || arg[<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span> || arg[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span>)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (arg[<span class="number">1</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; i + <span class="number">1</span> &lt; argc) i++; <span class="comment">// skip command string for -c</span></span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *eq_ptr = <span class="built_in">strchr</span>(arg, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eq_ptr &amp;&amp; (eq_ptr != arg) &amp;&amp; <span class="built_in">strchr</span>(arg, <span class="string">&#x27;/&#x27;</span>) == <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strlen</span>(arg) &gt; <span class="number">2</span>) &#123; <span class="comment">// Heuristic for env var</span></span><br><span class="line">            <span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            <span class="type">char</span> value_buf[MAX_VAR_VALUE_LEN + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> is_ro_flag = arg[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// First char is &#x27;0&#x27; or &#x27;1&#x27; for readonly</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *name_start = arg + <span class="number">1</span>; <span class="comment">// Name starts after the flag</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> name_len = eq_ptr - name_start;</span><br><span class="line">            <span class="keyword">if</span> (name_len &gt; <span class="number">0</span> &amp;&amp; name_len &lt;= MAX_VAR_NAME_LEN) &#123;</span><br><span class="line">                mystrncpy(name, name_start, name_len);</span><br><span class="line">                name[name_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (mystrlen(eq_ptr + <span class="number">1</span>) &lt;= MAX_VAR_VALUE_LEN) &#123;</span><br><span class="line">                    mystrcpy(value_buf, eq_ptr + <span class="number">1</span>);</span><br><span class="line">                    set_variable(name, value_buf, <span class="number">1</span>, is_ro_flag, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">/* value too long, skip */</span> &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">/* name too long or empty, skip */</span> &#125;</span><br><span class="line">            arg_idx_after_opts = i + <span class="number">1</span>; <span class="comment">// Update index of potential script file</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is now considered the script file if present</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; arg_idx_after_opts &amp;&amp; !command_string_from_arg) &#123; <span class="comment">// Script file if not -c mode</span></span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r_open = open(argv[arg_idx_after_opts], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (r_open &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;open %s: %d&quot;</span>, argv[arg_idx_after_opts], r_open);</span><br><span class="line">        <span class="keyword">if</span> (r_open != <span class="number">0</span>) &#123; dup(r_open, <span class="number">0</span>); close(r_open); &#125;</span><br><span class="line">        interactive = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;::                                                         ::\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;::                 MOS Shell (Command Control)             ::\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;::                                                         ::\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    load_history();</span><br><span class="line">    <span class="type">int</span> first_prompt_cycle = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        reset_allocators();</span><br><span class="line">        <span class="built_in">memset</span>(input_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(input_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first_prompt_cycle) <span class="built_in">printf</span>(<span class="string">&quot;\n$ &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123;</span><br><span class="line">            current_typed_line[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readline(input_buf, <span class="keyword">sizeof</span> input_buf, interactive);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input_buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">                first_prompt_cycle = <span class="number">0</span>; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        first_prompt_cycle = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (echocmds) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;+ %s\n&quot;</span>, input_buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* temp_scan = input_buf;</span><br><span class="line">        <span class="keyword">while</span> (*temp_scan &amp;&amp; <span class="built_in">strchr</span>(WHITESPACE, *temp_scan)) temp_scan++;</span><br><span class="line">        <span class="keyword">if</span> (*temp_scan == <span class="string">&#x27;#&#x27;</span> || *temp_scan == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            first_prompt_cycle = <span class="number">0</span>; <span class="comment">// Comment or empty line, next prompt doesn&#x27;t need extra \n</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	    add_to_history(input_buf);</span><br><span class="line">        save_history();</span><br><span class="line">        tokenizer_init(input_buf);</span><br><span class="line">        ASTNode *ast = parse_line();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ast) &#123;</span><br><span class="line">            execute_ast(ast);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(input_buf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; input_buf[<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (current_token.type != TOKEN_EOF &amp;&amp; current_token.type != TOKEN_EOL &amp;&amp; current_token.type != TOKEN_ERROR &amp;&amp; current_token.type != <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: syntax error near token &#x27;%s&#x27;\n&quot;</span>, current_token.value);</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_token.type == TOKEN_ERROR &amp;&amp; current_token.value[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: tokenizer error near &#x27;%s&#x27;\n&quot;</span>, current_token.value);</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_token.type != TOKEN_EOF &amp;&amp; current_token.type != TOKEN_EOL)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: syntax error\n&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrncpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">	<span class="type">char</span>* start = dest;</span><br><span class="line">	<span class="keyword">while</span> (count &amp;&amp; (*dest++ = *src++)) &#123;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count) &#123;</span><br><span class="line">		<span class="keyword">while</span> (--count) &#123;</span><br><span class="line">			*dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; (<span class="type">size_t</span>)n &amp;&amp; s1[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; s2[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>)s1[i] - (<span class="type">unsigned</span> <span class="type">char</span>)s2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; (<span class="type">size_t</span>)n) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>)s1[i] - (<span class="type">unsigned</span> <span class="type">char</span>)s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; (*str1 == *str2)) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)str1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* ptr = dest;</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="string">&#x27;\0&#x27;</span>) ptr++;</span><br><span class="line">    <span class="keyword">while</span> ((*ptr++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[length] != <span class="string">&#x27;\0&#x27;</span>) length++;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_shell_vars</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">        shell_vars[i].is_set = <span class="number">0</span>;</span><br><span class="line">        shell_vars[i].name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        shell_vars[i].value[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        shell_vars[i].is_exported = <span class="number">0</span>;</span><br><span class="line">        shell_vars[i].is_readonly = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num_set_vars = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShellVar* <span class="title function_">find_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!name) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shell_vars[i].is_set &amp;&amp; mystrcmp(shell_vars[i].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;shell_vars[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShellVar* <span class="title function_">find_free_slot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shell_vars[i].is_set) <span class="keyword">return</span> &amp;shell_vars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> export_flag, <span class="type">int</span> readonly_flag, <span class="type">int</span> update_flags_if_exists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mystrlen(name) &gt; MAX_VAR_NAME_LEN) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; mystrlen(value) &gt; MAX_VAR_VALUE_LEN) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ShellVar *var = find_variable(name);</span><br><span class="line">    <span class="keyword">if</span> (var) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var-&gt;is_readonly) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        mystrcpy(var-&gt;value, value ? value : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (update_flags_if_exists) &#123;</span><br><span class="line">            var-&gt;is_exported = export_flag;</span><br><span class="line">            <span class="keyword">if</span> (readonly_flag) var-&gt;is_readonly = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        var = find_free_slot();</span><br><span class="line">        <span class="keyword">if</span> (!var) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        mystrcpy(var-&gt;name, name);</span><br><span class="line">        mystrcpy(var-&gt;value, value ? value : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        var-&gt;is_exported = export_flag;</span><br><span class="line">        var-&gt;is_readonly = readonly_flag;</span><br><span class="line">        var-&gt;is_set = <span class="number">1</span>;</span><br><span class="line">        num_set_vars++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unset_variable</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    ShellVar *var = find_variable(name);</span><br><span class="line">    <span class="keyword">if</span> (!var) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (var-&gt;is_readonly) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    var-&gt;is_set = <span class="number">0</span>;</span><br><span class="line">    var-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    num_set_vars--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_all_variables</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shell_vars[i].is_set) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%s%s=%s\n&quot;</span>,</span><br><span class="line">                   shell_vars[i].is_exported ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   shell_vars[i].is_readonly ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   shell_vars[i].name,</span><br><span class="line">                   shell_vars[i].value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_variable_value</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    ShellVar *var = find_variable(name);</span><br><span class="line">    <span class="keyword">if</span> (var &amp;&amp; var-&gt;is_set) <span class="keyword">return</span> var-&gt;value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">mystrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == c) <span class="keyword">return</span> (<span class="type">char</span> *)str;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">return</span> (<span class="type">char</span> *)str;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymemmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *d = (<span class="type">unsigned</span> <span class="type">char</span> *)dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)src;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) d[i] = s[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) d[i - <span class="number">1</span>] = s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个架构流程大致可以分为：<strong>输入读入(readline)，生成AST树(parse_line)，执行AST树(execute_ast)，执行内部指令(execute_inner_command)&#x2F;外部指令(spawn)。</strong></p>
<p>首先是输入读入，调用readline函数来完成从标准输入中读入，readline函数如下（实现了快捷键）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n, <span class="type">int</span> interactive)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int current_len; </span><br><span class="line">    u_int cursor_pos;  </span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    u_int onscreen_cmd_len = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">        mystrcpy(buf, current_typed_line); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">        <span class="keyword">if</span> (history_count &gt; <span class="number">0</span> &amp;&amp; history_current_nav_offset &lt;= history_count) &#123; </span><br><span class="line">             mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    current_len = mystrlen(buf);</span><br><span class="line">    cursor_pos = current_len; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive &amp;&amp; current_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r$ &quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; current_len; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">        onscreen_cmd_len = current_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = read(<span class="number">0</span>, &amp;c, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (interactive &amp;&amp; current_len == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buf[current_len] = <span class="number">0</span>; <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> requires_full_reprint = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0x1b</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123;</span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0x1b</span>) &#123; </span><br><span class="line">            <span class="type">char</span> seq[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;seq[<span class="number">0</span>], <span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (seq[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (read(<span class="number">0</span>, &amp;seq[<span class="number">1</span>], <span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (history_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">                            mystrcpy(current_typed_line, buf); </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset &lt; history_count) &#123;</span><br><span class="line">                            history_current_nav_offset++;</span><br><span class="line">                            <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">                            mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">                            current_len = mystrlen(buf);</span><br><span class="line">                            cursor_pos = current_len;</span><br><span class="line">                            requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (history_current_nav_offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        history_current_nav_offset--;</span><br><span class="line">                        <span class="keyword">if</span> (history_current_nav_offset == <span class="number">0</span>) &#123; </span><br><span class="line">                            mystrcpy(buf, current_typed_line);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">int</span> nav_idx_in_hist_array = (history_latest_idx - (history_current_nav_offset - <span class="number">1</span>) + HISTFILESIZE) % HISTFILESIZE;</span><br><span class="line">                            mystrcpy(buf, history_lines[nav_idx_in_hist_array]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        current_len = mystrlen(buf);</span><br><span class="line">                        cursor_pos = current_len;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        cursor_pos--;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seq[<span class="number">1</span>] == <span class="string">&#x27;C&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                        cursor_pos++;</span><br><span class="line">                        requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\b&#x27;</span> || c == <span class="number">0x7f</span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mymemmove(&amp;buf[cursor_pos - <span class="number">1</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                cursor_pos--;</span><br><span class="line">                current_len--;</span><br><span class="line">                requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x01</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (cursor_pos != <span class="number">0</span>) &#123; cursor_pos = <span class="number">0</span>; requires_full_reprint = <span class="number">1</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x05</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (cursor_pos != current_len) &#123; cursor_pos = current_len; requires_full_reprint = <span class="number">1</span>;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x0B</span>) &#123; </span><br><span class="line">             <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                buf[cursor_pos] = <span class="string">&#x27;\0&#x27;</span>; current_len = cursor_pos; requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x15</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mymemmove(&amp;buf[<span class="number">0</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                current_len -= cursor_pos; cursor_pos = <span class="number">0</span>; requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x17</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursor_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                u_int original_cursor_pos = cursor_pos;</span><br><span class="line">                u_int end_of_deletion_span = cursor_pos;</span><br><span class="line">                <span class="keyword">while</span> (cursor_pos &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot; \t&quot;</span>, buf[cursor_pos - <span class="number">1</span>])) cursor_pos--;</span><br><span class="line">                u_int start_of_word_to_delete = cursor_pos;</span><br><span class="line">                <span class="keyword">while</span> (start_of_word_to_delete &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">strchr</span>(<span class="string">&quot; \t&quot;</span>, buf[start_of_word_to_delete - <span class="number">1</span>])) &#123;</span><br><span class="line">                    start_of_word_to_delete--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (start_of_word_to_delete &lt; end_of_deletion_span) &#123;</span><br><span class="line">                    mymemmove(&amp;buf[start_of_word_to_delete], &amp;buf[end_of_deletion_span], current_len - end_of_deletion_span + <span class="number">1</span>);</span><br><span class="line">                    current_len -= (end_of_deletion_span - start_of_word_to_delete);</span><br><span class="line">                    cursor_pos = start_of_word_to_delete;</span><br><span class="line">                    requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor_pos = original_cursor_pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span> || c == <span class="string">&#x27;\n&#x27;</span>) &#123; </span><br><span class="line">            buf[current_len] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interactive) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="number">0x20</span> &amp;&amp; c &lt; <span class="number">0x7f</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (history_current_nav_offset != <span class="number">0</span>) &#123; </span><br><span class="line">                mystrcpy(current_typed_line, buf);</span><br><span class="line">                history_current_nav_offset = <span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_len &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cursor_pos &lt; current_len) &#123;</span><br><span class="line">                    mymemmove(&amp;buf[cursor_pos + <span class="number">1</span>], &amp;buf[cursor_pos], current_len - cursor_pos + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buf[cursor_pos] = c;</span><br><span class="line">                current_len++;</span><br><span class="line">                cursor_pos++;</span><br><span class="line">                requires_full_reprint = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requires_full_reprint &amp;&amp; interactive) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; current_len; ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current_len &lt; onscreen_cmd_len) &#123;</span><br><span class="line">                <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; (onscreen_cmd_len - current_len); ++i) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u_int effective_displayed_cmd_len = (current_len &gt; onscreen_cmd_len) ? current_len : onscreen_cmd_len;</span><br><span class="line">            <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; (effective_displayed_cmd_len - cursor_pos); ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            onscreen_cmd_len = current_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是解析输入。首先需要明确AST语法树的结构和节点内容：</p>
<p>整体的思路是递归下降，先定义出最小的Token单元，然后用get_new_raw_token来获取下一个Token，最后根据当前的token来构建不同的ASTNode节点。</p>
<p>枚举类型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> <span class="title">ASTNode</span>;</span></span><br><span class="line"><span class="comment">// --- AST Node Types Enum ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NODE_ILLEGAL = <span class="number">0</span>,</span><br><span class="line">    NODE_COMMAND,</span><br><span class="line">    NODE_PIPELINE,</span><br><span class="line">    NODE_LIST_SEMI,  <span class="comment">// For &#x27;;&#x27;</span></span><br><span class="line">    NODE_AND,        <span class="comment">// For &#x27;&amp;&amp;&#x27;</span></span><br><span class="line">    NODE_OR,         <span class="comment">// For &#x27;||&#x27;</span></span><br><span class="line">&#125; ASTNodeType;</span><br><span class="line"><span class="comment">// --- Token Types Enum (based on EBNF) ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TOKEN_ERROR = <span class="number">0</span>,   <span class="comment">// Error or uninitialized</span></span><br><span class="line">    TOKEN_EOF = <span class="number">1</span>,     <span class="comment">// End of input (actual end)</span></span><br><span class="line">    TOKEN_EOL = <span class="number">2</span>,     <span class="comment">// End of line (newline or effective end via &#x27;#&#x27;)</span></span><br><span class="line">    TOKEN_WORD,        <span class="comment">// Command, argument, filename</span></span><br><span class="line">    TOKEN_PIPE,        <span class="comment">// |</span></span><br><span class="line">    TOKEN_SEMI,        <span class="comment">// ;</span></span><br><span class="line">    TOKEN_AND,         <span class="comment">// &amp;&amp;</span></span><br><span class="line">    TOKEN_OR,          <span class="comment">// ||</span></span><br><span class="line">    TOKEN_REDIR_IN,    <span class="comment">// &lt;</span></span><br><span class="line">    TOKEN_REDIR_OUT,   <span class="comment">// &gt;</span></span><br><span class="line">    TOKEN_REDIR_APP,   <span class="comment">// &gt;&gt;</span></span><br><span class="line">&#125; TokenType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    REDIR_TYPE_IN,   <span class="comment">// &lt;</span></span><br><span class="line">    REDIR_TYPE_OUT,  <span class="comment">// &gt;</span></span><br><span class="line">    REDIR_TYPE_APP,  <span class="comment">// &gt;&gt;</span></span><br><span class="line">&#125; RedirType;</span><br></pre></td></tr></table></figure>

<p>包含了ASTNodeType，用来标记ASTNode的节点类型。TokenType，用来标记每个token的类型。</p>
<p>之后是ASTNode和Token结构定义。<br><strong>Token</strong>包含一个TokenType，用来标志Token的类型，以及一个value。如果TokenType是TOKEN_WORD，那么这个字符串会被存到value中。<br><strong>ASTNode</strong>包含一个ASTNodeType，用来标志这个ASTNode节点的类型，以及data。data分为两种，如果是command类型，则data是CMDNodeData；如果是；&amp;&amp; || |，那么data是BinaryOpNodeData。<br><strong>CMDNodeData</strong>包括argv，用来涵盖一个指令的几个由空白字符分割的片段，argv[0]是指令的名字，后面是指令参数。argc是有效argv的数目，RedirNode是指令中包含的重定向指针。<br><strong>BinaryOpNodeData</strong>类似于二叉树，由左右节点组成，类型都是ASTNode。<br><strong>RedirNode</strong>包含重定向的类型RedirType，用来区分 &lt; &gt; &gt;&gt;，同时还有重定向操作的文件名filename，同时还有指向下一个RedirNode的指针，用来链式存储连续重定向。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- Token Structure ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TokenType type;</span><br><span class="line">    <span class="type">char</span> value[MAX_TOKEN_LEN]; <span class="comment">// String value of the token</span></span><br><span class="line">&#125; Token;</span><br><span class="line"><span class="comment">// --- Redirection Structure ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RedirNode</span> &#123;</span></span><br><span class="line">    RedirType type;</span><br><span class="line">    <span class="type">char</span> *filename;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RedirNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RedirNode;</span><br><span class="line"><span class="comment">// --- AST Node Structures ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *argv[MAX_CMD_ARGS];</span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    RedirNode *redirects; <span class="comment">// Linked list of redirections</span></span><br><span class="line">&#125; CMDNodeData;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ASTNode *left;</span><br><span class="line">    ASTNode *right;</span><br><span class="line">&#125; BinaryOpNodeData; <span class="comment">// For Pipeline, List, And, Or</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ASTNode</span> &#123;</span></span><br><span class="line">    ASTNodeType type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        CMDNodeData command;</span><br><span class="line">        BinaryOpNodeData binary_op;</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析层级如下：<br>parse_line &#x3D; parse_list<br>parse_list &#x3D; parse_and_or ( ; parse_and_or)<br>parse_and_or &#x3D; parse_pipeline ( &amp;&amp;&#x2F;| | parse_pipeline)<br>parse_pipeline &#x3D; parse_command ( | parse_command)<br>parse_command &#x3D; command (redirect command)</p>
<p>具体函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ASTNode *<span class="title function_">parse_line</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parse_list();</span><br><span class="line">&#125;</span><br><span class="line">ASTNode *<span class="title function_">parse_list</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_and_or();</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_SEMI || current_token.type == TOKEN_AMP) &#123;</span><br><span class="line">        TokenType op_type = current_token.type;</span><br><span class="line">        consume_token();</span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) &#123; </span><br><span class="line">            ASTNode *new_list_node = alloc_ast_node(op_type == TOKEN_SEMI ? NODE_LIST_SEMI : NODE_LIST_AMP);</span><br><span class="line">            new_list_node-&gt;data.binary_op.left = node;</span><br><span class="line">            new_list_node-&gt;data.binary_op.right = <span class="literal">NULL</span>;</span><br><span class="line">            node = new_list_node;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *right_node = parse_and_or();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error after &#x27;%s&#x27;\n&quot;</span>, op_type == TOKEN_SEMI ? <span class="string">&quot;;&quot;</span> : <span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_list_node = alloc_ast_node(op_type == TOKEN_SEMI ? NODE_LIST_SEMI : NODE_LIST_AMP);</span><br><span class="line">        new_list_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_list_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_list_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">ASTNode *<span class="title function_">parse_and_or</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_pipeline();</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_AND || current_token.type == TOKEN_OR) &#123;</span><br><span class="line">        TokenType op_type = current_token.type;</span><br><span class="line">        consume_token();</span><br><span class="line">        ASTNode *right_node = parse_pipeline();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error: &#x27;%s&#x27; not followed by pipeline\n&quot;</span>, op_type == TOKEN_AND ? <span class="string">&quot;&amp;&amp;&quot;</span> : <span class="string">&quot;||&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_op_node = alloc_ast_node(op_type == TOKEN_AND ? NODE_AND : NODE_OR);</span><br><span class="line">        new_op_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_op_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_op_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">ASTNode *<span class="title function_">parse_pipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    ASTNode *node = parse_command();</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current_token.type == TOKEN_PIPE) &#123;</span><br><span class="line">        consume_token();</span><br><span class="line">        ASTNode *right_node = parse_command();</span><br><span class="line">        <span class="keyword">if</span> (!right_node) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;Syntax error: &#x27;|&#x27; not followed by command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ASTNode *new_pipe_node = alloc_ast_node(NODE_PIPELINE);</span><br><span class="line">        new_pipe_node-&gt;data.binary_op.left = node;</span><br><span class="line">        new_pipe_node-&gt;data.binary_op.right = right_node;</span><br><span class="line">        node = new_pipe_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">ASTNode *<span class="title function_">parse_command</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current_token.type != TOKEN_WORD &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_IN &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_OUT &amp;&amp;</span><br><span class="line">        current_token.type != TOKEN_REDIR_APP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_EOF || current_token.type == TOKEN_EOL) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    ASTNode *cmd_node_ast = alloc_ast_node(NODE_COMMAND);</span><br><span class="line">    CMDNodeData *cmd_data = &amp;cmd_node_ast-&gt;data.command;</span><br><span class="line">    RedirNode **next_redir_ptr = &amp;cmd_data-&gt;redirects;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> parent_shell_is_interactive = iscons(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// Changed to infinite loop, break out explicitly</span></span><br><span class="line">        <span class="keyword">if</span> (current_token.type == TOKEN_WORD) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cmd_data-&gt;argc &lt; MAX_CMD_ARGS - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> *arg_after_var_expansion = expand_string_variables(current_token.value);</span><br><span class="line">                <span class="type">char</span> *final_arg_for_argv = arg_after_var_expansion; <span class="comment">// Start with variable-expanded arg</span></span><br><span class="line">                <span class="type">char</span> rebuilt_arg_buffer[MAX_EXPANDED_STR_LEN * <span class="number">2</span>]; <span class="comment">// Temporary buffer for rebuilding arg</span></span><br><span class="line">                rebuilt_arg_buffer[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="type">char</span> *current_rebuilt_ptr = rebuilt_arg_buffer;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *scan_ptr = arg_after_var_expansion;</span><br><span class="line">		<span class="comment">//printf(&quot;command word: %s\n&quot;, scan_ptr);</span></span><br><span class="line">                <span class="keyword">while</span> (*scan_ptr) &#123;</span><br><span class="line">                    <span class="type">char</span> *backtick_start = <span class="built_in">strchr</span>(scan_ptr, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (backtick_start) &#123;</span><br><span class="line">                        <span class="type">char</span> *backtick_end = <span class="built_in">strchr</span>(backtick_start + <span class="number">1</span>, <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (backtick_end) &#123;</span><br><span class="line">                            <span class="comment">// Copy part before the first backtick</span></span><br><span class="line">                            <span class="keyword">if</span> (backtick_start &gt; scan_ptr) &#123;</span><br><span class="line">                                mystrncpy(current_rebuilt_ptr, scan_ptr, backtick_start - scan_ptr);</span><br><span class="line">                                current_rebuilt_ptr += (backtick_start - scan_ptr);</span><br><span class="line">				<span class="comment">//printf(&quot;rebuilt: %s\n&quot;, current_rebuilt_ptr);</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Extract command for substitution</span></span><br><span class="line">                            <span class="type">char</span> cmd_to_subst[MAX_INPUT_BUF];</span><br><span class="line">                            <span class="type">int</span> cmd_len = backtick_end - (backtick_start + <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span> (cmd_len &gt;= MAX_INPUT_BUF) cmd_len = MAX_INPUT_BUF <span class="number">-1</span>; <span class="comment">// Truncate if too long</span></span><br><span class="line">                            mystrncpy(cmd_to_subst, backtick_start + <span class="number">1</span>, cmd_len);</span><br><span class="line">                            cmd_to_subst[cmd_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			    <span class="comment">//printf(&quot;cmd_to_subst: %s\n&quot;, cmd_to_subst);</span></span><br><span class="line">                            <span class="comment">// Execute substitution</span></span><br><span class="line">                            <span class="type">char</span> *subst_output = execute_command_substitution(cmd_to_subst, parent_shell_is_interactive);</span><br><span class="line">                            <span class="keyword">if</span> (subst_output) &#123; <span class="comment">// subst_output is already processed (newlines stripped/replaced)</span></span><br><span class="line">                                mystrcat(current_rebuilt_ptr, subst_output); <span class="comment">// Append result</span></span><br><span class="line">                                current_rebuilt_ptr += mystrlen(subst_output);</span><br><span class="line">                            &#125;</span><br><span class="line">                            scan_ptr = backtick_end + <span class="number">1</span>; <span class="comment">// Continue scanning after the closing backtick</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Unmatched opening backtick, treat literally</span></span><br><span class="line">                            mystrcat(current_rebuilt_ptr, scan_ptr);</span><br><span class="line">                            current_rebuilt_ptr += mystrlen(scan_ptr);</span><br><span class="line">                            scan_ptr += mystrlen(scan_ptr); <span class="comment">// Go to end</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// No more backticks in the remainder of the string</span></span><br><span class="line">                        mystrcat(current_rebuilt_ptr, scan_ptr);</span><br><span class="line">                        current_rebuilt_ptr += mystrlen(scan_ptr);</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// Done with this argument string</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                *current_rebuilt_ptr = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// Null terminate the rebuilt argument</span></span><br><span class="line">                <span class="keyword">if</span> (rebuilt_arg_buffer[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span> || arg_after_var_expansion[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123; <span class="comment">// If something was rebuilt or original was empty</span></span><br><span class="line">                    final_arg_for_argv = user_strdup(rebuilt_arg_buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// No substitutions, or only var expansion happened</span></span><br><span class="line">                    final_arg_for_argv = user_strdup(arg_after_var_expansion); <span class="comment">// strdup the var-expanded one</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// --- End Command Substitution Pass ---</span></span><br><span class="line">                cmd_data-&gt;argv[cmd_data-&gt;argc++] = final_arg_for_argv;</span><br><span class="line">		<span class="comment">//printf(&quot;final_arg_for_argv: %s\n&quot;, final_arg_for_argv);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ... too many args ... */</span> <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">            consume_token();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_token.type == TOKEN_REDIR_IN ||</span><br><span class="line">                   current_token.type == TOKEN_REDIR_OUT ||</span><br><span class="line">                   current_token.type == TOKEN_REDIR_APP) &#123;</span><br><span class="line">            TokenType redir_op_type = current_token.type;</span><br><span class="line">            consume_token(); </span><br><span class="line">            <span class="keyword">if</span> (current_token.type != TOKEN_WORD) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;Syntax error: Redirection operator not followed by filename\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            RedirNode *redir_node = alloc_redir_node();</span><br><span class="line">            <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_IN) redir_node-&gt;type = REDIR_TYPE_IN;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_OUT) redir_node-&gt;type = REDIR_TYPE_OUT;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (redir_op_type == TOKEN_REDIR_APP) redir_node-&gt;type = REDIR_TYPE_APP;</span><br><span class="line">	     <span class="comment">// Expand variables in the filename</span></span><br><span class="line">            <span class="type">char</span> *expanded_filename = expand_string_variables(current_token.value);</span><br><span class="line">            redir_node-&gt;filename = expanded_filename; <span class="comment">// user_strdup is now done by expand_string_variables</span></span><br><span class="line">            consume_token();</span><br><span class="line">            *next_redir_ptr = redir_node;</span><br><span class="line">            next_redir_ptr = &amp;redir_node-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Not a word or redirection, end of simple command</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cmd_data-&gt;argv[cmd_data-&gt;argc] = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">if</span> (cmd_data-&gt;argc == <span class="number">0</span> &amp;&amp; cmd_data-&gt;redirects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cmd_node_ast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解析完AST语法树后，会返回语法树的根节点 ASTNode * node。</p>
<p>之后就进入执行语法树的过程了。执行语法树的过程主要是根据当前ASTNode的类型来进行不同的操作。</p>
<p>如果当前是NODE_COMMAND，则利用当前节点包含的command来运行指令。运行的过程为，先判断该指令是否是内部指令，如果是的话直接调用函数运行，否则用spawn创建子进程运行。</p>
<p>如果当前是NODE_PIPELINE，则先创建管道，之后新开两个子进程，分别运行管道左右两边的命令。运行左边的命令时，将标准输出与管道的写端共享页面，即往标准输出的写入被视为写入管道；运行右边的命令时，将标准输入与管道的读端共享页面，即从标准输入的读取被视为读取管道。这样执行右边命令的进程在读取时，读取到的就是执行左边命令的进程的输出，也就是完成管道的作用。</p>
<p>如果是NODE_AND或者NODE_OR，则先递归运行左边的命令，之后根据管道来传输运行返回值，再根据条件运行的条件判断来确定是否运行右边的指令。</p>
<p>如果是NODE_LIST_SEMI，则是多条指令在同一行运行的情况。只需要按顺序依次从左到右运行指令即可。</p>
<p>总体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">execute_ast</span><span class="params">(ASTNode *node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> child_pid;</span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">switch</span> (node-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> NODE_COMMAND: &#123;</span><br><span class="line">            CMDNodeData *cmd = &amp;node-&gt;data.command;</span><br><span class="line">            <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">0</span> &amp;&amp; cmd-&gt;redirects == <span class="literal">NULL</span>) &#123; <span class="comment">// Should be caught by parser</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">0</span>) &#123; </span><br><span class="line">                debugf(<span class="string">&quot;sh: missing command for redirection\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	    <span class="keyword">if</span> (is_inner_cmd(cmd)) &#123;</span><br><span class="line">	    	execute_inner_cmd(cmd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//printf(&quot;%s is outer command\n&quot;, cmd-&gt;argv[0]);</span></span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;execute_ast: fork for command failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123; <span class="comment">// Child process</span></span><br><span class="line">                RedirNode *redir = cmd-&gt;redirects;</span><br><span class="line">                <span class="keyword">while</span> (redir) &#123;</span><br><span class="line">                    <span class="type">int</span> open_flags = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> target_fd_std = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_IN) &#123;</span><br><span class="line">                        open_flags = O_RDONLY;</span><br><span class="line">                        target_fd_std = <span class="number">0</span>; </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_OUT) &#123;</span><br><span class="line">                        open_flags = O_WRONLY | O_CREAT | O_TRUNC;</span><br><span class="line">                        target_fd_std = <span class="number">1</span>; </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (redir-&gt;type == REDIR_TYPE_APP) &#123;</span><br><span class="line">                        open_flags = O_WRONLY | O_CREAT | O_APPEND; </span><br><span class="line">                        target_fd_std = <span class="number">1</span>; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> opened_fd = open(redir-&gt;filename, open_flags);</span><br><span class="line">                    <span class="keyword">if</span> (opened_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;sh: cannot open %s\n&quot;</span>, redir-&gt;filename); <span class="comment">// Use printf for user messages</span></span><br><span class="line">                        <span class="built_in">exit</span>(); </span><br><span class="line">                    &#125;</span><br><span class="line">                    dup(opened_fd, target_fd_std);</span><br><span class="line">                    close(opened_fd);</span><br><span class="line">                    redir = redir-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">		<span class="type">int</span> spawn_ret;</span><br><span class="line">		<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;sh.b&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">		    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;sh&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">		    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;/sh.b&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">		    mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;/sh&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> *spawn_argv[MAX_CMD_ARGS + MAX_SHELL_VARS + <span class="number">1</span>]; <span class="comment">// Max possible size</span></span><br><span class="line">            <span class="type">int</span> spawn_argc = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 1. Copy command and its arguments</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cmd-&gt;argc; ++i) &#123;</span><br><span class="line">                spawn_argv[spawn_argc++] = cmd-&gt;argv[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. Append exported environment variables</span></span><br><span class="line">            <span class="type">char</span> env_str_pool[MAX_SHELL_VARS][MAX_VAR_NAME_LEN + MAX_VAR_VALUE_LEN + <span class="number">2</span>]; <span class="comment">// Pool for &quot;NAME=VALUE&quot; strings</span></span><br><span class="line">            <span class="type">int</span> env_str_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SHELL_VARS; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shell_vars[i].is_set &amp;&amp; shell_vars[i].is_exported) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (spawn_argc &lt; (MAX_CMD_ARGS + MAX_SHELL_VARS) &amp;&amp; env_str_idx &lt; MAX_SHELL_VARS) &#123;</span><br><span class="line">                        <span class="type">char</span> *current_env_str = env_str_pool[env_str_idx++];</span><br><span class="line">			<span class="keyword">if</span> (shell_vars[i].is_readonly) &#123;mystrcat(current_env_str, <span class="string">&quot;1&quot;</span>);	&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;mystrcat(current_env_str, <span class="string">&quot;0&quot;</span>);&#125;</span><br><span class="line">			mystrcat(current_env_str, shell_vars[i].name);</span><br><span class="line">			mystrcat(current_env_str, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">			mystrcat(current_env_str, shell_vars[i].value);</span><br><span class="line">                        spawn_argv[spawn_argc++] = current_env_str;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* too many args or env vars, handle error */</span> <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            spawn_argv[spawn_argc] = <span class="literal">NULL</span>; <span class="comment">// Null-terminate argv for spawn</span></span><br><span class="line">			<span class="comment">//printf(&quot;create a child shell\n&quot;);</span></span><br><span class="line">			<span class="type">int</span> i;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spawn_argc; i++) &#123;</span><br><span class="line">				<span class="comment">//printf(&quot;%s\n&quot;, spawn_argv[i]);</span></span><br><span class="line">			&#125;</span><br><span class="line">			spawn_ret = spawn(cmd-&gt;argv[<span class="number">0</span>], spawn_argv);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="type">char</span> **argv2 = (<span class="type">char</span> **)cmd-&gt;argv;</span><br><span class="line">			<span class="keyword">while</span>(argv2[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>,argv2[i++]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">               		spawn_ret = spawn(cmd-&gt;argv[<span class="number">0</span>], (<span class="type">char</span> **)cmd-&gt;argv); </span><br><span class="line">		&#125;</span><br><span class="line">                <span class="keyword">if</span> (spawn_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Error message printed by spawn or child itself if command not found by spawn</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sh: failed to spawn &#x27;%s&#x27; (err %d)\n&quot;</span>, cmd-&gt;argv[<span class="number">0</span>], spawn_ret);</span><br><span class="line">                &#125;</span><br><span class="line">		wait(spawn_ret);</span><br><span class="line">                <span class="built_in">exit</span>(); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Parent process</span></span><br><span class="line">                wait(child_pid); </span><br><span class="line">                <span class="comment">// After child exits, its stdout should have been flushed by its own exit sequence</span></span><br><span class="line">                <span class="comment">// or by kernel if it&#x27;s a direct syscall write.</span></span><br><span class="line">                <span class="comment">// No explicit fflush needed here for child&#x27;s output by parent.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NODE_PIPELINE: &#123;</span><br><span class="line">            <span class="keyword">if</span> (pipe(pipe_fds) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;pipe creation failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> pid1 = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid1 &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for pipe left failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pid1 == <span class="number">0</span>) &#123; </span><br><span class="line">                close(pipe_fds[<span class="number">0</span>]); </span><br><span class="line">                dup(pipe_fds[<span class="number">1</span>], <span class="number">1</span>);  </span><br><span class="line">                close(pipe_fds[<span class="number">1</span>]); </span><br><span class="line">                execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">                <span class="built_in">exit</span>(); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> pid2 = fork();</span><br><span class="line">            <span class="keyword">if</span> (pid2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 user_panic(<span class="string">&quot;fork for pipe right failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pid2 == <span class="number">0</span>) &#123;</span><br><span class="line">                close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">                dup(pipe_fds[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">                close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">                <span class="built_in">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            close(pipe_fds[<span class="number">0</span>]);</span><br><span class="line">            close(pipe_fds[<span class="number">1</span>]);</span><br><span class="line">            wait(pid1);</span><br><span class="line">            wait(pid2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NODE_LIST_SEMI:</span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) &#123; </span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> NODE_LIST_AMP: </span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) user_panic(<span class="string">&quot;fork for &amp; failed&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">                <span class="built_in">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right) &#123; </span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_AND: </span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Proper exit status handling needed</span></span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">            <span class="comment">// For now, simplified: always execute right if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right &amp;&amp; mystrcmp(node-&gt;data.binary_op.left-&gt;data.command.argv[<span class="number">0</span>], <span class="string">&quot;/mkdir&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                 execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NODE_OR: </span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Proper exit status handling needed</span></span><br><span class="line">            execute_ast(node-&gt;data.binary_op.left);</span><br><span class="line">            <span class="comment">// For now, simplified: always execute right if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;data.binary_op.right  &amp;&amp; mystrcmp(node-&gt;data.binary_op.left-&gt;data.command.argv[<span class="number">0</span>], <span class="string">&quot;/mkdir&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                execute_ast(node-&gt;data.binary_op.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            user_panic(<span class="string">&quot;Unknown AST node type: %d&quot;</span>, node-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，我重构的AST语法树结构就基本完成了，下面开始新增指令运行。</p>
<h3 id="不带-b-后缀指令"><a href="#不带-b-后缀指令" class="headerlink" title="不带 .b 后缀指令"></a>不带 <code>.b</code> 后缀指令</h3><p>你需要实现不带 <code>.b</code> 后缀的指令，但仍需兼容带有 <code>.b</code> 后缀的指令，如 <code>ls</code> 与 <code>ls.b</code> 都应能够正确列出当前目录下的文件。<br>只需要在第一次打开文件失败后手动在prog后面添加 .b 字符再次尝试打开即可。</p>
<p><img src="/pictures/image-6.png" alt="alt text"><br><img src="/pictures/image-7.png" alt="alt text"></p>
<h3 id="实现注释功能"><a href="#实现注释功能" class="headerlink" title="实现注释功能"></a>实现注释功能</h3><p>你需要使用 <code>#</code> 实现注释功能，例如 <code>ls | cat # this is a comment meow</code>，<code>ls | cat</code> 会被正确执行，而后面的注释则会被抛弃<br>当解析输出读取到#时，会之间移动到输入的末尾，期间的内容不会被解析</p>
<p><img src="/pictures/image-8.png" alt="alt text"></p>
<h3 id="支持相对路径"><a href="#支持相对路径" class="headerlink" title="支持相对路径"></a>支持相对路径</h3><p>MOS 中现有的文件系统操作并不支持相对路径，对于一切路径都从根目录开始查找，因此在 shell 命令中也需要用绝对路径指代文件，这为命令的描述带来了不便。你需要为每个进程维护<strong>工作目录</strong>这一状态，实现相关内建指令，并为其他与路径相关的指令提供路径支持。</p>
<p>首先，为了让进程维护自己的工作路径，需要在进程控制块中加入工作路径这一成员。</p>
<p><img src="/pictures/image-9.png" alt="alt text"></p>
<p>然后在创建进程的时候，默认将进程的cwd初始化为根目录。也就是当shell被创建的时候所在的默认目录。要时刻保证进程的工作路径与实际所在路径一致。</p>
<p><img src="/pictures/image-10.png" alt="alt text"></p>
<p>之后在进行sys_exofork系统调用的时候，将新申请的进程的cwd赋值为父进程的cwd。这样做是因为，子进程是父进程创建出来的，因此子进程所在的工作路径应该与父进程保持一致，这样执行外部指令时，采用相对地址才能保持一致。</p>
<p><img src="/pictures/image-11.png" alt="alt text"></p>
<p>然后编写两个系统调用：sys_get_cwd, sys_set_cwd，分别用来获得和更新当前进程的cwd。<br>之后由于cd、pwd是内部指令，因此其应当由shell进程执行，具体过程为在shell进程中编写函数，执行cd和pwd的相关行为。</p>
<p>先判断当前指令是否是cd或者pwd，如果是的话，进入内部命令执行函数。如果当前指令是pwd，则直接输出当前工作路径即可。如果是cd，那么如果按照题目要求实现。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">execute_inner_cmd</span><span class="params">(CMDNodeData *cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;pwd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pwd: expected 0 arguments; got %d\n&quot;</span>, cmd-&gt;argc - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			syscall_get_cwd(buf);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;cd&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">char</span> finalpath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span> (cmd-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">			mystrcpy(finalpath, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">char</span> cwd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			syscall_get_cwd(cwd);</span><br><span class="line">			<span class="type">int</span> r;</span><br><span class="line">			<span class="keyword">if</span> ((r = get_final_path(cwd, cmd-&gt;argv[<span class="number">1</span>], finalpath)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//printf(&quot;absolute path: %s\n&quot;, finalpath);</span></span><br><span class="line">				syscall_set_cwd(finalpath);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: The directory &#x27;%s&#x27; does not exist\n&quot;</span>, cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cd: &#x27;%s&#x27; is not a directory\n&quot;</span>, cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;cwd or relcwd does not exists\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-2</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;path is too long\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">-3</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;fail to normalize path\n&quot;</span>);</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Too many args for cd command\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;declare&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> export_f = <span class="number">0</span>;</span><br><span class="line">       		<span class="type">int</span> readonly_f = <span class="number">0</span>;</span><br><span class="line">        	<span class="type">int</span> arg_idx = <span class="number">1</span>;</span><br><span class="line">        	<span class="type">char</span> *name_val_pair = <span class="literal">NULL</span>;</span><br><span class="line">        	<span class="comment">// Parse flags</span></span><br><span class="line">        	<span class="keyword">while</span> (cmd-&gt;argv[arg_idx] &amp;&amp; cmd-&gt;argv[arg_idx][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            		<span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-x&quot;</span>) == <span class="number">0</span>) export_f = <span class="number">1</span>;</span><br><span class="line">            		<span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-r&quot;</span>) == <span class="number">0</span>) readonly_f = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-xr&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">				 mystrcmp(cmd-&gt;argv[arg_idx], <span class="string">&quot;-rx&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				export_f = <span class="number">1</span>;</span><br><span class="line">				readonly_f = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            		<span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="built_in">printf</span>(<span class="string">&quot;declare: invalid option %s\n&quot;</span>, cmd-&gt;argv[arg_idx]);</span><br><span class="line">                		<span class="keyword">return</span>; <span class="comment">// Indicate error if builtins had return values</span></span><br><span class="line">            		&#125;</span><br><span class="line">            		arg_idx++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (cmd-&gt;argv[arg_idx]) &#123; <span class="comment">// NAME[=VALUE] part</span></span><br><span class="line">            		name_val_pair = cmd-&gt;argv[arg_idx];</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> (!name_val_pair) &#123; <span class="comment">// Just &quot;declare&quot; or &quot;declare -xr&quot;</span></span><br><span class="line">            		print_all_variables();</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            		<span class="type">char</span> name[MAX_VAR_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">            		<span class="type">char</span> value_buf[MAX_VAR_VALUE_LEN + <span class="number">1</span>]; <span class="comment">// Buffer for value if parsed</span></span><br><span class="line">            		<span class="type">char</span> *value_ptr = <span class="literal">NULL</span>;</span><br><span class="line">            		<span class="type">char</span> *eq_ptr = <span class="built_in">strchr</span>(name_val_pair, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">            		<span class="keyword">if</span> (eq_ptr) &#123; <span class="comment">// NAME=VALUE</span></span><br><span class="line">                		<span class="type">int</span> name_len = eq_ptr - name_val_pair;</span><br><span class="line">                		<span class="keyword">if</span> (name_len &gt; MAX_VAR_NAME_LEN) &#123; <span class="comment">/* error */</span> <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrncpy(name, name_val_pair, name_len);</span><br><span class="line">                		name[name_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                		value_ptr = eq_ptr + <span class="number">1</span>; <span class="comment">// Can be empty string</span></span><br><span class="line">                		<span class="keyword">if</span> (mystrlen(value_ptr) &gt; MAX_VAR_VALUE_LEN) &#123; <span class="comment">/* error */</span> <span class="keyword">return</span>; &#125;</span><br><span class="line">                		mystrcpy(value_buf, value_ptr);</span><br><span class="line">                		value_ptr = value_buf;</span><br><span class="line">            		&#125; <span class="keyword">else</span> &#123; <span class="comment">// Just NAME</span></span><br><span class="line">                		<span class="keyword">if</span> (mystrlen(name_val_pair) &gt; MAX_VAR_NAME_LEN) &#123; <span class="comment">/* error */</span> <span class="keyword">return</span>; &#125;</span><br><span class="line">                			mystrcpy(name, name_val_pair);</span><br><span class="line">                			value_ptr = <span class="string">&quot;&quot;</span>; <span class="comment">// Default to empty string</span></span><br><span class="line">            		&#125;</span><br><span class="line">            		set_variable(name, value_ptr, export_f, readonly_f, <span class="number">1</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;unset&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (cmd-&gt;argc != <span class="number">2</span>) &#123;</span><br><span class="line">            		<span class="built_in">printf</span>(<span class="string">&quot;unset: usage: unset NAME\n&quot;</span>);</span><br><span class="line">            		<span class="keyword">return</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	unset_variable(cmd-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cmd-&gt;argv[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"> 		<span class="keyword">if</span> (cmd-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">&quot;history: too many arguments\n&quot;</span>);</span><br><span class="line">        		<span class="keyword">return</span>; <span class="comment">// Or return an error code for builtins</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="type">int</span> start_idx;</span><br><span class="line">    		<span class="keyword">if</span> (history_count == <span class="number">0</span>) &#123;</span><br><span class="line">        		<span class="keyword">return</span>; <span class="comment">// Nothing to print</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> (history_count &lt; HISTFILESIZE) &#123;</span><br><span class="line">        		start_idx = <span class="number">0</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		start_idx = history_add_idx; <span class="comment">// Oldest is where next add would go</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; history_count; ++i) &#123;</span><br><span class="line">        		<span class="type">int</span> current_entry_idx = (start_idx + i) % HISTFILESIZE;</span><br><span class="line">        		<span class="comment">// Bash history usually prints with line numbers. For MOS, just the command.</span></span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, history_lines[current_entry_idx]);</span><br><span class="line">    		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键是利用当前工作路径和传入的路径参数计算绝对路径，函数如下：</p>
<p>核心思路是先检验传入的path开头是否是&#x2F;，如果是说明传入的就是绝对路径，那么直接使用即可，如果不是说明是绝对路径，此时需要进行拼接。进行拼接的操作是，先将当前工作路径和传入的相对路径进行字符串拼接，之后进行路径标准化。</p>
<p>路径标准化的方式是，遇到.&#x2F;可以去掉，遇到..&#x2F;则去掉上一级目录，如果没有上一级则保留根目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_final_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cwd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *finalpath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cwd || !path || !finalpath) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Invalid arguments</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> constructed_path[MAXPATHLEN * <span class="number">2</span>]; <span class="comment">// Intermediate buffer for path construction</span></span><br><span class="line">    <span class="comment">// 1. Determine if &#x27;path&#x27; is absolute or relative and construct initial full path</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// Absolute path</span></span><br><span class="line">        <span class="keyword">if</span> (mystrlen(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Error: Absolute path too long.\n&quot;); // Optional debug</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// Path too long</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcpy(constructed_path, path);</span><br><span class="line">        <span class="comment">// As per your spec: &quot;绝对路径，此时将这个绝对路径复制到第三个参数finalpath即可，返回0&quot;</span></span><br><span class="line">        <span class="comment">// This means no stat check for absolute paths here.</span></span><br><span class="line">        <span class="comment">// Normalization is still good practice.</span></span><br><span class="line">	<span class="comment">//printf(&quot;rel is abs, raw finalpath: %s\n&quot;, constructed_path);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Relative path</span></span><br><span class="line">        <span class="comment">// Construct full path: cwd + &quot;/&quot; + path</span></span><br><span class="line">        <span class="keyword">if</span> (mystrlen(cwd) + <span class="number">1</span> + mystrlen(path) + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(constructed_path)) &#123; <span class="comment">// +1 for potential slash, +1 for null</span></span><br><span class="line">            <span class="comment">// printf(&quot;Error: Constructed relative path too long.\n&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mystrcpy(constructed_path, cwd);</span><br><span class="line">        <span class="comment">// Add slash if cwd is not &quot;/&quot; and path is not empty</span></span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span> &amp;&amp; constructed_path[mystrlen(constructed_path) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            mystrcat(constructed_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span> &amp;&amp; mystrlen(constructed_path) &gt; <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="comment">// If cwd was &quot;/&quot; and something got appended making it &quot;//path&quot;, fix to &quot;/path&quot;</span></span><br><span class="line">            <span class="comment">// This case is usually handled by normalize_path later.</span></span><br><span class="line">            <span class="comment">// More simply, if cwd is &quot;/&quot;, just don&#x27;t add another slash if path is not empty.</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcat(constructed_path, path);</span><br><span class="line">	<span class="comment">//printf(&quot;rel is rel, raw finalpath: %s\n&quot;, constructed_path);</span></span><br><span class="line">        <span class="comment">// Normalize the constructed path (handles &quot;.&quot;, &quot;..&quot;, &quot;//&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (normalize_path(constructed_path) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Error: Failed to normalize constructed path &#x27;%s&#x27;\n&quot;, temp_path);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>; <span class="comment">// Normalization error</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For relative paths, after normalization, perform stat check</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">        <span class="type">int</span> r_stat = stat(constructed_path, &amp;st); <span class="comment">// stat uses the (now absolute) constructed_path</span></span><br><span class="line">        <span class="keyword">if</span> (r_stat &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Error from stat typically means not found (check specific error codes if MOS stat provides them)</span></span><br><span class="line">            <span class="comment">// Assuming -E_NOT_FOUND or similar is returned by stat()</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// &quot;does not exist&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.st_isdir == <span class="number">0</span>) &#123; <span class="comment">// FTYPE_DIR is 1, regular file is 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// &quot;is not a directory&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Path exists and is a directory</span></span><br><span class="line">        mystrcpy(finalpath, constructed_path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Success</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normalize_path function (copied from previous response for completeness if not in a shared lib)</span></span><br><span class="line"><span class="comment">// Ensure MAXNAMELEN and MAXPATHLEN are defined (typically from fs.h)</span></span><br><span class="line"><span class="comment">// Ensure mystrcmp, mystrncpy, mymemcpy, mystrlen are available</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">normalize_path</span><span class="params">(<span class="type">char</span> *path_buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path_buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> components[MAX_CMD_ARGS][MAXNAMELEN]; </span><br><span class="line">    <span class="type">int</span> comp_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = path_buf;</span><br><span class="line">    <span class="type">int</span> is_absolute = (*p == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="comment">// Phase 1: Parse into components, handling &quot;.&quot; and &quot;..&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        p++; </span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="type">char</span> current_comp_val[MAXNAMELEN];</span><br><span class="line">        <span class="type">char</span> *c_ptr = current_comp_val;</span><br><span class="line">        <span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c_ptr - current_comp_val &lt; MAXNAMELEN - <span class="number">1</span>) *c_ptr++ = *p;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        *c_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &gt; <span class="number">0</span> &amp;&amp; mystrcmp(components[comp_idx - <span class="number">1</span>], <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                comp_idx--; <span class="comment">// Pop if last wasn&#x27;t &quot;..&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute) &#123; <span class="comment">// Relative path: push &quot;..&quot; or if stack top is &quot;..&quot; push another</span></span><br><span class="line">                <span class="keyword">if</span> (comp_idx &lt; MAX_CMD_ARGS) mystrncpy(components[comp_idx++], <span class="string">&quot;..&quot;</span>, MAXNAMELEN<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH; <span class="comment">// Path too complex/long</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If absolute and comp_idx is 0 (or was &quot;..&quot;), &quot;..&quot; from root is ignored or handled by pop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; current_comp_val[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &lt; MAX_CMD_ARGS) mystrncpy(components[comp_idx++], current_comp_val, MAXNAMELEN<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Phase 2: Reconstruct the path from components</span></span><br><span class="line">    <span class="type">char</span> *write_ptr = path_buf;</span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; comp_idx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123; <span class="comment">// Need a separator for components after the first</span></span><br><span class="line">            <span class="keyword">if</span> (write_ptr - path_buf &gt;= MAXPATHLEN - <span class="number">1</span>) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">            *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// First component of a relative path, no leading slash needed from here.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &amp;&amp; write_ptr == path_buf + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Absolute path, first component after root &#x27;/&#x27;, no extra slash if write_ptr is right after it.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = mystrlen(components[i]);</span><br><span class="line">        <span class="keyword">if</span> ((write_ptr - path_buf) + len &gt;= MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        <span class="built_in">memcpy</span>(write_ptr, components[i], len);</span><br><span class="line">        write_ptr += len;</span><br><span class="line">    &#125;</span><br><span class="line">    *write_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// Final fixups for empty or root results</span></span><br><span class="line">    <span class="keyword">if</span> (path_buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_absolute) mystrcpy(path_buf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> mystrcpy(path_buf, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; path_buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path_buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; comp_idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This case means something like &quot;/foo/..&quot; resolved to &quot;/&quot;.</span></span><br><span class="line">        <span class="comment">// If comp_idx is &gt; 0, it means there *were* components that simplified away.</span></span><br><span class="line">        <span class="comment">// If comp_idx became 0 (e.g. /.. or /foo/..), path_buf should correctly be just &quot;/&quot;</span></span><br><span class="line">        <span class="comment">// No specific action needed here if reconstruction is correct.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; write_ptr == path_buf) &#123; </span><br><span class="line">        <span class="comment">// This can happen if input was &quot;/&quot; and comp_idx remained 0.</span></span><br><span class="line">        <span class="comment">// Ensure it&#x27;s at least &quot;/&quot;.</span></span><br><span class="line">        path_buf[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>; path_buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，由于外部指令也需要实现相对路径，因此要确保外部指令在open的时候能够正确打开绝对路径。因此需要改写open函数，在open刚开始的时候，需要先获取当前工作路径并进行路径拼接，之后再利用拼接好的绝对路径来在磁盘中访问文件。</p>
<h3 id="环境变量管理"><a href="#环境变量管理" class="headerlink" title="环境变量管理"></a>环境变量管理</h3><p>MOS 中的Shell目前并不支持环境变量,你需要在shell中增加对环境变量的支持。</p>
<p>规定环境变量在命令中以<code>$</code>开头，名称与C语言变量命名要求，且长度不超过16，环境变量的值长度同样不超过16。环境变量可分为局部变量与非局部变量，仅非局部变量可传入子Shell中，并且只有非只读变量可被修改。</p>
<p><strong>核心数据结构与变量:</strong></p>
<ul>
<li><p><strong>ShellVar shell_vars[MAX_SHELL_VARS];</strong>: 这是实现环境变量管理的核心。它是一个结构体数组，每个 ShellVar 结构体代表一个变量。</p>
<ul>
<li><p>name[MAX_VAR_NAME_LEN + 1]: 变量名。</p>
</li>
<li><p>value[MAX_VAR_VALUE_LEN + 1]: 变量值。</p>
</li>
<li><p>is_exported: 一个标志，表示变量是否为环境变量（非局部变量）。1 表示是环境变量，0 表示是局部变量。</p>
</li>
<li><p>is_readonly: 一个标志，表示变量是否为只读。1 表示只读，0 表示可写。</p>
</li>
<li><p>is_set: 一个标志，表示该 ShellVar 槽是否被使用（即是否设置了变量）。</p>
</li>
</ul>
</li>
<li><p><strong>num_set_vars</strong>: 记录当前已设置的变量数量，用于快速判断是否满了。</p>
</li>
<li><p><strong>expansion_buffer_pool 和 expansion_buffer_pool_index</strong>: 用于存储变量展开后的临时结果。get_expansion_buffer 函数从池中获取一个缓冲区供 expand_string_variables 使用。</p>
</li>
</ul>
<p><strong>实现的功能与对应代码分析:</strong></p>
<ol>
<li><p><strong>变量创建与查找 (find_variable, find_free_slot, set_variable)</strong></p>
<ul>
<li><p>**find_variable(const char *name)**:</p>
<ul>
<li><p>遍历 shell_vars 数组。</p>
</li>
<li><p>如果找到一个槽 is_set 为 1 且 name 与输入 name 相符，则返回指向该 ShellVar 结构体的指针。</p>
</li>
<li><p>否则返回 NULL。</p>
</li>
</ul>
</li>
<li><p><strong>find_free_slot()</strong>:</p>
<ul>
<li><p>遍历 shell_vars 数组，寻找第一个 is_set 为 0 的槽。</p>
</li>
<li><p>返回指向该空槽的指针。如果所有槽都已使用，返回 NULL。</p>
</li>
</ul>
</li>
<li><p>**set_variable(const char *name, const char *value, int export_flag, int readonly_flag, int update_flags_if_exists)**:</p>
<ul>
<li><p><strong>名称和值长度检查</strong>: 检查 name 和 value 的长度是否超过 MAX_VAR_NAME_LEN 和 MAX_VAR_VALUE_LEN。</p>
</li>
<li><p><strong>查找变量</strong>: 首先调用 find_variable 检查变量是否已存在。</p>
</li>
<li><p><strong>修改现有变量</strong>:</p>
<ul>
<li><p>如果变量存在且是只读的 (var-&gt;is_readonly &#x3D;&#x3D; 1)，则不允许修改，打印错误信息并返回 -1。</p>
</li>
<li><p>如果变量存在且可写，则更新其 value。</p>
</li>
<li><p>如果 update_flags_if_exists 为真，则更新 is_exported 和 is_readonly 标志。注意，这里只允许将变量设置为只读，不能从只读变为可写（因为上面的 is_readonly 检查已经捕获了尝试修改只读变量值的情况）。</p>
</li>
</ul>
</li>
<li><p><strong>创建新变量</strong>:</p>
<ul>
<li><p>如果变量不存在，则调用 find_free_slot 寻找空槽。</p>
</li>
<li><p>如果找到空槽，则填充 name、value、is_exported、is_readonly，并将 is_set 设置为 1。</p>
</li>
<li><p>num_set_vars 递增。</p>
</li>
<li><p>如果找不到空槽，打印错误信息并返回 -1。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>变量删除 (unset_variable)</strong></p>
<ul>
<li><p>**unset_variable(const char *name)**:</p>
<ul>
<li><p>调用 find_variable 查找变量。</p>
</li>
<li><p>如果变量不存在，打印错误信息并返回 -1。</p>
</li>
<li><p>如果变量存在但 is_readonly 为 1，打印错误信息（不可删除只读变量）并返回 -1。</p>
</li>
<li><p>如果变量存在且可删除，则将其 is_set 设置为 0，清空 name（方便 find_free_slot），并递减 num_set_vars。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>显示所有变量 (print_all_variables)</strong></p>
<ul>
<li><p><strong>print_all_variables()</strong>:</p>
<ul>
<li>遍历 shell_vars 数组。</li>
<li>对于每个 is_set 为 1 的变量，按照 &lt;var&gt;&#x3D;&lt;val&gt; 的格式打印其 name 和 value。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>变量展开 (expand_string_variables, get_variable_value)</strong></p>
<ul>
<li><p><strong>get_variable_value(const char *name)</strong>:</p>
<ul>
<li>非常简单：查找变量，如果找到并已设置，返回其 value 指针；否则返回 NULL。</li>
</ul>
</li>
<li><p>**expand_string_variables(char *input_str)**:</p>
<ul>
<li><p>这是处理 $VAR 语法的核心。</p>
</li>
<li><p>**检查是否有 ‘</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">′∗∗:如果输入字符串中没有‘′∗∗:如果输入字符串中没有‘</span><br></pre></td></tr></table></figure>
<p>  &#96;，直接复制一份原字符串并返回（避免修改原始字符串，并从池中分配）。</p>
</li>
<li><p><strong>逐字符扫描</strong>:</p>
<ul>
<li><p>遇到 $ 时：</p>
<ul>
<li><p>跳过 $。</p>
</li>
<li><p><strong>解析变量名</strong>: 从 $ 后开始，读取符合变量命名规则的字符（这里允许字母、数字、下划线，直到遇到空格、$、操作符或字符串结束，且不超过 MAX_VAR_NAME_LEN）。</p>
</li>
<li><p><strong>查找变量值</strong>: 调用 get_variable_value 获取变量名对应的值。</p>
</li>
<li><p><strong>追加到输出</strong>: 如果找到变量值，将其追加到输出缓冲区。如果变量不存在，则什么也不追加（相当于展开为空）。</p>
</li>
<li><p><strong>处理单个 $</strong>: 如果 $ 后没有有效变量名（例如 $$ 或 $ 后面紧跟分隔符），则将 $ 字面量添加到输出。</p>
</li>
</ul>
</li>
<li><p>遇到非 $ 字符时：</p>
<ul>
<li>直接将其追加到输出缓冲区。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>缓冲区管理</strong>: 使用 get_expansion_buffer() 从池中获取缓冲区，并检查是否会溢出 MAX_EXPANDED_STR_LEN。</p>
</li>
<li><p><strong>结果返回</strong>: 返回一个指向已展开字符串的指针（在 expansion_buffer_pool 中）。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>环境变量继承与子 Shell (main 函数中 spawn 相关的部分, execute_ast 中 NODE_COMMAND 的 child 进程部分)</strong></p>
<ul>
<li><p><strong>main 函数 (处理传递给 sh.b 的参数)</strong>:</p>
<ul>
<li><p>在 main 函数的开头，当解析到参数列表时，代码遍历 argv。</p>
</li>
<li><p>它检查形如 NAME&#x3D;VALUE 的参数，并将其视为从父 Shell 传递过来的环境变量。</p>
</li>
<li><p>对于这些参数，它会解析出 NAME 和 VALUE，并调用 set_variable 将它们设置为<strong>环境变量</strong> (is_exported &#x3D; 1)，并且<strong>不是只读</strong> (is_readonly &#x3D; 0，除非参数以 ‘1’ 开头，但这个逻辑不太符合标准环境变量传递方式，可能是特定实现)。</p>
</li>
</ul>
</li>
<li><p><strong>execute_ast (处理 NODE_COMMAND)</strong>:</p>
<ul>
<li><p>当执行一个 NODE_COMMAND 节点时，如果是执行 sh.b 或 sh 命令本身：</p>
<ul>
<li><p>它会准备一个 spawn_argv 数组。</p>
</li>
<li><p>首先复制命令和它的参数。</p>
</li>
<li><p>然后，它遍历 shell_vars 数组，查找所有 is_exported 为 1 的变量。</p>
</li>
<li><p>对于每一个导出的环境变量，它会构建一个 “NAME&#x3D;VALUE” 的字符串（<strong>这里有一个小问题，代码中 env_str_pool 的构建逻辑似乎是 strcat(current_env_str, “1”); 然后 strcat(current_env_str, shell_vars[i].name); … 看起来像是把 is_readonly 标志放在了环境变量字符串的开头，这可能不是标准方式，标准是直接传 NAME&#x3D;VALUE，父进程的 envp 数组包含这些。但对于子 shell 的 spawn 函数来说，只要它能正确解析，就可以工作。</strong>）。</p>
</li>
<li><p>将这些 “NAME&#x3D;VALUE” 字符串添加到 spawn_argv 中，最后以 NULL 结束。</p>
</li>
<li><p>最后调用 spawn(cmd-&gt;argv[0], spawn_argv)，这将创建一个子进程，并将这些环境变量作为子进程的环境传递（通常 spawn 函数会处理 argv 的格式来设置子进程的环境）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结实现情况:</strong></p>
<ul>
<li><p><strong>环境变量管理 (局部&#x2F;环境变量, 读写性)</strong>: <strong>已实现</strong>。通过 ShellVar 结构体的 is_exported 和 is_readonly 标志以及 set_variable 函数来管理。</p>
</li>
<li><p><strong>declare 内建指令</strong>: <strong>已实现</strong>。</p>
<ul>
<li><p>支持 -x (is_exported) 和 -r (is_readonly) 标志。</p>
</li>
<li><p>支持 NAME[&#x3D;VALUE] 格式的设置。</p>
</li>
<li><p>支持缺省 VALUE 为空字符串。</p>
</li>
<li><p>支持只输入 declare 显示所有变量。</p>
</li>
<li><p><strong>注意</strong>: 对于 declare 输出所有变量部分，它只打印 name&#x3D;value，没有显示 export 或 readonly 标记。</p>
</li>
</ul>
</li>
<li><p><strong>unset 内建指令</strong>: <strong>已实现</strong>。</p>
<ul>
<li><p>支持删除非只读变量。</p>
</li>
<li><p>对只读变量的操作会报错。</p>
</li>
</ul>
</li>
<li><p><strong>变量展开 ($NAME)</strong>: <strong>已实现</strong>。在 expand_string_variables 函数中完成，能够处理 $VAR，并从环境变量池中取值。支持对文件名和命令参数中的变量进行展开。</p>
</li>
<li><p><strong>环境变量继承</strong>: <strong>已实现</strong>。在子 Shell (sh.b) 启动时，将导出的变量以 NAME&#x3D;VALUE 的形式传递给 spawn 函数。</p>
</li>
<li><p><strong>子 Shell 修改环境变量不影响父 Shell</strong>: <strong>已实现</strong>。当子 Shell 修改或添加其自己的变量时，这些修改只发生在子 Shell 的进程空间内，不会影响父 Shell 的 shell_vars 数组。父 Shell 在执行完子进程后（通过 wait）继续自己的 shell_vars。</p>
</li>
<li><p><strong>只读变量的修改和删除限制</strong>: <strong>已实现</strong>。在 set_variable 和 unset_variable 中都有相应的检查。</p>
</li>
</ul>
<p><strong>潜在的改进或注意事项:</strong></p>
<ul>
<li><strong>declare 输出格式</strong>: print_all_variables 可以修改以更像 bash，显示 export 和 readonly 等修饰符。</li>
</ul>
<h3 id="指令自由输入"><a href="#指令自由输入" class="headerlink" title="指令自由输入"></a>指令自由输入</h3><p>现有的 shell 不支持在输入命令时移动光标。你需要实现：键入命令时，可以使用 Left 和 Right 移动光标位置，并可以在当前光标位置进行字符的增加与删除。要求每次在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。</p>
<p><strong>实现机制分析:</strong></p>
<ol>
<li><p><strong>缓冲区与光标管理:</strong></p>
<ul>
<li><p>buf: 存储用户当前输入的命令字符串。</p>
</li>
<li><p>n: buf 的总大小。</p>
</li>
<li><p>current_len: 当前 buf 中已输入的字符数量。</p>
</li>
<li><p>cursor_pos: 当前光标在 buf 中的位置（从 0 开始，表示在第一个字符之前）。</p>
</li>
<li><p>onscreen_cmd_len: 记录了上次在屏幕上显示了多少个命令字符。这对于正确地擦除旧内容（通过打印空格）和定位光标非常重要。</p>
</li>
</ul>
</li>
<li><p><strong>按键读取与分类:</strong></p>
<ul>
<li><p>read(0, &amp;c, 1): 这是核心的输入读取操作，每次读取一个字节（一个字符）。</p>
</li>
<li><p><strong>特殊字符处理</strong>: 代码对各种按键进行了分类处理：</p>
<ul>
<li><p><strong>0x1b (ESC 序列)</strong>: 用于处理方向键 (Left, Right, Up, Down) 和其他特殊组合键。</p>
<ul>
<li><p>读取完 ESC (0x1b) 后，会尝试读取接下来的两个字符 (seq[0], seq[1]) 来识别具体的控制序列。</p>
</li>
<li><p>seq[1] &#x3D;&#x3D; ‘A’ (Up Arrow): 触发历史记录向上浏览（后面会详细讲）。</p>
</li>
<li><p>seq[1] &#x3D;&#x3D; ‘B’ (Down Arrow): 触发历史记录向下浏览。</p>
</li>
<li><p>seq[1] &#x3D;&#x3D; ‘D’ (Left Arrow): 将 cursor_pos 减 1，如果 cursor_pos &gt; 0。</p>
</li>
<li><p>seq[1] &#x3D;&#x3D; ‘C’ (Right Arrow): 将 cursor_pos 加 1，如果 cursor_pos &lt; current_len。</p>
</li>
</ul>
</li>
<li><p><strong>\b 或 0x7f (Backspace&#x2F;Delete)</strong>:</p>
<ul>
<li><p>如果光标不在行首 (cursor_pos &gt; 0)：</p>
<ul>
<li><p>使用 mymemmove 将光标位置后的所有字符向前移动一位，覆盖掉被删除的字符。</p>
</li>
<li><p>current_len 减 1。</p>
</li>
<li><p>cursor_pos 减 1。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1 以便重新绘制。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>\r 或 \n (回车)</strong>:</p>
<ul>
<li><p>表示命令输入完成。</p>
</li>
<li><p>将 buf 的当前内容保存到 current_typed_line（用于下次输入时恢复）。</p>
</li>
<li><p>调用 add_to_history 和 save_history。</p>
</li>
<li><p>返回 readline 函数，将 buf 的内容传递给解析器。</p>
</li>
</ul>
</li>
<li><p><strong>可打印字符 ( c &gt;&#x3D; 0x20 &amp;&amp; c &lt; 0x7f)</strong>:</p>
<ul>
<li><p>如果光标不在行尾 (cursor_pos &lt; current_len)：</p>
<ul>
<li>使用 mymemmove 将光标位置及之后的字符向后移动一位，为新字符腾出空间。</li>
</ul>
</li>
<li><p>将新字符 c 插入到 buf[cursor_pos]。</p>
</li>
<li><p>current_len 加 1。</p>
</li>
<li><p>cursor_pos 加 1。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p><strong>其他特殊控制键</strong>: 代码还处理了一些常见的编辑组合键，如 Ctrl+A (移到行首), Ctrl+E (移到行尾), Ctrl+K (剪切到行尾), Ctrl+U (剪切到行首), Ctrl+W (删除一个词)。这些功能也依赖于 cursor_pos 和 mymemmove 来修改 buf。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>完整回显 (requires_full_reprint 和屏幕刷新逻辑)</strong>:</p>
<ul>
<li><p>每当输入导致 buf 内容发生变化（插入、删除、移动光标）时，requires_full_reprint 标志会被设置为 1。</p>
</li>
<li><p>在每次循环的结尾，如果 requires_full_reprint 为真并且 interactive 为真：</p>
<ul>
<li><p><strong>printf(“\r”);</strong>: 将光标移动到当前行的开头。</p>
</li>
<li><p><strong>printf(“$ “);</strong>: 重新打印提示符。</p>
</li>
<li><p><strong>打印命令内容</strong>: 遍历 buf 中当前长度的字符并打印出来。</p>
</li>
<li><p><strong>擦除多余字符</strong>: 如果当前输入的命令比上次显示的内容短 (current_len &lt; onscreen_cmd_len)，则需要打印空格来覆盖掉旧的（现在不存在的）字符。</p>
</li>
<li><p><strong>定位光标</strong>:</p>
<ul>
<li><p>effective_displayed_cmd_len 用于计算当前行实际显示了多少字符（包括提示符后的命令部分）。</p>
</li>
<li><p>for (u_int i &#x3D; 0; i &lt; (effective_displayed_cmd_len - cursor_pos); ++i) { printf(“\b”); }: 这是一个关键的回显技巧。它通过打印 \b (退格符) 来将光标移动到正确的位置。例如，如果命令是 ls -l，onscreen_cmd_len 是 4，current_len 是 3，cursor_pos 是 1 (在 l 和 - 之间)，那么需要回退 (4 - 1) &#x3D; 3 步，才能回到新内容的正确位置。</p>
</li>
</ul>
</li>
<li><p><strong>onscreen_cmd_len &#x3D; current_len;</strong>: 更新 onscreen_cmd_len 以便下次回显时知道屏幕上显示了多少内容。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>与历史记录的集成 (history_current_nav_offset, current_typed_line)</strong>:</p>
<ul>
<li><p>history_current_nav_offset: 当用户按下向上或向下箭头时，这个变量用于跟踪用户在历史记录中的位置。0 表示当前正在输入的行；1 表示上一条历史记录；2 表示上两条历史记录，依此类推。</p>
</li>
<li><p>current_typed_line: 当用户从历史记录中选择一条命令并开始编辑它时，readline 会将当前输入的 buf 内容复制到 current_typed_line。这使得用户可以“退出”历史记录浏览模式，回到编辑当前输入行。</p>
</li>
<li><p><strong>历史记录浏览</strong>:</p>
<ul>
<li><p>当按下向上箭头 (seq[1] &#x3D;&#x3D; ‘A’)：</p>
<ul>
<li><p>如果用户正在编辑新行 (history_current_nav_offset &#x3D;&#x3D; 0)，先将当前输入的内容保存到 current_typed_line。</p>
</li>
<li><p>如果还有更早的历史记录可供访问 (history_current_nav_offset &lt; history_count)，则 history_current_nav_offset 增加。</p>
</li>
<li><p>根据新的 history_current_nav_offset 从 history_lines 数组中计算出要显示的旧命令（利用了循环缓冲区索引的计算）。</p>
</li>
<li><p>将该历史命令复制到 buf，更新 current_len 和 cursor_pos，并设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p>当按下向下箭头 (seq[1] &#x3D;&#x3D; ‘B’)：</p>
<ul>
<li><p>如果 history_current_nav_offset &gt; 0，则 history_current_nav_offset 减小。</p>
</li>
<li><p>如果 history_current_nav_offset 变为了 0，表示用户回到了最初的 current_typed_line，此时将 current_typed_line 的内容复制回 buf。</p>
</li>
<li><p>否则，从历史记录中加载旧命令，更新 buf 和相关变量，并重绘。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结实现细节:</strong></p>
<ul>
<li><p><strong>光标移动</strong>: 通过精确控制 cursor_pos 变量，并在每次改动后使用退格符 \b 来重定位光标，实现左右光标移动。</p>
</li>
<li><p><strong>字符插入</strong>: 使用 mymemmove 将光标后的内容后移，腾出空间，然后在 buf[cursor_pos] 插入字符。</p>
</li>
<li><p><strong>字符删除</strong>: 使用 mymemmove 将光标后的内容前移，覆盖被删除字符。</p>
</li>
<li><p><strong>完整回显</strong>: 通过 onscreen_cmd_len 和 requires_full_reprint 标志，在每次输入改动后，重新绘制整个命令行的内容，并精确地将光标放回正确位置。这保证了用户看到的是一个连续的、正确的编辑界面。</p>
</li>
<li><p><strong>历史记录集成</strong>: 通过 history_current_nav_offset 和 current_typed_line 实现了在输入行和历史记录之间的切换和编辑。</p>
</li>
</ul>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>你需要在Shell中实现以下快捷键:<br>快捷键行为:<br>left-arrow    光标尝试向左移动，如果可以移动则移动<br>right-arrow    光标尝试向右移动，如果可以移动则移动<br>backspace    删除光标左侧 1 个字符并将光标向左移动 1 列；若已在行首则无动作<br>Ctrl-E    光标跳至最后<br>Ctrl-A    光标跳至最前<br>Ctrl-K    删除从当前光标处到最后的文本<br>Ctrl-U    删除从最开始到光标前的文本<br>Ctrl-W    向左删除最近一个 word：先越过空白(如果有)，再删除连续非空白字符</p>
<p>*<em>核心函数: readline(char <em>buf, u_int n, int interactive)</em></em></p>
<p>这个函数是处理所有用户输入的入口，它负责识别按键，执行相应的操作，并在必要时更新屏幕显示。</p>
<p><strong>快捷键实现分析:</strong></p>
<ol>
<li><p><strong>光标移动 (Left&#x2F;Right Arrow)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x1b (ESC), seq[0] &#x3D;&#x3D; ‘[‘, seq[1] &#x3D;&#x3D; ‘D’ (Left) 或 ‘C’ (Right)。</p>
</li>
<li><p><strong>Left Arrow (seq[1] &#x3D;&#x3D; ‘D’)</strong>:</p>
<ul>
<li><p>检查 cursor_pos &gt; 0。</p>
</li>
<li><p>如果条件为真，则 cursor_pos–。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1，表示屏幕需要重绘以反映光标位置的变化。</p>
</li>
</ul>
</li>
<li><p><strong>Right Arrow (seq[1] &#x3D;&#x3D; ‘C’)</strong>:</p>
<ul>
<li><p>检查 cursor_pos &lt; current_len。</p>
</li>
<li><p>如果条件为真，则 cursor_pos++。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: requires_full_reprint 标志会在循环末尾触发屏幕重绘，根据新的 cursor_pos 定位光标，确保用户看到正确的显示。</p>
</li>
</ul>
</li>
<li><p><strong>Backspace (删除光标左侧字符)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; ‘\b’ 或 c &#x3D;&#x3D; 0x7f (通常是 Backspace 或 Delete 键)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>首先检查 history_current_nav_offset !&#x3D; 0。如果用户正在浏览历史记录，按下 Backspace 会将其从历史记录模式切换回正常编辑模式，并将当前显示的历史记录复制到 current_typed_line。这是一个重要的 UX 考虑。</p>
</li>
<li><p>检查 cursor_pos &gt; 0 (确保不在行首)。</p>
</li>
<li><p>如果光标不在行首：</p>
<ul>
<li><p>mymemmove(&amp;buf[cursor_pos - 1], &amp;buf[cursor_pos], current_len - cursor_pos + 1): 这是核心操作。它将光标位置 cursor_pos 处的字符（包括光标本身）以及之后的所有字符，向前移动一个位置。这effectively抹去了光标左侧的字符。</p>
</li>
<li><p>cursor_pos–: 光标位置随之向左移动一位。</p>
</li>
<li><p>current_len–: 输入的字符总数减少一个。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>行首处理</strong>: 如果 cursor_pos &#x3D;&#x3D; 0，则 Backspace 键被忽略，不做任何操作。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-E (光标跳至最后)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x05 (Ctrl-E 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>检查 cursor_pos !&#x3D; current_len。</p>
</li>
<li><p>如果光标不在行尾，则 cursor_pos &#x3D; current_len。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，光标会直接定位到行尾。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-A (光标跳至最前)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x01 (Ctrl-A 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>检查 cursor_pos !&#x3D; 0。</p>
</li>
<li><p>如果光标不在行首，则 cursor_pos &#x3D; 0。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，光标会直接定位到行首。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-K (删除从当前光标处到最后的文本)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x0B (Ctrl-K 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>首先，检查用户是否在浏览历史记录，如果是，则将其切换到正常编辑模式（同 Backspace）。</p>
</li>
<li><p>检查 cursor_pos &lt; current_len。</p>
</li>
<li><p>如果光标不在行尾（即有文本可删）：</p>
<ul>
<li><p>buf[cursor_pos] &#x3D; ‘\0’;: 在当前光标位置直接截断字符串，将该位置之后的所有内容视为无效。</p>
</li>
<li><p>current_len &#x3D; cursor_pos;: 更新当前字符串长度为光标位置。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，只会显示从行首到新 current_len 的内容。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-U (删除从最开始到光标前的文本)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x15 (Ctrl-U 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>首先，检查用户是否在浏览历史记录，如果是，则将其切换到正常编辑模式。</p>
</li>
<li><p>检查 cursor_pos &gt; 0。</p>
</li>
<li><p>如果光标不在行首（即有文本可删）：</p>
<ul>
<li><p>mymemmove(&amp;buf[0], &amp;buf[cursor_pos], current_len - cursor_pos + 1);: 这是核心操作。它将光标位置 cursor_pos 开始的所有字符（包括光标位置后的文本），移动到缓冲区的开头 (buf[0])。这 effectively 丢弃了光标之前（包括光标位置前的）的所有字符。</p>
</li>
<li><p>current_len -&#x3D; cursor_pos;: 更新当前字符串长度，减去被删除的字符数量。</p>
</li>
<li><p>cursor_pos &#x3D; 0;: 光标被重置到行首，因为所有内容都从那里开始显示了。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，从 buf[0] 开始显示，并且光标定位在行首。</p>
</li>
</ul>
</li>
<li><p><strong>Ctrl-W (向左删除最近一个 word)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: c &#x3D;&#x3D; 0x17 (Ctrl-W 的 ASCII 值)。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>首先，检查用户是否在浏览历史记录，如果是，则将其切换到正常编辑模式。</p>
</li>
<li><p><strong>查找删除范围</strong>:</p>
<ul>
<li><p>original_cursor_pos &#x3D; cursor_pos;: 保存当前光标位置，以便后续处理。</p>
</li>
<li><p><strong>越过尾部空白</strong>: 从 cursor_pos 开始，向前查找第一个非空白字符 (while (cursor_pos &gt; 0 &amp;&amp; strchr(“ \t”, buf[cursor_pos - 1])) cursor_pos–;)。这一步是为了处理用户可能在词后输入了空格的情况。</p>
</li>
<li><p>end_of_deletion_span &#x3D; cursor_pos;: 记录当前光标位置（即词的末尾，或尾部空白的起始位置）。</p>
</li>
<li><p><strong>查找词的起始</strong>: 从 cursor_pos 开始，向前查找第一个空白字符 (while (start_of_word_to_delete &gt; 0 &amp;&amp; !strchr(“ \t”, buf[start_of_word_to_delete - 1])) { start_of_word_to_delete–; })。这会找到词（或词前面空白串）的起始位置。</p>
</li>
</ul>
</li>
<li><p><strong>执行删除</strong>:</p>
<ul>
<li><p>如果找到了需要删除的有效范围 (start_of_word_to_delete &lt; end_of_deletion_span)：</p>
<ul>
<li><p>mymemmove(&amp;buf[start_of_word_to_delete], &amp;buf[end_of_deletion_span], current_len - end_of_deletion_span + 1);: 将词（和它前面的空白）之后的文本移动到词的起始位置，覆盖掉词及其前面的空白。</p>
</li>
<li><p>current_len -&#x3D; (end_of_deletion_span - start_of_word_to_delete);: 更新总长度。</p>
</li>
<li><p>cursor_pos &#x3D; start_of_word_to_delete;: 将光标定位到删除区域的起始位置。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
<li><p>如果未找到有效删除范围（例如在行首或者只有空白），光标会回到 original_cursor_pos（基本上无变化）。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回显更新</strong>: 重绘时，显示被修改后的 buf，并将光标定位到删除词的起始位置。</p>
</li>
</ul>
</li>
</ol>
<p><strong>回显更新逻辑的关键点:</strong></p>
<p>requires_full_reprint 配合 onscreen_cmd_len 和退格符 \b 是实现精确回显的关键。当需要更新屏幕时：</p>
<ol>
<li><p>移动光标到行首 (\r)。</p>
</li>
<li><p>重绘提示符 ($)。</p>
</li>
<li><p>打印新的命令内容。</p>
</li>
<li><p>如果新内容比旧内容短，则打印足够多的空格来“擦除”旧内容中多余的部分。</p>
</li>
<li><p>关键是根据新光标位置，通过连续打印 \b 来将光标准确地放回显示内容的正确位置。</p>
</li>
</ol>
<h3 id="历史指令"><a href="#历史指令" class="headerlink" title="历史指令"></a>历史指令</h3><p>你需要实现 shell 中保存历史指令的功能，可以通过 Up 和 Down 选择所保存的指令并执行。你需要将历史指令保存到根目录的 <code>.mos_history</code> 文件中（一条指令一行），为了评测的方便，我们设定 <code>$HISTFILESIZE=20</code>（bash 中默认为 500），即在 <code>.mos_history</code> 中至多保存最近的 20 条指令。你还需要支持通过 <code>history</code> 命令输出 <code>.mos_history</code> 文件中的内容。</p>
<p><strong>核心数据结构与变量:</strong></p>
<ul>
<li><p><strong>HISTFILESIZE 20</strong>: 定义了历史记录文件和内存中最多保存的指令条数。</p>
</li>
<li><p><strong>HISTORY_FILE “&#x2F;.mos_history”</strong>: 定义了存储历史记录的文件路径。</p>
</li>
<li><p><strong>char history_lines[HISTFILESIZE][MAX_INPUT_BUF]</strong>: 这是一个二维字符数组，用于在内存中存储历史指令。它被实现为一个<strong>循环缓冲区</strong>。</p>
</li>
<li><p><strong>int history_count &#x3D; 0;</strong>: 当前内存中实际存储的历史指令条数。</p>
</li>
<li><p><strong>int history_add_idx &#x3D; 0;</strong>: 在循环缓冲区中，下一个要添加的新指令的索引。当缓冲区满时，这个索引会指向最旧的那个指令，新指令会覆盖它。</p>
</li>
<li><p><strong>int history_latest_idx &#x3D; -1;</strong>: 在循环缓冲区中，最近添加的指令的索引。-1 表示历史记录为空。</p>
</li>
<li><p><strong>int history_current_nav_offset &#x3D; 0;</strong>: 用户在浏览历史记录时的偏移量。</p>
<ul>
<li><p>0: 表示用户当前正在输入新的命令，或者已经回到了输入的新命令。</p>
</li>
<li><p>1: 表示用户选择的是上一条历史记录。</p>
</li>
<li><p>N: 表示用户选择的是第 N 条历史记录。</p>
</li>
</ul>
</li>
<li><p><strong>char current_typed_line[MAX_INPUT_BUF] &#x3D; {0};</strong>: 用于暂存用户在浏览历史记录时（按下 Up Arrow）之前输入的、未提交的命令。当用户按下 Down Arrow 并且 history_current_nav_offset 变为 0 时，会从这里恢复。</p>
</li>
</ul>
<p><strong>实现的功能与对应代码分析:</strong></p>
<ol>
<li><p><strong>加载历史记录 (load_history())</strong></p>
<ul>
<li><p><strong>目的</strong>: Shell 启动时，从 HISTORY_FILE 读取最近 HISTFILESIZE 条指令到内存中的 history_lines。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>打开 HISTORY_FILE (只读 O_RDONLY)。如果文件不存在或无法打开，则静默失败（不加载历史）。</p>
</li>
<li><p>逐行读取文件内容到 line_buf。</p>
</li>
<li><p>使用一个临时缓冲区 temp_history_load 来存储从文件读取的行。</p>
</li>
<li><p><strong>循环缓冲区填充逻辑</strong>:</p>
<ul>
<li><p>如果 temp_count (临时缓冲区中的条数) 小于 HISTFILESIZE，则直接添加到 temp_history_load。</p>
</li>
<li><p>如果 temp_count 达到 HISTFILESIZE，则在添加新行之前，将 temp_history_load 中的所有旧条目向前移动一位，覆盖掉最旧的条目，然后将新行添加到最后。这是一个模拟循环缓冲区的策略。</p>
</li>
</ul>
</li>
<li><p>文件读取完毕后，将 temp_history_load 中的内容按照正确的顺序（从旧到新）复制到实际的 history_lines 循环缓冲区中，并更新 history_add_idx 和 history_latest_idx。</p>
</li>
<li><p>最后，将 history_current_nav_offset 重置为 0。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>保存历史记录 (save_history())</strong></p>
<ul>
<li><p><strong>目的</strong>: Shell 退出时，将内存中的 history_lines（最新的 HISTFILESIZE 条）写回 HISTORY_FILE。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>打开 HISTORY_FILE (写模式 O_WRONLY，创建 O_CREAT，截断 O_TRUNC)。如果打开失败则打印错误。</p>
</li>
<li><p>根据 history_count 和 history_add_idx 确定历史记录的起始索引 (start_idx)。如果历史记录未满 (history_count &lt; HISTFILESIZE)，则从索引 0 开始；如果已满或溢出，则从 history_add_idx 开始（这是最旧的记录）。</p>
</li>
<li><p>从 start_idx 开始，循环 history_count 次，将 history_lines[current_entry_idx] 的内容和换行符写入文件。</p>
</li>
<li><p>关闭文件。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>*<em>添加指令到历史记录 (add_to_history(const char <em>cmd_line))</em></em></p>
<ul>
<li><p><strong>目的</strong>: 在用户执行一条指令后，将其添加到内存中的历史记录。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>忽略空命令。</p>
</li>
<li><p><strong>去重</strong>: 检查新命令是否与最后一条历史记录相同。如果相同，则不添加，避免重复项。</p>
</li>
<li><p>将新命令 cmd_line 复制到 history_lines[history_add_idx]。</p>
</li>
<li><p>更新 history_latest_idx &#x3D; history_add_idx。</p>
</li>
<li><p>更新 history_add_idx &#x3D; (history_add_idx + 1) % HISTFILESIZE，移动到下一个可用位置。</p>
</li>
<li><p>如果 history_count &lt; HISTFILESIZE，则 history_count++，表示记录数增加。</p>
</li>
<li><p><strong>重置导航状态</strong>: history_current_nav_offset &#x3D; 0，表示用户回到了当前输入的行，而不是在浏览历史记录。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用 Up&#x2F;Down Arrow 选择历史记录 (在 readline 函数中)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: 读取到 ESC 序列，并且是 ‘[‘ 后面跟着 ‘A’ (Up) 或 ‘B’ (Down)。</p>
</li>
<li><p><strong>Up Arrow (seq[1] &#x3D;&#x3D; ‘A’)</strong>:</p>
<ul>
<li><p>首先，如果用户当前正在编辑新行 (history_current_nav_offset &#x3D;&#x3D; 0)，则将 buf 的内容保存到 current_typed_line，为稍后恢复输入提供基础。</p>
</li>
<li><p>检查 history_current_nav_offset &lt; history_count。这确保了我们不会越过最早的记录。</p>
</li>
<li><p>如果可以向上浏览：</p>
<ul>
<li><p>history_current_nav_offset++。</p>
</li>
<li><p>根据新的 history_current_nav_offset 和 history_latest_idx 计算出要加载的历史记录在 history_lines 数组中的实际索引 (nav_idx_in_hist_array)。</p>
</li>
<li><p>将该历史记录复制到 buf，更新 current_len 和 cursor_pos。</p>
</li>
<li><p>设置 requires_full_reprint &#x3D; 1 以更新屏幕显示。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Down Arrow (seq[1] &#x3D;&#x3D; ‘B’)</strong>:</p>
<ul>
<li><p>检查 history_current_nav_offset &gt; 0。这确保了我们不会越过当前输入的行。</p>
</li>
<li><p>如果可以向下浏览：</p>
<ul>
<li><p>history_current_nav_offset–。</p>
</li>
<li><p>如果 history_current_nav_offset &#x3D;&#x3D; 0，表示用户回到了最初的输入行，将 current_typed_line 的内容复制回 buf。</p>
</li>
<li><p>否则（仍然在浏览历史记录），计算要加载的历史记录索引，加载并显示。</p>
</li>
<li><p>更新 buf，current_len，cursor_pos，并设置 requires_full_reprint &#x3D; 1。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>history 内建命令 (execute_inner_cmd 函数)</strong></p>
<ul>
<li><p><strong>触发条件</strong>: 当 execute_ast 检测到 NODE_COMMAND 的第一个参数是 “history” 且没有其他参数时。</p>
</li>
<li><p><strong>逻辑</strong>:</p>
<ul>
<li><p>检查 cmd-&gt;argc &gt; 1。如果命令带了除 history 之外的参数，会打印用法错误。</p>
</li>
<li><p>如果 history_count &#x3D;&#x3D; 0，则什么也不做。</p>
</li>
<li><p><strong>确定起始打印位置</strong>:</p>
<ul>
<li><p>如果 history_count &lt; HISTFILESIZE (历史记录未满)，从索引 0 开始打印。</p>
</li>
<li><p>如果 history_count &gt;&#x3D; HISTFILESIZE (历史记录已满或已循环)，则从 history_add_idx 开始打印（因为 history_add_idx 指向的是下一个要添加的位置，也就是最旧的那个元素）。</p>
</li>
</ul>
</li>
<li><p><strong>遍历并打印</strong>: 从确定的 start_idx 开始，循环 history_count 次，使用模运算 (% HISTFILESIZE) 来正确地在循环缓冲区中获取和打印每一条历史记录。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>与主循环的交互:</strong></p>
<ul>
<li><p>Shell 的主循环 (main 函数) 在每次迭代开始时：</p>
<ul>
<li><p>调用 load_history() 加载历史记录。</p>
</li>
<li><p>调用 readline() 获取用户输入。</p>
</li>
<li><p>readline 返回后，将用户的输入（可能经过历史记录选择和编辑）复制到 input_buf。</p>
</li>
<li><p>然后调用 add_to_history() 将这条输入的命令添加到内存历史记录中。</p>
</li>
<li><p>接着调用 save_history() 将最新的历史记录写回文件。</p>
</li>
</ul>
</li>
</ul>
<p><strong>总结:</strong></p>
<p>MOS Shell 通过以下方式实现了历史指令功能：</p>
<ul>
<li><p><strong>内存存储</strong>: 使用一个循环缓冲区 history_lines 在内存中保存最近的 HISTFILESIZE 条指令。</p>
</li>
<li><p><strong>文件持久化</strong>: 在启动时加载，退出时保存到 .mos_history 文件，确保历史记录的持久性。</p>
</li>
<li><p><strong>历史记录浏览</strong>: 在 readline 函数中通过解析方向键序列，利用 history_current_nav_offset 来跟踪用户在历史记录中的位置，并动态加载和显示历史命令到输入行。</p>
</li>
<li><p><strong>编辑与恢复</strong>: 使用 current_typed_line 变量，允许用户在浏览历史记录后编辑选择的命令，并将编辑后的命令作为新的当前输入行处理。</p>
</li>
<li><p><strong>history 命令</strong>: 实现了一个内建命令，可以方便地查看当前内存中的所有历史指令。</p>
</li>
</ul>
<h3 id="实现反引号"><a href="#实现反引号" class="headerlink" title="实现反引号"></a>实现反引号</h3><p>你需要使用反引号实现指令替换。你需要将反引号内指令执行的所有标准输出代替原有指令中的反引号内容。</p>
<p><strong>关键函数与逻辑:</strong></p>
<ol>
<li><p><strong>识别反引号</strong>:</p>
<ul>
<li><p>反引号  被识别为一种特殊的 TOKEN_WORD。</p>
</li>
<li><p>在 get_next_raw_token() 函数中，当遇到`时，它会捕获从开头的  到匹配的结尾  的所有内容，并将这个字符串（包括反引号）作为一个 TOKEN_WORD 返回。</p>
</li>
<li><p><strong>注意</strong>: 当前的 get_next_raw_token 实现对于反引号的识别很简单，它会把  包裹的内容作为一个单独的 TOKEN_WORD。它<strong>不处理嵌套反引号</strong>，<strong>也不处理反引号内的转义字符</strong>（例如 \ 后面跟着 ）。</p>
</li>
</ul>
</li>
<li><p><strong>命令替换的执行 (execute_command_substitution)</strong></p>
<ul>
<li><p><strong>被调用时机</strong>: 这个函数在 parse_command() 函数内部被调用。当 parse_command() 处理一个 TOKEN_WORD 时，它会先调用 expand_string_variables 来展开变量，然后对展开后的字符串执行一个<strong>二次扫描</strong>，查找其中的反引号对。</p>
</li>
<li><p><strong>get_subst_output_buffer()</strong>: 这个函数从一个预分配的缓冲区池中获取一个空缓冲区，用于存储被替换命令的输出。这限制了同时进行的命令替换的数量和单个替换输出的最大长度。</p>
</li>
<li><p><strong>创建管道</strong>: pipe(pipe_fds) 创建一个匿名管道。管道的读端 (pipe_fds[0]) 和写端 (pipe_fds[1]) 会被用来连接父 Shell 和子命令的输出。</p>
</li>
<li><p><strong>fork() 子进程</strong>:</p>
<ul>
<li><p>在父 Shell（即当前 MOS Shell 进程）中 fork() 出一个子进程。</p>
</li>
<li><p><strong>子进程</strong>:</p>
<ul>
<li><p>关闭管道的读端 (pipe_fds[0])。</p>
</li>
<li><p><strong>重定向标准输出</strong>: dup(pipe_fds[1], 1) 将子进程的标准输出文件描述符 (1) 重定向到管道的写端 (pipe_fds[1])。</p>
</li>
<li><p>关闭原始的管道写端描述符 pipe_fds[1]。</p>
</li>
<li><p><strong>执行命令</strong>: 使用 spawn(“&#x2F;sh.b”, sh_argv) 来执行一个独立的 sh.b shell 实例，并传递 -c 参数以及反引号内的实际命令字符串 (command_to_run)。这个 sh.b 进程会执行 command_to_run，并且其输出会被重定向到管道的写端。</p>
</li>
<li><p>如果 spawn 失败，子进程会打印错误并退出。</p>
</li>
</ul>
</li>
<li><p><strong>父进程</strong>:</p>
<ul>
<li><p>关闭管道的写端 (pipe_fds[1])。</p>
</li>
<li><p><strong>读取管道输出</strong>: 在一个循环中，从管道的读端 (pipe_fds[0]) 读取子进程的标准输出。每次读取一个字符 read_char，并将其追加到预先获取的缓冲区 output_buffer 中。</p>
</li>
<li><p><strong>缓冲区溢出处理</strong>: 如果输出超出了 MAX_CMD_SUBST_OUTPUT_LEN，则打印截断警告，然后丢弃管道中剩余的所有数据，以允许子进程正常结束。</p>
</li>
<li><p>在读取完成后，为 output_buffer 添加 null 终止符。</p>
</li>
<li><p>关闭管道的读端 pipe_fds[0]。</p>
</li>
<li><p><strong>wait(child_pid_for_sh_c)</strong>: 父进程等待执行 sh -c “…” 的子进程完成。</p>
</li>
<li><p><strong>后处理输出</strong>:</p>
<ul>
<li><p>移除末尾的换行符和回车符。</p>
</li>
<li><p>将内部的换行符和回车符替换为空字符 \0。这个处理方式是将多个换行符替换成多个 \0，然后 mystrcat 会将它们连接起来，最终形成一个由 \0 分隔的字符串。</p>
</li>
</ul>
</li>
<li><p>返回处理后的 output_buffer 指针。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>在 parse_command 中集成</strong>:</p>
<ul>
<li><p>当 parse_command 遇到一个 TOKEN_WORD 时，它会首先对 current_token.value 进行<strong>变量展开</strong>（调用 expand_string_variables）。</p>
</li>
<li><p>然后，对变量展开后的字符串（存储在 arg_after_var_expansion 中），进行<strong>二次扫描</strong>来处理命令替换。</p>
</li>
<li><p><strong>处理反引号</strong>:</p>
<ul>
<li><p>使用 scan_ptr 遍历字符串。</p>
</li>
<li><p>查找第一个反引号  (backtick_start)。</p>
</li>
<li><p>查找匹配的第二个反引号  (backtick_end)。</p>
</li>
<li><p>如果找到了成对的反引号：</p>
<ul>
<li><p>将反引号前的部分（scan_ptr 到 backtick_start）复制到 rebuilt_arg_buffer。</p>
</li>
<li><p>提取反引号之间的命令字符串 cmd_to_subst。</p>
</li>
<li><p>调用 execute_command_substitution(cmd_to_subst, …) 来执行命令替换。</p>
</li>
<li><p>将 execute_command_substitution 返回的（已处理的）输出追加到 rebuilt_arg_buffer。</p>
</li>
<li><p>更新 scan_ptr 到 backtick_end + 1，继续扫描。</p>
</li>
</ul>
</li>
<li><p>如果只找到开头的反引号但没有匹配的结尾反引号，则将该部分作为字面量处理。</p>
</li>
<li><p>如果字符串中没有反引号，则直接将 arg_after_var_expansion 复制到 rebuilt_arg_buffer。</p>
</li>
</ul>
</li>
<li><p>最后，将 rebuilt_arg_buffer 中的内容 user_strdup，作为最终的参数传给 cmd_data-&gt;argv。</p>
</li>
</ul>
</li>
</ol>
<p><strong>总结实现机制:</strong></p>
<ol>
<li><p><strong>标记</strong>: 反引号被 tokenizer 识别为特殊的 TOKEN_WORD。</p>
</li>
<li><p><strong>解析与处理</strong>: parse_command 在处理 TOKEN_WORD 时，先执行变量展开，然后扫描展开后的字符串，查找  对。</p>
</li>
<li><p><strong>分离命令</strong>: 反引号内的命令被提取出来。</p>
</li>
<li><p><strong>子 Shell 执行</strong>: 创建一个子进程，通过 sh -c “…” 来执行提取出的命令。</p>
</li>
<li><p><strong>输出重定向</strong>: 子进程的标准输出被重定向到一个管道。</p>
</li>
<li><p><strong>捕获输出</strong>: 父进程从管道中读取子进程的所有输出。</p>
</li>
<li><p><strong>后处理</strong>: 输出的换行符被移除或替换，然后成为最终的替换文本。</p>
</li>
<li><p><strong>组装参数</strong>: 最终的参数（包含命令替换结果的参数）被构建并传递给命令的执行。</p>
</li>
</ol>
<p><strong>局限性 (基于代码分析):</strong></p>
<ul>
<li><p><strong>无嵌套反引号支持</strong>: 如果命令中存在嵌套的反引号（例如 echoecho &#96;date&#96;&#96;），当前的实现将无法正确处理，可能会导致错误或意外行为。</p>
</li>
<li><p><strong>无转义反引号支持</strong>: 如果用户想在反引号内包含字面上的反引号（例如 echoecho a&#96;b&#96;&#96;），当前的实现会认为第二个  是结束反引号的标志，导致错误。</p>
</li>
<li><p><strong>输出缓冲区限制</strong>: MAX_CMD_SUBST_OUTPUT_LEN 和 MAX_CMD_SUBST_BUFFERS 的限制意味着不能执行产生非常大输出或在同一行有太多命令替换的命令。</p>
</li>
<li><p><strong>换行符处理</strong>: 将内部换行符替换为 \0 是一个特定实现，它会将内部的多行输出合并成一个用 \0 分隔的“单词”，然后可能被 shell 进一步解析。不同的 shell 对此行为有细微差别。</p>
</li>
</ul>
<h3 id="指令条件执行"><a href="#指令条件执行" class="headerlink" title="指令条件执行"></a>指令条件执行</h3><p>你需要实现 Linux shell 中的 <code>&amp;&amp;</code> 与 <code>||</code>。 对于 <code>command1 &amp;&amp; command2</code>，<code>command2</code> 被执行当且仅当 <code>command1</code> 返回 0；对于 <code>command1 || command2</code>，<code>command2</code> 被执行当且仅当 <code>command1</code> 返回非 0 值。</p>
<p>条件指令与反引号指令执行同理，开子进程并将指令执行的结果通过管道通信，父进程再根据条件符号的类型和返回值来判断是否运行下一个指令。</p>
<h3 id="更多指令"><a href="#更多指令" class="headerlink" title="更多指令"></a>更多指令</h3><p>你需要实现 <code>touch</code>，<code>mkdir</code>，<code>rm</code> 指令以及内建指令<code>exit</code>，只需要考虑如下情形：</p>
<ul>
<li><code>touch</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>touch &lt;file&gt;</code>：创建空文件 <code>file</code>，若文件存在则放弃创建，正常退出无输出。 若创建文件的父目录不存在则输出 <code>touch: cannot touch &#39;&lt;file&gt;&#39;: No such file or directory</code>。 例如 <code>touch nonexistent/dir/a.txt</code> 时应输出 <code>touch: cannot touch &#39;nonexistent/dir/a.txt&#39;: No such file or directory</code>。</li>
</ul>
</blockquote>
<ul>
<li><code>mkdir</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>mkdir &lt;dir&gt;</code>：若目录已存在则输出 <code>mkdir: cannot create directory &#39;&lt;dir&gt;&#39;: File exists</code>，若创建目录的父目录不存在则输出 <code>mkdir: cannot create directory &#39;&lt;dir&gt;&#39;: No such file or directory</code>，否则正常创建目录。</li>
<li><code>mkdir -p &lt;dir&gt;</code>：当使用 <code>-p</code> 选项时忽略错误，若目录已存在则直接退出，若创建目录的父目录不存在则递归创建目录。</li>
</ul>
</blockquote>
<ul>
<li><code>rm</code>:</li>
</ul>
<blockquote>
<ul>
<li><code>rm &lt;file&gt;</code>：若文件存在则删除 <code>&lt;file&gt;</code>，否则输出 <code>rm: cannot remove &#39;&lt;file&gt;&#39;: No such file or directory</code>。</li>
<li><code>rm &lt;dir&gt;</code>：命令行输出: <code>rm: cannot remove &#39;&lt;dir&gt;&#39;: Is a directory</code>。</li>
<li><code>rm -r &lt;dir&gt;|&lt;file&gt;</code>：若文件或文件夹存在则删除，否则输出 <code>rm: cannot remove &#39;&lt;dir&gt;|&lt;file&gt;&#39;: No such file or directory</code>。</li>
<li><code>rm -rf &lt;dir&gt;|&lt;file&gt;</code>：如果对应文件或文件夹存在则删除，否则直接退出。</li>
</ul>
</blockquote>
<ul>
<li>（内建指令）<code>exit</code>:执行后退出当前shell</li>
</ul>
<p>注:对于<code>rm</code>,<code>mkdir</code>,<code>touch</code>指令，若成功执行则返回0，否则返回非零值即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">touch</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open(path, O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;touch: cannot touch &#x27;%s&#x27;: No such file or directory\n&quot;</span>, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;other error when touch %s, error code is %d\n&quot;</span>, path, fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nothing to touch\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            touch(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; path[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            str[i] = path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; path[i] != <span class="string">&#x27;\0&#x27;</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                fd = open(str, O_MKDIR);</span><br><span class="line">                <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;other error when mkdir %s, error code is %d\n&quot;</span>, path, fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str[i] = path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        fd = open(str, O_MKDIR);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other error when mkdir %s, error code is %d\n&quot;</span>, path, fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mkdir: cannot create directory &#x27;%s&#x27;: File exists\n&quot;</span>, path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(path, O_MKDIR);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-10</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mkdir: cannot create directory &#x27;%s&#x27;: No such file or directory\n&quot;</span>, path);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;other error when mkdir %s, error code is %d\n&quot;</span>, path, fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">5</span>] = <span class="string">&quot;-p&quot;</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;receive mkdir command:\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	<span class="type">char</span> *p = argv[i];</span><br><span class="line">	<span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			*p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    	<span class="comment">//printf(&quot;\&quot;%s\&quot;&quot;, argv[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], s) == <span class="number">0</span>) &#123;</span><br><span class="line">            argv[i] = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nothing to mkdir\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mkdir(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag_r;</span><br><span class="line"><span class="type">int</span> flag_f;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rm</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag_f) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove &#x27;%s&#x27;: No such file or directory\n&quot;</span>, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    stat(path, &amp;st);</span><br><span class="line">    <span class="keyword">if</span> (st.st_isdir &amp;&amp; !flag_r) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove &#x27;%s&#x27;: Is a directory\n&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> cwd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    syscall_get_cwd(cwd);</span><br><span class="line">    <span class="type">char</span> finalpath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    get_final_path(cwd, path, finalpath);</span><br><span class="line">    <span class="comment">//printf(&quot;rm finalpath: %s\n&quot;, finalpath);</span></span><br><span class="line">    remove(finalpath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_final_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cwd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *finalpath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cwd || !path || !finalpath) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Invalid arguments</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> constructed_path[MAXPATHLEN * <span class="number">2</span>]; <span class="comment">// Intermediate buffer for path construction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Determine if &#x27;path&#x27; is absolute or relative and construct initial full path</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// Absolute path</span></span><br><span class="line">        <span class="keyword">if</span> (mystrlen(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Error: Absolute path too long.\n&quot;); // Optional debug</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcpy(constructed_path, path);</span><br><span class="line">        <span class="comment">// As per your spec: &quot;绝对路径，此时将这个绝对路径复制到第三个参数finalpath即可，返回0&quot;</span></span><br><span class="line">        <span class="comment">// This means no stat check for absolute paths here.</span></span><br><span class="line">        <span class="comment">// Normalization is still good practice.</span></span><br><span class="line">	<span class="comment">//printf(&quot;rel is abs, raw finalpath: %s\n&quot;, constructed_path);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Relative path</span></span><br><span class="line">        <span class="comment">// Construct full path: cwd + &quot;/&quot; + path</span></span><br><span class="line">        <span class="keyword">if</span> (mystrlen(cwd) + <span class="number">1</span> + mystrlen(path) + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(constructed_path)) &#123; <span class="comment">// +1 for potential slash, +1 for null</span></span><br><span class="line">            <span class="comment">// printf(&quot;Error: Constructed relative path too long.\n&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcpy(constructed_path, cwd);</span><br><span class="line">        <span class="comment">// Add slash if cwd is not &quot;/&quot; and path is not empty</span></span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span> &amp;&amp; constructed_path[mystrlen(constructed_path) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            mystrcat(constructed_path, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(cwd, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span> &amp;&amp; mystrlen(constructed_path) &gt; <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="comment">// If cwd was &quot;/&quot; and something got appended making it &quot;//path&quot;, fix to &quot;/path&quot;</span></span><br><span class="line">            <span class="comment">// This case is usually handled by normalize_path later.</span></span><br><span class="line">            <span class="comment">// More simply, if cwd is &quot;/&quot;, just don&#x27;t add another slash if path is not empty.</span></span><br><span class="line">        &#125;</span><br><span class="line">        mystrcat(constructed_path, path);</span><br><span class="line">	<span class="comment">//printf(&quot;rel is rel, raw finalpath: %s\n&quot;, constructed_path);</span></span><br><span class="line">        <span class="comment">// Normalize the constructed path (handles &quot;.&quot;, &quot;..&quot;, &quot;//&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (normalize_path(constructed_path) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;Error: Failed to normalize constructed path &#x27;%s&#x27;\n&quot;, temp_path);</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For relative paths, after normalization, perform stat check</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Path exists and is a directory</span></span><br><span class="line">        mystrcpy(finalpath, constructed_path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Success</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normalize_path function (copied from previous response for completeness if not in a shared lib)</span></span><br><span class="line"><span class="comment">// Ensure MAXNAMELEN and MAXPATHLEN are defined (typically from fs.h)</span></span><br><span class="line"><span class="comment">// Ensure mystrcmp, mystrncpy, mymemcpy, mystrlen are available</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">normalize_path</span><span class="params">(<span class="type">char</span> *path_buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path_buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> components[<span class="number">128</span>][<span class="number">128</span>]; </span><br><span class="line">    <span class="type">int</span> comp_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = path_buf;</span><br><span class="line">    <span class="type">int</span> is_absolute = (*p == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Phase 1: Parse into components, handling &quot;.&quot; and &quot;..&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        p++; </span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        <span class="type">char</span> current_comp_val[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> *c_ptr = current_comp_val;</span><br><span class="line">        <span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c_ptr - current_comp_val &lt; <span class="number">128</span> - <span class="number">1</span>) *c_ptr++ = *p;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        *c_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &gt; <span class="number">0</span> &amp;&amp; mystrcmp(components[comp_idx - <span class="number">1</span>], <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                comp_idx--; <span class="comment">// Pop if last wasn&#x27;t &quot;..&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute) &#123; <span class="comment">// Relative path: push &quot;..&quot; or if stack top is &quot;..&quot; push another</span></span><br><span class="line">                <span class="keyword">if</span> (comp_idx &lt; <span class="number">128</span>) mystrncpy(components[comp_idx++], <span class="string">&quot;..&quot;</span>, <span class="number">128</span><span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH; <span class="comment">// Path too complex/long</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If absolute and comp_idx is 0 (or was &quot;..&quot;), &quot;..&quot; from root is ignored or handled by pop</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mystrcmp(current_comp_val, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; current_comp_val[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (comp_idx &lt; <span class="number">128</span>) mystrncpy(components[comp_idx++], current_comp_val, <span class="number">128</span><span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -E_BAD_PATH; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (*p == <span class="string">&#x27;/&#x27;</span>) p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Phase 2: Reconstruct the path from components</span></span><br><span class="line">    <span class="type">char</span> *write_ptr = path_buf;</span><br><span class="line">    <span class="keyword">if</span> (is_absolute) &#123;</span><br><span class="line">        *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; comp_idx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123; <span class="comment">// Need a separator for components after the first</span></span><br><span class="line">            <span class="keyword">if</span> (write_ptr - path_buf &gt;= MAXPATHLEN - <span class="number">1</span>) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">            *write_ptr++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// First component of a relative path, no leading slash needed from here.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; comp_idx &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &amp;&amp; write_ptr == path_buf + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Absolute path, first component after root &#x27;/&#x27;, no extra slash if write_ptr is right after it.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = mystrlen(components[i]);</span><br><span class="line">        <span class="keyword">if</span> ((write_ptr - path_buf) + len &gt;= MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        <span class="built_in">memcpy</span>(write_ptr, components[i], len);</span><br><span class="line">        write_ptr += len;</span><br><span class="line">    &#125;</span><br><span class="line">    *write_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Final fixups for empty or root results</span></span><br><span class="line">    <span class="keyword">if</span> (path_buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_absolute) mystrcpy(path_buf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> mystrcpy(path_buf, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; path_buf[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path_buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; comp_idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This case means something like &quot;/foo/..&quot; resolved to &quot;/&quot;.</span></span><br><span class="line">        <span class="comment">// If comp_idx is &gt; 0, it means there *were* components that simplified away.</span></span><br><span class="line">        <span class="comment">// If comp_idx became 0 (e.g. /.. or /foo/..), path_buf should correctly be just &quot;/&quot;</span></span><br><span class="line">        <span class="comment">// No specific action needed here if reconstruction is correct.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_absolute &amp;&amp; write_ptr == path_buf) &#123; </span><br><span class="line">        <span class="comment">// This can happen if input was &quot;/&quot; and comp_idx remained 0.</span></span><br><span class="line">        <span class="comment">// Ensure it&#x27;s at least &quot;/&quot;.</span></span><br><span class="line">        path_buf[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>; path_buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrncpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* start = dest; </span><br><span class="line">	<span class="keyword">while</span> (count &amp;&amp; (*dest++ = *src++)) </span><br><span class="line">	&#123;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--count)</span><br><span class="line">		&#123;</span><br><span class="line">			*dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; (<span class="type">size_t</span>)n &amp;&amp; s1[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; s2[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] != s2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>)s1[i] - (<span class="type">unsigned</span> <span class="type">char</span>)s2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; (<span class="type">size_t</span>)n) &#123; </span><br><span class="line">            <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>)s1[i] - (<span class="type">unsigned</span> <span class="type">char</span>)s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; (*str1 == *str2)) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)str1 - *(<span class="type">unsigned</span> <span class="type">char</span> *)str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* ptr = dest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到 dest 的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 src 的内容复制到 dest 的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *ptr = *src;</span><br><span class="line">        ptr++;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加字符串结束符</span></span><br><span class="line">    *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* original_dest = dest; <span class="comment">// 保存目标字符串的起始地址</span></span><br><span class="line">    <span class="keyword">while</span> ((*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>); <span class="comment">// 逐字符复制，直到遇到 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回目标字符串的起始地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mystrlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[length] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span> s_r[<span class="number">5</span>] = <span class="string">&quot;-r&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s_rf[<span class="number">5</span>] = <span class="string">&quot;-rf&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], s_r) == <span class="number">0</span>) &#123;</span><br><span class="line">            argv[i] = <span class="number">0</span>;</span><br><span class="line">            flag_r = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], s_rf) == <span class="number">0</span>) &#123;</span><br><span class="line">            argv[i] = <span class="number">0</span>;</span><br><span class="line">            flag_f = <span class="number">1</span>;</span><br><span class="line">            flag_r = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nothing to rm\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rm(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要注意在rm中，传递的路径必须是绝对路径，因为后续remove调用ipc后的serve_remove中没有用到open，并且文件系统服务进程的工作路径与shell的工作路径不同，没法将相对路径转换成绝对路径，因此必须在rm内部就转换成绝对路径。</p>
<p>exit是内建指令，只需要调用exit()即可。</p>
<h3 id="追加重定向"><a href="#追加重定向" class="headerlink" title="追加重定向"></a>追加重定向</h3><p>你需要实现 shell 中 <code>&gt;&gt;</code> 追加重定向的功能，例如：</p>
<p><code>ls &gt;&gt; file1 ls &gt;&gt; file1</code></p>
<p>实现追加重定向首先需要新定义一种文件打开方式APPEND，在识别到redirect类型是APPEND时，就把文件打开方式设置为APPEND，之后在serve_open的时候，如果检测到文件打开方式是APPEND时，就把offset设置为size，这样之后再写入文件的时候就会从data+offset的位置开始写入，也就是在文件末尾追加内容。</p>
<p>至此，挑战性任务的所有内容都已经完成，我在此期间收获了很多，也对操作系统有了更加深入的了解！</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MOS</tag>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
