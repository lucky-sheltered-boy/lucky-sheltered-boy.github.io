<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2025-北航编译技术设计文档 | lucky-sheltered-boy's Blog</title><meta name="author" content="Jiyuan Zhao"><meta name="copyright" content="Jiyuan Zhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="前言 2025年9月10日完稿  在上编译课之前，我就早有耳闻编译的大名。有很多学长对编译课赞不绝口，称赞其为绝世好课；也有很多学长是苦不堪言，认为其是噩梦。这种两极分化的评价让我对编译这门课充满了敬畏，也多了一丝好奇，到底是怎样的课设才能收获如此丰富的评价呢？希望经过本学期的学习后，我能形成自己的评价，收获自我的感悟。 最后写下我对于编译课的希望吧，在之前学习CO的时候，经常听助教说要多思考少d">
<meta property="og:type" content="article">
<meta property="og:title" content="2025-北航编译技术设计文档">
<meta property="og:url" content="http://example.com/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="lucky-sheltered-boy&#39;s Blog">
<meta property="og:description" content="前言 2025年9月10日完稿  在上编译课之前，我就早有耳闻编译的大名。有很多学长对编译课赞不绝口，称赞其为绝世好课；也有很多学长是苦不堪言，认为其是噩梦。这种两极分化的评价让我对编译这门课充满了敬畏，也多了一丝好奇，到底是怎样的课设才能收获如此丰富的评价呢？希望经过本学期的学习后，我能形成自己的评价，收获自我的感悟。 最后写下我对于编译课的希望吧，在之前学习CO的时候，经常听助教说要多思考少d">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG">
<meta property="article:published_time" content="2026-02-05T17:42:59.000Z">
<meta property="article:modified_time" content="2026-02-05T17:44:09.708Z">
<meta property="article:author" content="Jiyuan Zhao">
<meta property="article:tag" content="编译技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2025-北航编译技术设计文档",
  "url": "http://example.com/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/",
  "image": "https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG",
  "datePublished": "2026-02-05T17:42:59.000Z",
  "dateModified": "2026-02-05T17:44:09.708Z",
  "author": [
    {
      "@type": "Person",
      "name": "Jiyuan Zhao",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2025-北航编译技术设计文档',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lucky-sheltered-boy's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">2025-北航编译技术设计文档</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">2025-北航编译技术设计文档</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-05T17:42:59.000Z" title="Created 2026-02-06 01:42:59">2026-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-05T17:44:09.708Z" title="Updated 2026-02-06 01:44:09">2026-02-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/">编译技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>28mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>2025年9月10日完稿</p>
</blockquote>
<p>在上编译课之前，我就早有耳闻编译的大名。有很多学长对编译课赞不绝口，称赞其为绝世好课；也有很多学长是苦不堪言，认为其是噩梦。这种两极分化的评价让我对编译这门课充满了敬畏，也多了一丝好奇，到底是怎样的课设才能收获如此丰富的评价呢？希望经过本学期的学习后，我能形成自己的评价，收获自我的感悟。</p>
<p>最后写下我对于编译课的希望吧，在之前学习CO的时候，经常听助教说要多思考少debug，希望在写编译器的时候也可以这样，先思考架构，之后再动手实现，尽量不debug，愉快又轻松。</p>
<h2 id="参考编译器介绍"><a href="#参考编译器介绍" class="headerlink" title="参考编译器介绍"></a>参考编译器介绍</h2><blockquote>
<p>2025年9月27日完稿</p>
</blockquote>
<p>在搜集参考资料时，我找了很多。主要还是广泛阅读了编译课提供的模版代码以及学长博客中流传的经典代码。具体来源如下：</p>
<ol>
<li>LLVM官方文档：<a target="_blank" rel="noopener" href="https://llvm.org/docs/">https://llvm.org/docs/</a></li>
<li>LLVM框架参考：<a target="_blank" rel="noopener" href="https://github.com/Hyggge/Petrichor">https://github.com/Hyggge/Petrichor</a></li>
<li>编译课示例代码：<a target="_blank" rel="noopener" href="https://github.com/zhhangBian/Compiler-Techniques">https://github.com/zhhangBian/Compiler-Techniques</a></li>
<li>学长代码：<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Galaxy-JewXW/buaa-compiler-2024">https://github.com/Galaxy-JewXW/buaa-compiler-2024</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zhangyitonggg/BUAA-2024-compiler">https://github.com/zhangyitonggg/BUAA-2024-compiler</a></li>
</ul>
</li>
<li>SysY 的语言说明和2025文法说明</li>
</ol>
<p>在我阅读的大部分编译器中，总体结构的设计都是相似的，大体可以分为前端、中端、后端、utils等。前端主要负责词法分析、语法分析、语义分析。中端做中间代码生成和代码优化。后端再把 IR 映射到 MIPS。utils是一些工具类，比如输出到文件，或者添加错误类型等等。</p>
<p>接口设计上，重点是每个编译阶段之间的衔接。好的接口设计都是流水线一样工作的，上一个阶段的结果作为下一个阶段的输入，这样的好处是功能隔离、高内聚低耦合。比如词法分析最后的结果会返回 Token 流，该 Token 流就是语法分析的输入。因此只需要预先设计每个阶段的输入输出是什么，就可以设计出对应的接口。</p>
<p>文件组织上，大部分编译器都是按阶段分包，原因很简单，调试时打开目录就知道这段代码属于哪一段，不会在一个包里乱成一团。一个典型的文件组织结构如下所示：</p>
<ul>
<li><strong>frontend</strong>：词法、语法、语义、符号表</li>
<li><strong>middle</strong>：IR 构建与 IR 数据结构</li>
<li><strong>optimize</strong>：中端优化 Pass</li>
<li><strong>backend</strong>：MIPS 生成与后端小优化</li>
<li><strong>utils</strong>：错误收集与输出</li>
</ul>
<h2 id="编译器总体设计"><a href="#编译器总体设计" class="headerlink" title="编译器总体设计"></a>编译器总体设计</h2><blockquote>
<p>2025年9月28日初稿，2026年1月2日完稿</p>
</blockquote>
<p>在看了许多优秀的编译器架构设计后，我打算参考学长们成熟的架构来设计我自己的编译器。</p>
<h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>在整体的构建中，我将编译器分为了前中后三段，并设计了错误处理端。在编译器的运行中，在每一端各司其职，仅能通过顶层的端级进行交互，达到了高内聚低耦合的效果。</p>
<p>同时，在编译器的书写中，我还尽量运用了多种面向对象设计思想，融入了多种复杂设计模式，使得编译器的整体书写较为优雅，具有良好的阅读效果。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>在我的编译器中，把前中后三端设计为了静态类，提供了静态交互方法，不暴露内部的接口。每个阶段都分别用单例模式进行管理，这样方便其他阶段调用该类，同时也只保留一个功能实例，方便功能拆分和统一。</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">操作</th>
<th align="left">输入</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">读入文件</td>
<td align="left">testfile.txt</td>
<td align="left">字符流</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Lexer.lex()</td>
<td align="left">字符流</td>
<td align="left">TokenStream</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Parser.parse()</td>
<td align="left">TokenStream</td>
<td align="left">AST</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Visitor.check()</td>
<td align="left">AST</td>
<td align="left">SymbolTable</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">ErrorLog检查</td>
<td align="left">ErrorLog</td>
<td align="left">error.txt</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">IRBuilder.build()</td>
<td align="left">AST + SymbolTable</td>
<td align="left">Module</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">Optimizer.optimize()</td>
<td align="left">Module</td>
<td align="left">Module</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">MipsBuilder.build()</td>
<td align="left">Module</td>
<td align="left">MipsFile</td>
</tr>
</tbody></table>
<h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>编译器的整体代码结构为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├─Compiler.java</span><br><span class="line">├─backend</span><br><span class="line">│ └─...</span><br><span class="line">├─frontend</span><br><span class="line">│ ├─lexer</span><br><span class="line">│ │ └─...</span><br><span class="line">│ ├─parser</span><br><span class="line">│ │ └─...</span><br><span class="line">│ └─Visitor</span><br><span class="line">│   └─...</span><br><span class="line">├─middle</span><br><span class="line">│ ├─IRBuilder.java</span><br><span class="line">│ ├─IRData.java</span><br><span class="line">│ └─component</span><br><span class="line">│   └─...</span><br><span class="line">├─optimize</span><br><span class="line">│ └─...</span><br><span class="line">└─utils</span><br><span class="line">  ├─Config.java</span><br><span class="line">  ├─Error.java</span><br><span class="line">  ├─ErrorLog.java</span><br><span class="line">  └─Printer.java</span><br></pre></td></tr></table></figure>

<p>三端式结构分明，方便代码管理和debug。每个阶段内部采取单例模式，围绕一个主类添加其他功能类，完成词法分析、语法分析、语义分析等阶段的操作。还设置 utils 类方便错误管理和输入输出等。</p>
<h2 id="词法分析设计"><a href="#词法分析设计" class="headerlink" title="词法分析设计"></a>词法分析设计</h2><blockquote>
<p>2025年9月28日完稿</p>
</blockquote>
<h3 id="编码前设计"><a href="#编码前设计" class="headerlink" title="编码前设计"></a>编码前设计</h3><h4 id="文件组织-1"><a href="#文件组织-1" class="headerlink" title="文件组织"></a>文件组织</h4><p>词法分析这块基本是经典四件套：</p>
<ul>
<li><strong>Lexer</strong>：扫描字符流并产出 token</li>
<li><strong>Token</strong>：类型 + 字面值 + 行号</li>
<li><strong>TokenStream</strong>：token 列表 + 指针，支持 next&#x2F;peek&#x2F;last&#x2F;setCurPos</li>
<li><strong>TokenType</strong>：所有终结符&#x2F;关键字枚举</li>
</ul>
<p>文件结构如图所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lexer</span><br><span class="line"> Ⓒ Lexer</span><br><span class="line"> Ⓒ Token</span><br><span class="line"> Ⓒ TokenStream</span><br><span class="line"> Ⓔ TokenType</span><br></pre></td></tr></table></figure>

<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>首先 compiler 是编译器的入口，先读入 testfile.txt 文件，然后传入 Lexer 进行词法分析。Lexer 是单例模式，因此调用 <code>Lexer.getInstance()</code> 可以获取到唯一的 Lexer 单例，再调用 <code>lex()</code> 方法进行词法分析，最后返回一个 TokenStream，里面每个单元是一个 Token。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PushbackReader pushbackReader;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    pushbackReader = <span class="keyword">new</span> <span class="title class_">PushbackReader</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span></span><br><span class="line">    <span class="title class_">FileReader</span>(filePath, StandardCharsets.UTF_8)), <span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;初始化 Lexer 失败: 文件未找到 &quot;</span> + filePath, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 词法分析</span></span><br><span class="line"><span class="type">TokenStream</span> <span class="variable">tokenStream</span> <span class="operator">=</span> Lexer.getInstance(pushbackReader).lex();</span><br><span class="line">Printer.printToLexer(tokenStream.toString());</span><br></pre></td></tr></table></figure>

<h3 id="编码完成之后的修改"><a href="#编码完成之后的修改" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p>为了简化文件读取流程，我封装了 <code>read()</code> 方法和 <code>currentChar</code>，方便词法分析操作。<code>currentChar</code> 相当于一个指针，用来指向当前正在处理的字符。如果想访问当前字符，只需要直接访问 <code>currentChar</code> 即可。如果要处理下一个字符并且不需要当前字符了，只需要调用 <code>read()</code> 方法就可以。如果想保留当前字符同时提前看下一个字符，只需要调用 <code>peek()</code> 方法。</p>
<p>实际的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> reader.read();</span><br><span class="line">    currentChar = (<span class="type">char</span>) t;</span><br><span class="line">    <span class="keyword">return</span> currentChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader.unread(currentChar);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">peek</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> reader.read();</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) t;</span><br><span class="line">    reader.unread(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEOF</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentChar == EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在词法分析主流程中，我采用循环写法，每次循环中先跳过空白符，再读取下一个token。</p>
<p>我把“跳空白 + 跳注释”单独抽成了 <code>skipWhitespaceAndComments()</code>，其核心功能是跳过换行和注释。在 Lexer 类里面维护一个 <code>line</code>，如果遇到换行，包括多行注释里面的换行，则 <code>line++</code>，同时跳过该字符。如果是 <code>/</code>，则看后面是否是 <code>//</code> 或 <code>/*</code>，如果是 <code>//</code> 则一直读字符直到读取至换行，如果是 <code>/*</code> 则一直读取至 <code>*/</code> 或者文件结尾。 因为这块一开始没抽出来的时候特别容易漏掉“多行注释里行号递增”，导致后面语法&#x2F;语义报错行号一塌糊涂。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">skipWhitespaceAndComments</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">while</span> (Character.isWhitespace(currentChar) || currentChar == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentChar == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            line++;</span><br><span class="line">            read();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isWhitespace(currentChar)) &#123;</span><br><span class="line">            read();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentChar == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">nextChar</span> <span class="operator">=</span> peek();</span><br><span class="line">                <span class="keyword">if</span> (nextChar == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// Single-line comment</span></span><br><span class="line">                    <span class="keyword">while</span> (currentChar != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; !isEOF()) &#123;</span><br><span class="line">                        read();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (currentChar == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                        line++;</span><br><span class="line">                        read();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextChar == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// Multi-line comment</span></span><br><span class="line">                    read(); <span class="comment">// consume &#x27;*&#x27;</span></span><br><span class="line">                    read(); <span class="comment">// consume first char inside comment</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isEOF()) &#123;</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// Unterminated comment</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (currentChar == <span class="string">&#x27;*&#x27;</span> &amp;&amp; peek() == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                            read(); <span class="comment">// consume &#x27;*&#x27;</span></span><br><span class="line">                            read(); <span class="comment">// consume &#x27;/&#x27;</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (currentChar == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                            line++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        read();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Not a comment, just a &#x27;/&#x27;</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先跳过空白符，然后判断是否遇到了文件结尾，如果是结尾则直接结束。否则读取下一个 Token，并添加至 TokenStream 中。</p>
<p>token 识别上主要分几类：</p>
<ul>
<li><strong>单字符直接定类</strong>：括号、分号、+ - * &#x2F; % , 等</li>
<li><strong>需要向前看一位的</strong>：&#x3D; ! &lt; &gt; &amp; |，用 peek() 分辨 &#x3D;&#x3D;&#x2F;&#x3D;、!&#x3D;&#x2F;!、&amp;&amp;&#x2F;非法 &amp; 等</li>
<li><strong>数字</strong>：连续读数字得到 INTCON</li>
<li><strong>标识符&#x2F;关键字</strong>：连续读字母&#x2F;数字&#x2F;下划线，然后用 switch 匹配关键字（const&#x2F;int&#x2F;static&#x2F;…）</li>
<li><strong>字符串</strong>：遇到 “ 一直读到下一个 “</li>
</ul>
<p>这样做的好处是按照类别分类，保证了正确性，方便后续扩展与迭代开发。核心分拣代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Token <span class="title function_">getNextToken</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSingleToken()) &#123;</span><br><span class="line">        <span class="comment">// 单字符就可以判定为 Token</span></span><br><span class="line">        <span class="keyword">return</span> tackleSingleToken();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOneOrTwoToken()) &#123;</span><br><span class="line">        <span class="comment">// 需要再向后读一个字符来判定的 Token</span></span><br><span class="line">        <span class="keyword">return</span> tackleOneOrTwoToken();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentChar == <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 字符串字面量</span></span><br><span class="line">        <span class="keyword">return</span> tackleStringLiteral();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(currentChar)) &#123;</span><br><span class="line">        <span class="comment">// 数字字面量</span></span><br><span class="line">        <span class="keyword">return</span> tackleDigit();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 标识符或关键字</span></span><br><span class="line">        <span class="keyword">return</span> tackleIdent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>词法阶段我只处理了一类比较“硬”的错误：单个 &amp; 或 |。按要求应该是 &amp;&amp;&#x2F;||，所以这里直接记一个错误码 a，但仍然返回一个逻辑与&#x2F;或 token，让后续阶段能继续跑下去，否则错误恢复会更麻烦。</p>
<h2 id="语法分析设计"><a href="#语法分析设计" class="headerlink" title="语法分析设计"></a>语法分析设计</h2><blockquote>
<p>2025年10月1日完稿</p>
</blockquote>
<h3 id="编码前设计-1"><a href="#编码前设计-1" class="headerlink" title="编码前设计"></a>编码前设计</h3><p>语法分析做的事就是把 TokenStream 还原成结构化的 AST。</p>
<p>我的 AST 节点类是按文法一比一建造的，优点是写起来直接，缺点就是类很多、文件夹会很大。</p>
<p>对于 Parser 采用单例模式设计，用 Node 接口来统一串联所有节点。为了更好的管理每种语法类型，我还对所有语法成分进行了目录分类，比如所有语句类 Stmt 可以单独存放，所有表达式 Exp 也可以存放，所有初始值 IV, CIV 也可以单独存放。</p>
<h4 id="文件组织-2"><a href="#文件组织-2" class="headerlink" title="文件组织"></a>文件组织</h4><ul>
<li><code>frontend/parser/Parser.java</code>：递归下降解析</li>
<li><code>frontend/parser/AST/*</code>：各语法节点类</li>
</ul>
<p>具体文件结构如图所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">parser</span><br><span class="line"> └─ AST</span><br><span class="line">    ├─ CIV</span><br><span class="line">    ├─ Exp</span><br><span class="line">    ├─ Func</span><br><span class="line">    ├─ IV</span><br><span class="line">    ├─ Stmt</span><br><span class="line">    │  Ⓒ Block</span><br><span class="line">    │  Ⓘ BlockItem</span><br><span class="line">    Ⓒ CompUnit</span><br><span class="line">    Ⓒ ConstDecl</span><br><span class="line">    Ⓒ ConstDef</span><br><span class="line">    Ⓘ Decl</span><br><span class="line">    Ⓒ VarDecl</span><br><span class="line">    Ⓒ VarDef</span><br><span class="line"> Ⓘ Node</span><br><span class="line"> Ⓒ Parser</span><br></pre></td></tr></table></figure>

<h3 id="编码完成之后的修改-1"><a href="#编码完成之后的修改-1" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><h4 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h4><p>为了更方便的处理 TokenStream，我依旧仿照词法分析的方式设置了很多方法，例如 next，getCurToken，peek等。</p>
<p>其用途是，<code>getCurToken</code> 相当于一个 Token 指针，指向当前处理的 Token，想要获取当前 Token 只需要调用 <code>getCurToken</code> 方法。如果处理完当前 Token 想要处理下一个 Token，只需要调用 <code>next</code> 方法即可。这里还支持 <code>peek</code>，可以动态向前查看多个 Token 字符。为了查看上一个字符，还可以调用 <code>last</code> 方法。同时为了支持回溯，我还支持用 <code>getCurPos</code> 获取当前的 pos，在需要回溯的时候再 <code>setCurPos</code> 重新设置 pos 位置，达到回溯的效果。</p>
<p>核心代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Token <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= tokens.size()) &#123;</span><br><span class="line">        curToken = <span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.EOF, <span class="string">&quot;end&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> curToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// System.out.println(p + &quot; &quot; + tokens.get(p).getLine() + &quot; &quot; + tokens.get(p));</span></span><br><span class="line">    curToken = tokens.get(pos++);</span><br><span class="line">    <span class="keyword">return</span> curToken;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">getCurToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curToken;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">peek</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos + delta - <span class="number">1</span> &gt;= tokens.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.EOF, <span class="string">&quot;end&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens.get(pos + delta - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">last</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.EOF, <span class="string">&quot;end&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens.get(pos - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurPos</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurPos</span><span class="params">(<span class="type">int</span> pos)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pos = pos;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">0</span> &amp;&amp; pos &lt;= tokens.size()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.curToken = tokens.get(pos - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.curToken = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h4><p>整体就是递归下降：<code>parseCompUnit()</code> 往下调 <code>parseDecl</code>&#x2F;<code>parseFuncDef</code>&#x2F;<code>parseStmt</code>&#x2F;<code>parseExp</code>…。对于每一个语法成分，我都建立了一个类，在语法分析时只需要调用该语法成分的 parse 方法，然后依次调用子成分的 parse 方法，最后返回该语法成分的实例即可。</p>
<p>我们首先改写文法，消除其中的左递归，然后在各个节点类中按照改写后的文法定义各个节点的属性和相应的Get和Set方法。之后，我们在Parser类中递归向下分析每个节点类即可。具体细节如下：</p>
<ol>
<li><strong>递归下降解析</strong><br>每种语法规则对应一个解析函数。例如：<ul>
<li><code>parseAddExp()</code> 用于解析 AddExp，它递归调用 <code>parseMulExp()</code>。</li>
</ul>
</li>
<li><strong>回溯支持</strong><ul>
<li>在可能的多分支选择中，通过预读下一个 Token 判断选择路径。</li>
<li>如果无法通过预读解决选择路径的话，则需要进行回溯，此时仅需要记录下回溯返回的位置，并在结束时返回合适的位置即可。</li>
</ul>
</li>
</ol>
<p>有个我觉得比较关键的点是语句分支的判定，比如 Stmt 里要区分：</p>
<ul>
<li><code>LVal &#39;=&#39; Exp &#39;;&#39;</code></li>
<li><code>[Exp] &#39;;&#39;</code></li>
</ul>
<p>这块我用了“试探 + 回退”：先记下 curPos，临时解析一次 LVal 看下一 token 是不是 ASSIGN，然后再 setCurPos(curPos) 回去走真正的分支。</p>
<p>一个典型的代码示例为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stmt -&gt; &#x27;printf&#x27; &#x27;(&#x27; StringConst &#123; &#x27;,&#x27; Exp &#125; &#x27;)&#x27; &#x27;;&#x27; // i j</span></span><br><span class="line"><span class="keyword">public</span> PrintfStmt <span class="title function_">parsePrintfStmt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Token</span> <span class="variable">printfToken</span> <span class="operator">=</span> tokenStream.getCurToken(); <span class="comment">// printf</span></span><br><span class="line">    tokenStream.next(); <span class="comment">// printf</span></span><br><span class="line">    tokenStream.next(); <span class="comment">// (</span></span><br><span class="line">    <span class="type">Token</span> <span class="variable">stringConst</span> <span class="operator">=</span> tokenStream.getCurToken(); <span class="comment">// stringConst</span></span><br><span class="line">    tokenStream.next(); <span class="comment">// stringConst</span></span><br><span class="line">    ArrayList&lt;Exp&gt; exps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (tokenStream.getCurToken().is(COMMA)) &#123;</span><br><span class="line">        tokenStream.next(); <span class="comment">// ,</span></span><br><span class="line">        exps.add(parseExp());</span><br><span class="line">    &#125;</span><br><span class="line">    checkParserError(RPARENT);</span><br><span class="line">    checkParserError(SEMICN);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PrintfStmt</span>(stringConst, exps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p>语法阶段主要按课程要求处理 i&#x2F;j&#x2F;k 三类缺符号：</p>
<ul>
<li><strong>i</strong>：缺 ;</li>
<li><strong>j</strong>：缺 )</li>
<li><strong>k</strong>：缺 ]</li>
</ul>
<p>实现上统一走 <code>checkParserError</code>：如果当前 token 不是期望符号，就用 <code>tokenStream.last().getLine()</code> 去报错，也就是“报在上一个正常 token 的行号上”，否则就消费掉这个符号。</p>
<p>另外我加了一个 <code>errorLayer</code>：在“试探解析”期间把它加一，避免试探过程触发一堆无意义的 i&#x2F;j&#x2F;k，这类误报非常影响调试心情。</p>
<ul>
<li>增加 <code>errorLayer</code>，把“试探解析”从错误收集里隔离出去。</li>
<li>i&#x2F;j&#x2F;k 统一封装到 <code>checkParserError</code>，不在各个 <code>parseXxx</code> 里散落重复逻辑。</li>
</ul>
<h2 id="语义分析设计"><a href="#语义分析设计" class="headerlink" title="语义分析设计"></a>语义分析设计</h2><blockquote>
<p>2025年10月7日完稿</p>
</blockquote>
<h3 id="编码前设计-2"><a href="#编码前设计-2" class="headerlink" title="编码前设计"></a>编码前设计</h3><p>语义分析主要需要做两件事：</p>
<ul>
<li>对于正确的源程序，需要从源程序中识别出定义的常量、变量等，输出它们的作用域序号，单词的字符&#x2F;字符串形式，类型名称。</li>
<li>对于错误的源程序，需要识别出错误，并输出错误所在的行号和错误的类别码。</li>
</ul>
<p>可以看到课程组有意识地将错误处理分散在编译器的全流程中，事实上这确实是合理的，因为真正的编译器不可能是只在考察编译器错误处理能力时提供错误的代码。</p>
<h4 id="文件组织-3"><a href="#文件组织-3" class="headerlink" title="文件组织"></a>文件组织</h4><p>语义分析主要在 <code>Visitor</code> 中完成，核心是遍历 AST 并维护符号表。</p>
<ul>
<li><code>frontend/Visitor/Visitor.java</code>：语义检查主体，实现 AST 节点的 visit 方法。</li>
<li><code>frontend/Visitor/SymbolTable.java</code>：树形符号表，支持父子作用域嵌套。</li>
<li><code>frontend/Visitor/Symbol/*</code>：<ul>
<li><code>VarSymbol</code>：变量&#x2F;常量符号，记录类型、维度、是否全局等。</li>
<li><code>FuncSymbol</code>：函数符号，记录返回值类型、形参列表。</li>
<li><code>SymbolType</code>：符号类型枚举。</li>
</ul>
</li>
</ul>
<p>具体文件结构如下图所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Visitor</span><br><span class="line"> └─ Symbol</span><br><span class="line">    Ⓒ FuncSymbol</span><br><span class="line">    Ⓒ Symbol</span><br><span class="line">    Ⓔ SymbolType</span><br><span class="line">    Ⓒ VarSymbol</span><br><span class="line"> Ⓒ SymbolTable</span><br><span class="line"> Ⓒ Visitor</span><br></pre></td></tr></table></figure>

<h3 id="工作流程-3"><a href="#工作流程-3" class="headerlink" title="工作流程"></a>工作流程</h3><p>入口从 CompUnit 开始，顺序检查：全局声明 → 函数定义 → main 函数。</p>
<p>对于每个语法成分，先用 get 方法获得其子成分，然后再依次调用 check 方法检查其子语法成分是否有语义错误。</p>
<p>代码示例为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stmt -&gt; &#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; Stmt // h</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkForCycleStmt</span><span class="params">(ForCycleStmt stmt)</span> &#123;</span><br><span class="line">    <span class="type">ForStmt</span> <span class="variable">initStmt</span> <span class="operator">=</span> stmt.getInitStmt();</span><br><span class="line">    <span class="type">Cond</span> <span class="variable">cond</span> <span class="operator">=</span> stmt.getCond();</span><br><span class="line">    <span class="type">ForStmt</span> <span class="variable">stepStmt</span> <span class="operator">=</span> stmt.getStepStmt();</span><br><span class="line">    <span class="type">Stmt</span> <span class="variable">bodyStmt</span> <span class="operator">=</span> stmt.getBodyStmt();</span><br><span class="line">    <span class="keyword">if</span> (initStmt != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkForStmt(initStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cond != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkCond(cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stepStmt != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkForStmt(stepStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    loopNum++;</span><br><span class="line">    checkStmt(bodyStmt);</span><br><span class="line">    loopNum--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在作用域管理上，采用树形 SymbolTable 结构。每当进入一个新的代码块，Block，就调用 <code>enterBlock()</code> 创建一个新的子符号表，并将当前符号表指针 curTable 指向它；离开代码块时，调用 <code>leaveBlock()</code> 回退到父符号表。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enterBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    idCount++;</span><br><span class="line">    <span class="type">SymbolTable</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolTable</span>(idCount, curTable);</span><br><span class="line">    curTable.addChild(child);</span><br><span class="line">    curTable = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leaveBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    curTable = curTable.getFather();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编码完成之后的修改-2"><a href="#编码完成之后的修改-2" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><h4 id="工作流程-4"><a href="#工作流程-4" class="headerlink" title="工作流程"></a>工作流程</h4><p>在编码过程中，为了方便后续中间代码生成时能正确映射符号，我严格保证了 Visitor 建立符号表的顺序与 IRBuilder 遍历 AST 的顺序一致。</p>
<p>此外，对于库函数，getint, putint, putch, putstr，我在 Visitor 的构造函数中直接将它们加入到了顶层全局符号表中。这样在处理函数调用时，无需对库函数做特殊判断，除了 getint 需要检查无参，统一了处理逻辑。最后在输出 symbol.txt 的时候去掉库函数的输出即可。</p>
<h4 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h4><p>语义错误主要依据课程要求的错误码进行检查，重点处理了以下几类：</p>
<table>
<thead>
<tr>
<th align="left">错误类别码</th>
<th align="left">错误类型</th>
<th align="left">解决思路</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="left">操作符有错误（ &amp; 和 | ）</td>
<td align="left">在语法分析阶段进行</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">名字重定义（函数名和变量名重定义）</td>
<td align="left">在当前作用域内查找</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">可执行语句使用未定义的名字</td>
<td align="left">利用符号表的父指针，不断向外查找</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">函数参数个数不匹配</td>
<td align="left">解析完函数调用后进行确认</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">函数参数类型不匹配</td>
<td align="left">解析完函数调用后进行确认</td>
</tr>
<tr>
<td align="left">h</td>
<td align="left">不能改变常量的值</td>
<td align="left">检查Symbol的类型是否为const</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">无返回值的函数存在不匹配的return语句</td>
<td align="left">在 FuncDef 内进行处理</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">有返回值的函数缺少return语句</td>
<td align="left">在 FuncDef 解析结束后对函数Block进行查找</td>
</tr>
</tbody></table>
<p>对于新增的错误类型，我采用在 check 方法中特判的做法。</p>
<p>如果有语义错误，则新建 Error 实例并调用 addError 添加至 ErrorLog 中，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addError</span><span class="params">(Token ident, <span class="type">char</span> errorKey)</span> &#123;</span><br><span class="line">    <span class="type">Error</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ident.getLine(), errorKey);</span><br><span class="line">    ErrorLog.getInstance().addError(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码生成设计"><a href="#代码生成设计" class="headerlink" title="代码生成设计"></a>代码生成设计</h2><blockquote>
<p>2025年11月15日初稿，2025年12月20日完稿</p>
</blockquote>
<h3 id="编码前设计-3"><a href="#编码前设计-3" class="headerlink" title="编码前设计"></a>编码前设计</h3><h4 id="中间代码选择"><a href="#中间代码选择" class="headerlink" title="中间代码选择"></a>中间代码选择</h4><p>代码生成分为中间代码生成 LLVM IR 和目标代码生成 MIPS 两个阶段。</p>
<p>我是选择的LLVM作为中间代码，原因主要有三：</p>
<ul>
<li>有很多往年学长的博客、代码可以参考，便于实现；</li>
<li>LLVM 本身是十分易于优化的。</li>
<li>即使最后完不成 mips 代码生成，也可以选择 LLVM 作为目标代码，可谓是进可攻、退可守。</li>
</ul>
<h4 id="LLVM-介绍"><a href="#LLVM-介绍" class="headerlink" title="LLVM 介绍"></a>LLVM 介绍</h4><p>LLVM 中有四个具有依次包含关系的基本概念：</p>
<ul>
<li><strong>Module</strong> 是一份 LLVM IR 的顶层容器，对应于编译前端的每个翻译单元。一个 Module 由若干 GlobalValue 组成，而一个GlobalValue 可以是全局变量 GlobalVariable，也可以是函数 Function。</li>
<li><strong>Function</strong> 就是编程语言中的函数，包括函数签名和若干个基本块。函数内的第一个基本块叫做入口基本块。</li>
<li><strong>BasicBlock</strong> 是一组顺序执行的指令集合，只有一个入口和一个出口，非头尾指令执行时不会违背顺序跳转到其他指令上去<ul>
<li>每个基本块最后一条指令一般是跳转指令</li>
<li>每个 BasicBlock 都有一个 label，label 使得该 BasicBlock 有一个符号表的入口点</li>
<li>函数内最后一个基本块的最后条指令是函数返回指令，以terminator instruction（ret、br等）结尾</li>
</ul>
</li>
<li><strong>Instruction</strong> 是 LLVM IR 的最小可执行单位，每一条指令都单占一行</li>
</ul>
<h4 id="Value-Use"><a href="#Value-Use" class="headerlink" title="Value-Use"></a>Value-Use</h4><p>LLVM 中所有类都直接或间接继承自 Value，在 LLVM 中，有“一切皆 Value”的说法。通过规整的继承关系，就得到了 LLVM 的类型系统。</p>
<p>为了表达 Value 之间的引用关系，LLVM 中还有一种特殊的 Value 叫做 User，其将其他 Value 作为参数。</p>
<p>Instruction 继承自 User，因此它可以将其他 Value 作为参数。对于指令 <code>%add1 = add nsw i32 %a, %b</code>，在 <code>%add1</code> 与 <code>%a</code>、<code>%b</code> 之间分别构成了 Use 关系。后续的相关指令也可以继续进行调用，形成 Use 链。</p>
<p>这种指令间的关系正是 LLVM 的核心之一，实现了 SSA 形式的中间代码。这样的形式可以方便 LLVM 进行分析和优化，如：</p>
<ul>
<li>可以快速分析两个值是否是同一个值，是否要删除冗余代码。</li>
<li>如果一个 Value 没有 Use 关系，很可能就是可以删除的冗余代码。</li>
</ul>
<p>在设计中间代码生成的过程中，我一开始并不理解其 value-use 关系的设计目的，直到后期做到了代码优化，才明白其重要性，可以便捷地找到在函数的值实体之间的依赖关系。</p>
<h4 id="文件组织-4"><a href="#文件组织-4" class="headerlink" title="文件组织"></a>文件组织</h4><ul>
<li><strong>中间代码</strong>：<ul>
<li><code>middle/IRBuilder.java</code>：IR 生成总入口。</li>
<li><code>middle/component/*</code>：IR 组件，包括 Module, Function, BasicBlock, Instruction 等。</li>
</ul>
</li>
<li><strong>目标代码</strong>：<ul>
<li><code>backend/MipsBuilder.java</code>：MIPS 生成总入口。</li>
<li><code>backend/MipsFile.java</code>：负责管理 .data 和 .text 段并输出。</li>
<li><code>backend/component/*</code>：MIPS 指令与操作数类。</li>
</ul>
</li>
</ul>
<p>具体文件组织如下图：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">middle</span><br><span class="line"> └─ component</span><br><span class="line">    ├─ instruction</span><br><span class="line">    ├─ model</span><br><span class="line">    └─ type</span><br><span class="line">    Ⓒ BasicBlock</span><br><span class="line">    Ⓒ ConstInt</span><br><span class="line">    Ⓒ ConstString</span><br><span class="line">    Ⓒ ForLoop</span><br><span class="line">    Ⓒ FuncParam</span><br><span class="line">    Ⓒ Function</span><br><span class="line">    Ⓒ GlobalVar</span><br><span class="line">    Ⓒ InitialValue</span><br><span class="line">    Ⓒ Module</span><br><span class="line">    Ⓒ Undefined</span><br><span class="line"> Ⓒ IRBuilder</span><br><span class="line"> Ⓒ IRData</span><br></pre></td></tr></table></figure>

<h4 id="工作流程-5"><a href="#工作流程-5" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li><strong>IR 生成</strong>：遍历 AST，将全局变量转换为 GlobalVar，将函数体转换为 BasicBlock 和 Instruction 序列。</li>
<li><strong>MIPS 生成</strong>：遍历生成的 IR Module，将每个 IR 指令映射为对应的 MIPS 指令序列。</li>
</ol>
<h3 id="编码完成之后的修改-3"><a href="#编码完成之后的修改-3" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><p>我使用了 LLVM-IR 来作为中间代码。使得程序真正有了可运行的结果。</p>
<p>中间代码生成无疑是工作量最大的一部分，我几乎投入了完整的五天才解决了中间代码生成过程中的全部问题。</p>
<h4 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h4><p>在 IRBuilder 中，我维护了一个 lookupTable，用于建立 AST 中的 Symbol 到 LLVM IR Value 的映射。</p>
<p><strong>作用域管理</strong></p>
<p>为了保证符号查找的正确性，我严格按照 AST 遍历顺序维护符号表栈。<br>这样可以跟语义分析保持同样的逻辑，方便我书写代码，同样也方便我梳理思路，防止出错。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enterScope</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> childIndexMap.getOrDefault(currentTable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; currentTable.getChildren().size()) &#123;</span><br><span class="line">        currentTable = currentTable.getChildren().get(index);</span><br><span class="line">        childIndexMap.put(currentTable.getFather(), index + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Scope mismatch...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lookupTable = <span class="keyword">new</span> <span class="title class_">SymbolTable</span>(currentTable.getId(), lookupTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制流生成</strong></p>
<p>对于 if-else 语句，我采用了标准的“基本块 + 跳转”模式。<br>特别注意了短路求值和空 else 块的处理。</p>
<p>相关代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildIfElseStmt</span><span class="params">(IfElseStmt stmt)</span> &#123;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">trueBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicBlock</span>(IRData.getBlockName());</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">falseBlock</span> <span class="operator">=</span> stmt.getElseStmt() != <span class="literal">null</span> ? <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">BasicBlock</span>(IRData.getBlockName()) : <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">nextBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicBlock</span>(IRData.getBlockName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置基本块所属函数</span></span><br><span class="line">    trueBlock.setFunction(currentFunction);</span><br><span class="line">    <span class="keyword">if</span> (falseBlock != <span class="literal">null</span>) falseBlock.setFunction(currentFunction);</span><br><span class="line">    nextBlock.setFunction(currentFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成条件跳转</span></span><br><span class="line">    buildCond(stmt.getCond(), trueBlock, falseBlock != <span class="literal">null</span> ? falseBlock : nextBlock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 True 分支</span></span><br><span class="line">    IRData.setCurrentBlock(trueBlock);</span><br><span class="line">    currentBlock = trueBlock;</span><br><span class="line">    buildStmt(stmt.getIfStmt());</span><br><span class="line">    <span class="keyword">if</span> (!isBlockTerminated(currentBlock)) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BrInst</span>(nextBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 False 分支（如果有）</span></span><br><span class="line">    <span class="keyword">if</span> (falseBlock != <span class="literal">null</span>) &#123;</span><br><span class="line">        IRData.setCurrentBlock(falseBlock);</span><br><span class="line">        currentBlock = falseBlock;</span><br><span class="line">        buildStmt(stmt.getElseStmt());</span><br><span class="line">        <span class="keyword">if</span> (!isBlockTerminated(currentBlock)) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BrInst</span>(nextBlock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 汇合点</span></span><br><span class="line">    IRData.setCurrentBlock(nextBlock);</span><br><span class="line">    currentBlock = nextBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组初始化</strong></p>
<p>为了处理局部数组的初始化，我实现了 <code>buildLocalArrayInit</code> 方法。<br>利用 GepInst 计算地址并逐个 Store。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildLocalArrayInit</span><span class="params">(Value baseAddr, InitVal initVal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initVal <span class="keyword">instanceof</span> IVExps) &#123;</span><br><span class="line">        <span class="type">IVExps</span> <span class="variable">ivExps</span> <span class="operator">=</span> (IVExps) initVal;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ivExps.getExps().size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrayLen</span> <span class="operator">=</span> ((ArrayType) ((PointerType)baseAddr.getValueType()).getTargetType()).getElementNum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式初始化的部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">Exp</span> <span class="variable">exp</span> <span class="operator">=</span> ivExps.getExps().get(i);</span><br><span class="line">            <span class="type">Value</span> <span class="variable">val</span> <span class="operator">=</span> buildExp(exp);</span><br><span class="line">            <span class="type">Instruction</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GepInst</span>(baseAddr, <span class="keyword">new</span> <span class="title class_">ConstInt</span>(IntegerType.i32, i));</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StoreInst</span>(gep, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未显式初始化的部分补 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &lt; arrayLen; i++) &#123;</span><br><span class="line">            <span class="type">Instruction</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GepInst</span>(baseAddr, <span class="keyword">new</span> <span class="title class_">ConstInt</span>(IntegerType.i32, i));</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StoreInst</span>(gep, <span class="keyword">new</span> <span class="title class_">ConstInt</span>(IntegerType.i32, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MIPS目标代码生成"><a href="#MIPS目标代码生成" class="headerlink" title="MIPS目标代码生成"></a>MIPS目标代码生成</h4><p>在 MipsBuilder 中，我使用了 <code>Map&lt;Class, Consumer&gt;</code> 的方式来分发指令生成逻辑。<br>这样做的好处是可以避免冗长的 if-else 或 switch 结构。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initInstructionHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">    instructionHandlers.put(AllocInst.class, inst -&gt; buildAllocInst((AllocInst) inst));</span><br><span class="line">    instructionHandlers.put(BinaryInst.class, inst -&gt; &#123;</span><br><span class="line">        <span class="type">BinaryInst</span> <span class="variable">binaryInst</span> <span class="operator">=</span> (BinaryInst) inst;</span><br><span class="line">        <span class="keyword">if</span> (OperatorType.isLogicalOperator(binaryInst.getOpType())) &#123;</span><br><span class="line">            buildIcmp(binaryInst);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buildBinaryInst(binaryInst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ... 其他指令映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈帧管理与寄存器分配</strong></p>
<p>在函数生成开始时，我会计算所有局部变量的栈偏移量。<br>如果开启优化，还会根据寄存器分配结果预留寄存器。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildFunction</span><span class="params">(Function function)</span> &#123;</span><br><span class="line">    currentFunction = function;</span><br><span class="line">    var2Offset = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    curStackOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取寄存器分配结果</span></span><br><span class="line">    var2reg = optimizeOn ? <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(function.getVar2reg()) : <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;func_&quot;</span> + function.getName().substring(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数：前4个参数在寄存器，后续参数在栈上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; function.getFuncParams().size(); i++) &#123;</span><br><span class="line">        curStackOffset -= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            var2reg.put(function.getFuncParams().get(i),</span><br><span class="line">            Register.getByOffset(Register.A0, i));</span><br><span class="line">        &#125;</span><br><span class="line">        var2Offset.put(function.getFuncParams().get(i), curStackOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为其他指令分配栈空间（如果未分配寄存器）</span></span><br><span class="line">    <span class="keyword">for</span> (BasicBlock block : function.getBasicBlocks()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Instruction instruction : block.getInstructions()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!instruction.getName().isEmpty() &amp;&amp; !var2reg.containsKey(instruction)) &#123;</span><br><span class="line">                curStackOffset -= <span class="number">4</span>;</span><br><span class="line">                var2Offset.put(instruction, curStackOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 生成基本块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>比较指令生成</strong></p>
<p>对于比较指令，如 <code>icmp eq</code>，我将其转换为 MIPS 的 <code>seq</code> 等指令。<br>如果操作数在寄存器中则直接使用，否则从栈中加载。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildIcmp</span><span class="params">(BinaryInst binaryInst)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 确定操作码 asmOp (SEQ, SNE, SLT 等)</span></span><br><span class="line">    <span class="type">Value</span> <span class="variable">operand1</span> <span class="operator">=</span> binaryInst.getOperand1();</span><br><span class="line">    <span class="type">Value</span> <span class="variable">operand2</span> <span class="operator">=</span> binaryInst.getOperand2();</span><br><span class="line">    <span class="type">Register</span> <span class="variable">reg1</span> <span class="operator">=</span> Register.K0;</span><br><span class="line">    <span class="type">Register</span> <span class="variable">reg2</span> <span class="operator">=</span> Register.K1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载操作数到寄存器</span></span><br><span class="line">    <span class="keyword">if</span> (operand1 <span class="keyword">instanceof</span> ConstInt constInt) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LiAsm</span>(reg1, constInt.getIntValue());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2reg.containsKey(operand1)) &#123;</span><br><span class="line">        reg1 = var2reg.get(operand1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MemAsm</span>(AsmOp.LW, reg1, Register.SP, var2Offset.get(operand1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 加载 operand2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成比较指令</span></span><br><span class="line">    <span class="type">Register</span> <span class="variable">targetReg</span> <span class="operator">=</span> var2reg.getOrDefault(binaryInst, Register.K0);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CmpAsm</span>(asmOp, targetReg, reg1, reg2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果结果未分配寄存器，存回栈</span></span><br><span class="line">    <span class="keyword">if</span> (!var2reg.containsKey(binaryInst)) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MemAsm</span>(AsmOp.SW, targetReg, Register.SP, var2Offset.get(binaryInst));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码前后的改变主要如下：</p>
<ol>
<li>在每条指令翻译后都添加相应的注释输出中间代码，这样可以便于debug</li>
<li>对栈的操作核查了多次，小心再小心</li>
</ol>
<h2 id="代码优化设计"><a href="#代码优化设计" class="headerlink" title="代码优化设计"></a>代码优化设计</h2><blockquote>
<p>2026年1月2日完稿</p>
</blockquote>
<h3 id="编码前设计-4"><a href="#编码前设计-4" class="headerlink" title="编码前设计"></a>编码前设计</h3><h4 id="文件组织-5"><a href="#文件组织-5" class="headerlink" title="文件组织"></a>文件组织</h4><ul>
<li><code>optimize/Optimizer.java</code>：优化器入口，组织所有 Pass 的执行顺序。</li>
<li><code>optimize/*</code>：各种具体的优化 Pass 类，如 Mem2Reg, GVN, LoopUnroll 等。</li>
</ul>
<p>所做的优化大概如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">optimize</span><br><span class="line"> Ⓒ BlockSimplify</span><br><span class="line"> Ⓒ CodeRemoval</span><br><span class="line"> Ⓒ CondConstProp</span><br><span class="line"> Ⓒ DivideCall</span><br><span class="line"> Ⓒ FixMD</span><br><span class="line"> Ⓒ FunctionCopy</span><br><span class="line"> Ⓒ FunctionSideEffect</span><br><span class="line"> Ⓒ GCM</span><br><span class="line"> Ⓒ GlobalVarLocalize</span><br><span class="line"> Ⓒ GVN</span><br><span class="line"> Ⓒ IcmpOptimize</span><br><span class="line"> Ⓒ InlinedFunction</span><br><span class="line"> Ⓒ LocalConstArrayToValue</span><br><span class="line"> Ⓒ LoopAnalysis</span><br><span class="line"> Ⓒ LoopInvariantHoist</span><br><span class="line"> Ⓒ LoopRecord</span><br><span class="line"> Ⓒ LoopUnroll</span><br><span class="line"> Ⓒ Mem2Reg</span><br><span class="line"> Ⓒ MemoryOptimize</span><br><span class="line"> Ⓒ Optimizer</span><br><span class="line"> Ⓒ PhiOptimize</span><br><span class="line"> Ⓒ PickGep</span><br><span class="line"> Ⓒ PrintOptimize</span><br><span class="line"> Ⓒ PureFunctionEval</span><br><span class="line"> Ⓒ SpecificOptimize</span><br><span class="line"> Ⓒ SurplusBlock</span><br><span class="line"> Ⓒ UnusedFunction</span><br><span class="line"> Ⓒ UnusedLocalArray</span><br></pre></td></tr></table></figure>

<h4 id="工作流程-6"><a href="#工作流程-6" class="headerlink" title="工作流程"></a>工作流程</h4><p>优化器接收一个 Module，按顺序执行一系列优化 Pass，对 IR 进行转换和精简，最后输出优化后的 Module。</p>
<h3 id="编码完成之后的修改-4"><a href="#编码完成之后的修改-4" class="headerlink" title="编码完成之后的修改"></a>编码完成之后的修改</h3><p>优化具体可见优化文档，这里挑几个有代表性的优化讲一下。</p>
<h4 id="工作流程-7"><a href="#工作流程-7" class="headerlink" title="工作流程"></a>工作流程</h4><p>我采用了“多轮迭代”的策略，将主要的优化 Pass 放入一个循环中执行多次，目前设定为 10 轮，以便不同优化之间能够相互促进。例如，Mem2Reg 可能会产生无用代码，随后的 CodeRemoval 可以将其删除，从而暴露更多的优化机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">optimize</span><span class="params">()</span> &#123;</span><br><span class="line">    UnusedLocalArray.run(<span class="keyword">module</span>);</span><br><span class="line">    PureFunctionEval.run(<span class="keyword">module</span>); <span class="comment">// 纯函数常量参数求值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        SurplusBlock.build(<span class="keyword">module</span>);</span><br><span class="line">        Mem2Reg.run(<span class="keyword">module</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        GVN.run(<span class="keyword">module</span>);</span><br><span class="line">        LoopUnroll.run(<span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SurplusBlock.build(<span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键优化-Pass-实现"><a href="#关键优化-Pass-实现" class="headerlink" title="关键优化 Pass 实现"></a>关键优化 Pass 实现</h3><h4 id="Mem2Reg"><a href="#Mem2Reg" class="headerlink" title="Mem2Reg"></a>Mem2Reg</h4><p>这是中端优化的核心，通过计算支配树和支配边界，插入 Phi 节点并重命名变量，将内存访问（ alloca&#x2F;load&#x2F;store ）提升为寄存器操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">optimize</span><span class="params">(Function function, <span class="type">boolean</span> simplify)</span> &#123;</span><br><span class="line">    currentFunction = function;</span><br><span class="line">    calcControlFlowGraph(); <span class="comment">// 计算 CFG</span></span><br><span class="line">    calcDominatorTree();    <span class="comment">// 计算支配树</span></span><br><span class="line">    calcDominanceFrontier();<span class="comment">// 计算支配边界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!simplify) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个整型 AllocInst 进行提升</span></span><br><span class="line">    <span class="keyword">for</span> (BasicBlock block : function.getBasicBlocks()) &#123;</span><br><span class="line">        ArrayList&lt;Instruction&gt; instructions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(block.getInstructions());</span><br><span class="line">        <span class="keyword">for</span> (Instruction instruction : instructions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instruction <span class="keyword">instanceof</span> AllocInst allocInst</span><br><span class="line">            &amp;&amp; (allocInst.getTargetType().equals(IntegerType.i32)))</span><br><span class="line">            &#123;</span><br><span class="line">                currentAlloc = allocInst;</span><br><span class="line">                initMem2Reg();</span><br><span class="line">                insertPhi(); <span class="comment">// 在支配边界插入 Phi</span></span><br><span class="line">                renameVariables(currentFunction.getEntryBlock()); <span class="comment">// 变量重命名</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LoopUnroll"><a href="#LoopUnroll" class="headerlink" title="LoopUnroll"></a>LoopUnroll</h4><p>针对小循环进行完全展开，消除循环控制开销。我主要识别单回边、单基本块的简单循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryUnroll</span><span class="params">(LoopRecord loop)</span> &#123;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">header</span> <span class="operator">=</span> loop.getEntry();</span><br><span class="line">    <span class="comment">// 仅处理单回边的循环</span></span><br><span class="line">    <span class="keyword">if</span> (loop.getEnds().size() != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查循环结构（必须是条件跳转结尾）</span></span><br><span class="line">    <span class="type">Instruction</span> <span class="variable">term</span> <span class="operator">=</span> header.getLastInstruction();</span><br><span class="line">    <span class="keyword">if</span> (!(term <span class="keyword">instanceof</span> BrInst br) || !br.isConditional()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 识别归纳变量和步长</span></span><br><span class="line">    <span class="comment">// ... (代码省略：查找 Phi 节点和更新指令)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟循环执行，如果迭代次数在阈值内（MAX_TRIP_COUNT = 32），则进行展开</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PureFunctionEval"><a href="#PureFunctionEval" class="headerlink" title="PureFunctionEval"></a>PureFunctionEval</h4><p>这是一个比较有特色的优化，针对无副作用且参数为常量的函数调用，在编译期直接计算结果。这对于递归计算非常有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryEvaluateCall</span><span class="params">(CallInst callInst, BasicBlock block, Module <span class="keyword">module</span>)</span> &#123;</span><br><span class="line">    <span class="type">Function</span> <span class="variable">calledFunc</span> <span class="operator">=</span> callInst.getCalledFunction();</span><br><span class="line">    <span class="comment">// 检查是否是可求值的纯函数（无全局变量读写、无 IO）</span></span><br><span class="line">    <span class="keyword">if</span> (!calledFunc.canReplace()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查所有参数是否为常量</span></span><br><span class="line">    ArrayList&lt;Value&gt; params = callInst.getParameters();</span><br><span class="line">    ArrayList&lt;Integer&gt; constArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Value param : params) &#123;</span><br><span class="line">        <span class="keyword">if</span> (param <span class="keyword">instanceof</span> ConstInt constInt) &#123;</span><br><span class="line">            constArgs.add(constInt.getIntValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数不是常量，无法求值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试模拟执行并缓存结果</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 替换 call 为常量结果</span></span><br><span class="line">    <span class="type">ConstInt</span> <span class="variable">constResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstInt</span>(IntegerType.i32, result);</span><br><span class="line">    callInst.replaceByNewValue(constResult);</span><br><span class="line">    block.getInstructions().remove(callInst);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PeepHole"><a href="#PeepHole" class="headerlink" title="PeepHole"></a>PeepHole</h4><p>在后端生成汇编后，通过模式匹配消除冗余指令。例如，将“比较生成 0&#x2F;1”和“根据 0&#x2F;1 跳转”融合为一条条件跳转指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将“cmp 生成 0/1 + 分支判断该结果是否为 0”融合为一条直接分支。</span></span><br><span class="line"><span class="comment">* seq $t, $a, $b</span></span><br><span class="line"><span class="comment">* beq $t, 0, L =&gt; bne $a, $b, L</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fuseCmpAndBranchOnZero</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 遍历指令序列</span></span><br><span class="line">    <span class="keyword">if</span> (cur <span class="keyword">instanceof</span> BrAsm candidate</span><br><span class="line">    &amp;&amp; (candidate.getOp() == AsmOp.BEQ || candidate.getOp() == AsmOp.BNE)</span><br><span class="line">    &amp;&amp; candidate.getRs() == cmpAsm.getRd()) &#123;</span><br><span class="line">        <span class="comment">// 检查 cmp 结果是否只被该分支使用</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 替换为新的分支指令，直接比较原操作数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>2026年1月2日完稿</p>
</blockquote>
<p>感想具体可见总结感想，这里简单说两句。</p>
<p>整体做下来，我觉得这个项目最大的收益是把可调试性先立住：每个阶段都有明确的输入输出结构，并且都有对应的落盘结果可以看。这样不管是前端的缺符号、语义的某个错误码，还是后端寄存器&#x2F;栈偏移的问题，定位路径都会短很多。</p>
<p>编译器很有意思，写编译的过程也既痛苦又快乐，不过总之还是能学到很多有用的编译知识的，我很满意了。</p>
<p>感谢为我铺路的学长们，感谢伟大的助教和老师，感谢这门课！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Jiyuan Zhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/">http://example.com/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/">编译技术</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/" title="2025-北航编译技术实验文法定义及相关说明"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">2025-北航编译技术实验文法定义及相关说明</div></div><div class="info-2"><div class="info-item-1"> 知识产权声明：以下内容由北航编译技术课程组提供，并非本人创作，本人只负责搬运，有任何问题请以课程组为准！！！  2025编译技术实验文法定义及相关说明一、概要SysY 语言是编译技术实验所完成的编译器的源语言，是 C 语言的一个子集。一个 SysY 语言源程序文件中有且仅有一个名为 main 的主函数定义，除此之外包含若干全局变量声明、常量声明和其他函数定义。SysY 语言支持 32 位有符号数 int 类型及其的一维数组类型；const 修饰符用于声明常量。 SysY 语言本身没有提供输入&#x2F;输出(I&#x2F;O)的语言构造，I&#x2F;O 是以运行时库方式提供，库函数可以在 SysY 程序中的函数内调用。部分 SysY 运行时库函数的参数类型会超出 SysY 支持的数据类型，如可以为字符串。SysY 编译器需要能处理这种情况，将 SysY 程序中这样的参数正确地传递给 SysY 运行时库。  函数：函数可以带参数也可以不带参数，参数的类型可以是 int 或其一维数组类型；函数可以返回 int 类型的值，或者不返回值（即声明为 void 类型）。当参数为 int...</div></div></div></a><a class="pagination-related" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E6%96%87%E7%AB%A0/" title="2025-北航编译技术优化文章"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover5.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">2025-北航编译技术优化文章</div></div><div class="info-2"><div class="info-item-1">对于优化，主要分为两个阶段的优化：中端和后端。中端对中间代码先进行优化，随后由后端生成目标代码，再由后端优化代码进行进一步的优化。 核心的优化工作主要集中在以下三个方面：  mem2reg：将内存变量提升为 SSA 寄存器形式，减少 load&#x2F;store 指令。 removePhi：将 Phi 指令转化为 Move 指令，以便后端 MIPS 翻译。 regAlloc：使用图着色算法进行寄存器分配。  此外，为了支撑这些核心优化，还实现了一些基础的 Pass，如死代码删除、CFG 构建、支配关系分析等。 中端优化中端优化即机器无关优化，主要针对 LLVM IR 进行处理。 死代码删除死代码删除分为两层：删除不可达基本块和删除无用指令。 删不可达基本块SurplusBlock 的实现基于图的可达性分析：从入口块出发进行 DFS，标记所有可达的块，最后将未被标记的块从函数中移除。同时，还需要清理跳转指令之后的无用指令。 1234567891011121314// 从入口块开始DFSvisited = new...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E6%96%87%E7%AB%A0/" title="2025-北航编译技术优化文章"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover5.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-06</div><div class="info-item-2">2025-北航编译技术优化文章</div></div><div class="info-2"><div class="info-item-1">对于优化，主要分为两个阶段的优化：中端和后端。中端对中间代码先进行优化，随后由后端生成目标代码，再由后端优化代码进行进一步的优化。 核心的优化工作主要集中在以下三个方面：  mem2reg：将内存变量提升为 SSA 寄存器形式，减少 load&#x2F;store 指令。 removePhi：将 Phi 指令转化为 Move 指令，以便后端 MIPS 翻译。 regAlloc：使用图着色算法进行寄存器分配。  此外，为了支撑这些核心优化，还实现了一些基础的 Pass，如死代码删除、CFG 构建、支配关系分析等。 中端优化中端优化即机器无关优化，主要针对 LLVM IR 进行处理。 死代码删除死代码删除分为两层：删除不可达基本块和删除无用指令。 删不可达基本块SurplusBlock 的实现基于图的可达性分析：从入口块出发进行 DFS，标记所有可达的块，最后将未被标记的块从函数中移除。同时，还需要清理跳转指令之后的无用指令。 1234567891011121314// 从入口块开始DFSvisited = new...</div></div></div></a><a class="pagination-related" href="/2026/01/19/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E4%B8%AD%E6%9C%9F%E6%9C%AB%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/" title="2025 北航编译原理期中期末题目回顾"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover1.JPG" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">2025 北航编译原理期中期末题目回顾</div></div><div class="info-2"><div class="info-item-1"> 本文章主要记录了2025秋季学期北航编译原理课程实验上机期中期末的回忆题目~ 题目均由本人回忆记录，可能与原题稍有偏差，但大体思路一致  期中题目1. 新增 elif 文法：具体新增文法如下： 123Stmt -&gt; &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27;Stmt 		&#123; &#x27;elif&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt &#125; 1.有elif 2.无elif 3.有多个elif		[ &#x27;else&#x27; Stmt ] // 1.有else 2.无else  解题思路：  词法分析阶段识别 elif 为一个保留关键字，建立 ELIFTK。 语法分析阶段，对于 IfStmt 语法结构，新增一个 list 用来装 elif，里面每一个单元涵盖 Cond 和 Stmt。在 toString 的时候，先对 if 语句进行 toString，然后看有没有 elif，如果有的话就仿照 if 的 toString 操作去写就可以。最后对...</div></div></div></a><a class="pagination-related" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/" title="2025-北航编译技术实验文法定义及相关说明"><img class="cover" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-06</div><div class="info-item-2">2025-北航编译技术实验文法定义及相关说明</div></div><div class="info-2"><div class="info-item-1"> 知识产权声明：以下内容由北航编译技术课程组提供，并非本人创作，本人只负责搬运，有任何问题请以课程组为准！！！  2025编译技术实验文法定义及相关说明一、概要SysY 语言是编译技术实验所完成的编译器的源语言，是 C 语言的一个子集。一个 SysY 语言源程序文件中有且仅有一个名为 main 的主函数定义，除此之外包含若干全局变量声明、常量声明和其他函数定义。SysY 语言支持 32 位有符号数 int 类型及其的一维数组类型；const 修饰符用于声明常量。 SysY 语言本身没有提供输入&#x2F;输出(I&#x2F;O)的语言构造，I&#x2F;O 是以运行时库方式提供，库函数可以在 SysY 程序中的函数内调用。部分 SysY 运行时库函数的参数类型会超出 SysY 支持的数据类型，如可以为字符串。SysY 编译器需要能处理这种情况，将 SysY 程序中这样的参数正确地传递给 SysY 运行时库。  函数：函数可以带参数也可以不带参数，参数的类型可以是 int 或其一维数组类型；函数可以返回 int 类型的值，或者不返回值（即声明为 void 类型）。当参数为 int...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Jiyuan Zhao</div><div class="author-info-description">这里是keshi的博客网站，联系作者：zhaojiyuan0721</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lucky-sheltered-boy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lucky-sheltered-boy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:23371524@buaa.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">参考编译器介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">编译器总体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">总体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.2.</span> <span class="toc-text">接口设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">3.3.</span> <span class="toc-text">文件组织</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">词法分析设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%89%8D%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.1.</span> <span class="toc-text">编码前设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">工作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">4.2.</span> <span class="toc-text">编码完成之后的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">工作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">错误处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">语法分析设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%89%8D%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">5.1.</span> <span class="toc-text">编码前设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">文件组织</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BF%AE%E6%94%B9-1"><span class="toc-number">5.2.</span> <span class="toc-text">编码完成之后的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-2"><span class="toc-number">5.2.1.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D"><span class="toc-number">5.2.2.</span> <span class="toc-text">递归下降</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-1"><span class="toc-number">5.3.</span> <span class="toc-text">错误处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">语义分析设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%89%8D%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">6.1.</span> <span class="toc-text">编码前设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-3"><span class="toc-number">6.1.1.</span> <span class="toc-text">文件组织</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-3"><span class="toc-number">6.2.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BF%AE%E6%94%B9-2"><span class="toc-number">6.3.</span> <span class="toc-text">编码完成之后的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-4"><span class="toc-number">6.3.1.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-2"><span class="toc-number">6.3.2.</span> <span class="toc-text">错误处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">代码生成设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%89%8D%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">7.1.</span> <span class="toc-text">编码前设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E9%80%89%E6%8B%A9"><span class="toc-number">7.1.1.</span> <span class="toc-text">中间代码选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LLVM-%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.2.</span> <span class="toc-text">LLVM 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value-Use"><span class="toc-number">7.1.3.</span> <span class="toc-text">Value-Use</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-4"><span class="toc-number">7.1.4.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-5"><span class="toc-number">7.1.5.</span> <span class="toc-text">工作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BF%AE%E6%94%B9-3"><span class="toc-number">7.2.</span> <span class="toc-text">编码完成之后的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">7.2.1.</span> <span class="toc-text">中间代码生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MIPS%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">7.2.2.</span> <span class="toc-text">MIPS目标代码生成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.</span> <span class="toc-text">代码优化设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%89%8D%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">8.1.</span> <span class="toc-text">编码前设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-5"><span class="toc-number">8.1.1.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-6"><span class="toc-number">8.1.2.</span> <span class="toc-text">工作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BF%AE%E6%94%B9-4"><span class="toc-number">8.2.</span> <span class="toc-text">编码完成之后的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-7"><span class="toc-number">8.2.1.</span> <span class="toc-text">工作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BC%98%E5%8C%96-Pass-%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.</span> <span class="toc-text">关键优化 Pass 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mem2Reg"><span class="toc-number">8.3.1.</span> <span class="toc-text">Mem2Reg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoopUnroll"><span class="toc-number">8.3.2.</span> <span class="toc-text">LoopUnroll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PureFunctionEval"><span class="toc-number">8.3.3.</span> <span class="toc-text">PureFunctionEval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PeepHole"><span class="toc-number">8.3.4.</span> <span class="toc-text">PeepHole</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E6%96%87%E7%AB%A0/" title="2025-北航编译技术优化文章"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover5.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-北航编译技术优化文章"/></a><div class="content"><a class="title" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E6%96%87%E7%AB%A0/" title="2025-北航编译技术优化文章">2025-北航编译技术优化文章</a><time datetime="2026-02-06T05:15:43.000Z" title="Created 2026-02-06 13:15:43">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="2025-北航编译技术设计文档"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover8.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-北航编译技术设计文档"/></a><div class="content"><a class="title" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="2025-北航编译技术设计文档">2025-北航编译技术设计文档</a><time datetime="2026-02-05T17:42:59.000Z" title="Created 2026-02-06 01:42:59">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/" title="2025-北航编译技术实验文法定义及相关说明"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-北航编译技术实验文法定义及相关说明"/></a><div class="content"><a class="title" href="/2026/02/06/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/" title="2025-北航编译技术实验文法定义及相关说明">2025-北航编译技术实验文法定义及相关说明</a><time datetime="2026-02-05T17:28:57.000Z" title="Created 2026-02-06 01:28:57">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/19/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E4%B8%AD%E6%9C%9F%E6%9C%AB%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/" title="2025 北航编译原理期中期末题目回顾"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover1.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025 北航编译原理期中期末题目回顾"/></a><div class="content"><a class="title" href="/2026/01/19/2025-%E5%8C%97%E8%88%AA%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E4%B8%AD%E6%9C%9F%E6%9C%AB%E9%A2%98%E7%9B%AE%E5%9B%9E%E9%A1%BE/" title="2025 北航编译原理期中期末题目回顾">2025 北航编译原理期中期末题目回顾</a><time datetime="2026-01-19T07:21:54.000Z" title="Created 2026-01-19 15:21:54">2026-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/23/LLM-MoE-RL-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/" title="LLM MoE RL 学习报告"><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/cover7.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LLM MoE RL 学习报告"/></a><div class="content"><a class="title" href="/2025/08/23/LLM-MoE-RL-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/" title="LLM MoE RL 学习报告">LLM MoE RL 学习报告</a><time datetime="2025-08-23T02:15:17.000Z" title="Created 2025-08-23 10:15:17">2025-08-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By Jiyuan Zhao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>